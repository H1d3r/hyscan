/*************************************************************/
/* Copyright (C) 2021 OSS Nokalva, Inc.  All rights reserved.*/
/*************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OSS NOKALVA, INC.
 * AND MAY BE USED ONLY BY DIRECT LICENSEES OF OSS NOKALVA, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED.
 * THIS COPYRIGHT STATEMENT MAY NOT BE REMOVED. */

/* This file was generated by a TRIAL version of the OSS ASN.1 Tools.
 * Applications built using this file can be executed only on the machine
 * on which you run the OSS ASN.1 compiler. */

/* Generated for: None (Trial), License 84425Z 84425Z. */
/* Abstract syntax: cbd_asn1 */
/* Created: Wed Dec 15 19:59:52 2021 */
/* ASN.1/C++ compiler version: 7.1 */
/* Code generated for runtime version 7.1 or later */
/* Compiler operating system: Windows X64 */
/* Compiler machine type: Intel 64 or AMD64 */
/* Target operating system: Windows X64 */
/* Target machine type: Intel 64 or AMD64 */
/* C++ compiler options required: -Zp8 (Microsoft) */
/* ASN.1 compiler options and file names specified:
 * -headerfile kull_m_kerberos_oss_asn1_internal.h -output
 * kull_m_kerberos_oss_asn1_internal_x64 -externalname cbd_asn1 -verbose -der
 * -root -noSampleCode -messageFormat msvc -allow universaltags
 * D:\Program Files\OSS Nokalva\asn1cpp\winx64.trial\7.1.0\asn1dflt\asn1dflt.msx64.zp8
 * KerberosV5Spec2.asn KerberosV5-PK-INIT-SPEC.asn PKIX1Explicit88.asn
 * PKINIT.asn MS-SFU-KILE.asn
 */

#define OSS_COMPILER_API_LEVEL 41
#define _OSS_CODE_FILE
#define OSS_TOED_BER
#include "kull_m_kerberos_oss_asn1_internal.h"
#include "string.h"

#include "osstype.h"

#if OSSDEBUG > 1
#define OSS_CNTX_INIT _Context_Element _element;  _element._occurrence = 0;
#define OSS_CNTX_INITZERO _Context_Element _element = {NULL, NULL, 0};
#define OSS_CNTX_ZEROOCC  _element._occurrence = 0;
#define OSS_CNTX_INCOCC  _element._occurrence++;
#define OSS_CNTX_SETOCC(OCC) _element._occurrence = OCC;
#define OSS_CNTX_DEF _Context_Element _element;
#define OSS_CNTX_POP(OSSCNAME) OSSCNAME->_oss_context_anchor._last = _element._parent;
#define OSS_CNTX_PUSH(OSSCNAME,CNTXID) _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _element._parent = OSSCNAME->_oss_context_anchor._last;\
    OSSCNAME->_oss_context_anchor._last = &_element;
#define OSS_CNTX_SET(CNTXID) _element._id = (_Context_Id *)&_context_id[CNTXID];
#define OSS_CNTX_NEW(OSSCNAME,CNTXID) _Context_Element _element;\
    _element._occurrence = 0;\
    _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _element._parent = OSSCNAME->_oss_context_anchor._last;\
    OSSCNAME->_oss_context_anchor._last = &_element;
#define OSS_CNTX_ANCHOR_SET(PDU,CNTXID) \
    _element._parent = _oss_c->_oss_context_anchor._last;\
    _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _oss_c->_oss_context_anchor._last = &_element;\
    if (!_oss_c->_oss_context_anchor._pdu_number) {\
        _oss_c->_oss_context_anchor._pdu_number = PDU;\
        _oss_c->_oss_context_anchor._pdu_id = _element._id;\
    }
#define OSS_CNTX_OSSC_DEF _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#else
#define OSS_CNTX_INIT
#define OSS_CNTX_INITZERO
#define OSS_CNTX_ZEROOCC
#define OSS_CNTX_INCOCC
#define OSS_CNTX_SETOCC(OCC)
#define OSS_CNTX_DEF
#define OSS_CNTX_POP(OSSCNAME)
#define OSS_CNTX_PUSH(OSSCNAME,CNTXID)
#define OSS_CNTX_SET(CNTXID)
#define OSS_CNTX_NEW(OSSCNAME,CNTXID)
#define OSS_CNTX_ANCHOR_SET(PDU,CNTXID) _oss_c->_oss_context_anchor._pdu_number = 0;
#endif
/* Control table object */

class cbd_asn1_TableType : public OssControlTable {
public:
    static void *internal;
    cbd_asn1_TableType();
    int destroy(void *data, OssTypeIndex typeindex);
    int copy(void *src, void **dst, OssTypeIndex typeindex);
    int equal(void *data1, void *data2, OssTypeIndex typeindex);
};

cbd_asn1_TableType::cbd_asn1_TableType() : OssControlTable(internal) {
}

int cbd_asn1_TableType::destroy(void *data, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    delete (Ticket *)data;
	    break;
	case 2:
	    delete (EncTicketPart *)data;
	    break;
	case 3:
	    delete (AS_REQ *)data;
	    break;
	case 4:
	    delete (TGS_REQ *)data;
	    break;
	case 5:
	    delete (KDC_REQ_BODY *)data;
	    break;
	case 6:
	    delete (AS_REP *)data;
	    break;
	case 7:
	    delete (TGS_REP *)data;
	    break;
	case 8:
	    delete (EncASRepPart *)data;
	    break;
	case 9:
	    delete (EncTGSRepPart *)data;
	    break;
	case 10:
	    delete (AP_REQ *)data;
	    break;
	case 11:
	    delete (Authenticator *)data;
	    break;
	case 12:
	    delete (AP_REP *)data;
	    break;
	case 13:
	    delete (EncAPRepPart *)data;
	    break;
	case 14:
	    delete (KRB_SAFE *)data;
	    break;
	case 15:
	    delete (KRB_PRIV *)data;
	    break;
	case 16:
	    delete (EncKrbPrivPart *)data;
	    break;
	case 17:
	    delete (KRB_CRED *)data;
	    break;
	case 18:
	    delete (EncKrbCredPart *)data;
	    break;
	case 19:
	    delete (KRB_ERROR *)data;
	    break;
	case 20:
	    delete (METHOD_DATA *)data;
	    break;
	case 21:
	    delete (TYPED_DATA *)data;
	    break;
	case 22:
	    delete (PA_ENC_TIMESTAMP *)data;
	    break;
	case 23:
	    delete (PA_ENC_TS_ENC *)data;
	    break;
	case 24:
	    delete (ETYPE_INFO *)data;
	    break;
	case 25:
	    delete (ETYPE_INFO2 *)data;
	    break;
	case 26:
	    delete (AD_IF_RELEVANT *)data;
	    break;
	case 27:
	    delete (AD_KDCIssued *)data;
	    break;
	case 28:
	    delete (AD_AND_OR *)data;
	    break;
	case 29:
	    delete (AD_MANDATORY_FOR_KDC *)data;
	    break;
	case 30:
	    delete (ChangePasswdData *)data;
	    break;
	case 31:
	    delete (PA_PK_AS_REQ *)data;
	    break;
	case 32:
	    delete (AuthPack *)data;
	    break;
	case 33:
	    delete (TD_TRUSTED_CERTIFIERS *)data;
	    break;
	case 34:
	    delete (TD_INVALID_CERTIFICATES *)data;
	    break;
	case 35:
	    delete (KRB5PrincipalName *)data;
	    break;
	case 36:
	    delete (AD_INITIAL_VERIFIED_CAS *)data;
	    break;
	case 37:
	    delete (PA_PK_AS_REP *)data;
	    break;
	case 38:
	    delete (KDCDHKeyInfo *)data;
	    break;
	case 39:
	    delete (ReplyKeyPack *)data;
	    break;
	case 40:
	    delete (TD_DH_PARAMETERS *)data;
	    break;
	case 41:
	    delete (Attribute *)data;
	    break;
	case 42:
	    delete (X520name *)data;
	    break;
	case 43:
	    delete (X520CommonName *)data;
	    break;
	case 44:
	    delete (X520LocalityName *)data;
	    break;
	case 45:
	    delete (X520StateOrProvinceName *)data;
	    break;
	case 46:
	    delete (X520OrganizationName *)data;
	    break;
	case 47:
	    delete (X520OrganizationalUnitName *)data;
	    break;
	case 48:
	    delete (X520Title *)data;
	    break;
	case 49:
	    delete (X520dnQualifier *)data;
	    break;
	case 50:
	    delete (X520countryName *)data;
	    break;
	case 51:
	    delete (X520SerialNumber *)data;
	    break;
	case 52:
	    delete (X520Pseudonym *)data;
	    break;
	case 53:
	    delete (DomainComponent *)data;
	    break;
	case 54:
	    delete (EmailAddress *)data;
	    break;
	case 55:
	    delete (DistinguishedName *)data;
	    break;
	case 56:
	    delete (DirectoryString *)data;
	    break;
	case 57:
	    delete (Certificate *)data;
	    break;
	case 58:
	    delete (CertificateList *)data;
	    break;
	case 59:
	    delete (ORAddress *)data;
	    break;
	case 60:
	    delete (CommonName *)data;
	    break;
	case 61:
	    delete (TeletexCommonName *)data;
	    break;
	case 62:
	    delete (TeletexOrganizationName *)data;
	    break;
	case 63:
	    delete (TeletexPersonalName *)data;
	    break;
	case 64:
	    delete (TeletexOrganizationalUnitNames *)data;
	    break;
	case 65:
	    delete (PDSName *)data;
	    break;
	case 66:
	    delete (PhysicalDeliveryCountryName *)data;
	    break;
	case 67:
	    delete (PostalCode *)data;
	    break;
	case 68:
	    delete (PhysicalDeliveryOfficeName *)data;
	    break;
	case 69:
	    delete (PhysicalDeliveryOfficeNumber *)data;
	    break;
	case 70:
	    delete (ExtensionORAddressComponents *)data;
	    break;
	case 71:
	    delete (PhysicalDeliveryPersonalName *)data;
	    break;
	case 72:
	    delete (PhysicalDeliveryOrganizationName *)data;
	    break;
	case 73:
	    delete (ExtensionPhysicalDeliveryAddressComponents *)data;
	    break;
	case 74:
	    delete (UnformattedPostalAddress *)data;
	    break;
	case 75:
	    delete (StreetAddress *)data;
	    break;
	case 76:
	    delete (PostOfficeBoxAddress *)data;
	    break;
	case 77:
	    delete (PosteRestanteAddress *)data;
	    break;
	case 78:
	    delete (UniquePostalName *)data;
	    break;
	case 79:
	    delete (LocalPostalAttributes *)data;
	    break;
	case 80:
	    delete (ExtendedNetworkAddress *)data;
	    break;
	case 81:
	    asn1Free(data);
	    break;
	case 82:
	    delete (TeletexDomainDefinedAttributes *)data;
	    break;
	case 83:
	    delete (AuthPack_OLD *)data;
	    break;
	case 84:
	    delete (KERB_REPLY_KEY_PACKAGE *)data;
	    break;
	case 85:
	    delete (PA_FOR_USER_ENC *)data;
	    break;
	case 86:
	    delete (PA_S4U_X509_USER *)data;
	    break;
	case 87:
	    delete (PA_PAC_OPTIONS *)data;
	    break;
	case 88:
	    delete (KERB_PA_PAC_REQUEST *)data;
	    break;
	case 89:
	    delete (KERB_LOCAL *)data;
	    break;
	case 90:
	    delete (KERB_AD_RESTRICTION_ENTRY *)data;
	    break;
	case 91:
	    asn1Free(data);
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    return 0;
}

int cbd_asn1_TableType::copy(void *src, void **dst, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    *dst = new Ticket(*(Ticket *)src);
	    break;
	case 2:
	    *dst = new EncTicketPart(*(EncTicketPart *)src);
	    break;
	case 3:
	    *dst = new AS_REQ(*(AS_REQ *)src);
	    break;
	case 4:
	    *dst = new TGS_REQ(*(TGS_REQ *)src);
	    break;
	case 5:
	    *dst = new KDC_REQ_BODY(*(KDC_REQ_BODY *)src);
	    break;
	case 6:
	    *dst = new AS_REP(*(AS_REP *)src);
	    break;
	case 7:
	    *dst = new TGS_REP(*(TGS_REP *)src);
	    break;
	case 8:
	    *dst = new EncASRepPart(*(EncASRepPart *)src);
	    break;
	case 9:
	    *dst = new EncTGSRepPart(*(EncTGSRepPart *)src);
	    break;
	case 10:
	    *dst = new AP_REQ(*(AP_REQ *)src);
	    break;
	case 11:
	    *dst = new Authenticator(*(Authenticator *)src);
	    break;
	case 12:
	    *dst = new AP_REP(*(AP_REP *)src);
	    break;
	case 13:
	    *dst = new EncAPRepPart(*(EncAPRepPart *)src);
	    break;
	case 14:
	    *dst = new KRB_SAFE(*(KRB_SAFE *)src);
	    break;
	case 15:
	    *dst = new KRB_PRIV(*(KRB_PRIV *)src);
	    break;
	case 16:
	    *dst = new EncKrbPrivPart(*(EncKrbPrivPart *)src);
	    break;
	case 17:
	    *dst = new KRB_CRED(*(KRB_CRED *)src);
	    break;
	case 18:
	    *dst = new EncKrbCredPart(*(EncKrbCredPart *)src);
	    break;
	case 19:
	    *dst = new KRB_ERROR(*(KRB_ERROR *)src);
	    break;
	case 20:
	    *dst = new METHOD_DATA(*(METHOD_DATA *)src);
	    break;
	case 21:
	    *dst = new TYPED_DATA(*(TYPED_DATA *)src);
	    break;
	case 22:
	    *dst = new PA_ENC_TIMESTAMP(*(PA_ENC_TIMESTAMP *)src);
	    break;
	case 23:
	    *dst = new PA_ENC_TS_ENC(*(PA_ENC_TS_ENC *)src);
	    break;
	case 24:
	    *dst = new ETYPE_INFO(*(ETYPE_INFO *)src);
	    break;
	case 25:
	    *dst = new ETYPE_INFO2(*(ETYPE_INFO2 *)src);
	    break;
	case 26:
	    *dst = new AD_IF_RELEVANT(*(AD_IF_RELEVANT *)src);
	    break;
	case 27:
	    *dst = new AD_KDCIssued(*(AD_KDCIssued *)src);
	    break;
	case 28:
	    *dst = new AD_AND_OR(*(AD_AND_OR *)src);
	    break;
	case 29:
	    *dst = new AD_MANDATORY_FOR_KDC(*(AD_MANDATORY_FOR_KDC *)src);
	    break;
	case 30:
	    *dst = new ChangePasswdData(*(ChangePasswdData *)src);
	    break;
	case 31:
	    *dst = new PA_PK_AS_REQ(*(PA_PK_AS_REQ *)src);
	    break;
	case 32:
	    *dst = new AuthPack(*(AuthPack *)src);
	    break;
	case 33:
	    *dst = new TD_TRUSTED_CERTIFIERS(*(TD_TRUSTED_CERTIFIERS *)src);
	    break;
	case 34:
	    *dst = new TD_INVALID_CERTIFICATES(*(TD_INVALID_CERTIFICATES *)src);
	    break;
	case 35:
	    *dst = new KRB5PrincipalName(*(KRB5PrincipalName *)src);
	    break;
	case 36:
	    *dst = new AD_INITIAL_VERIFIED_CAS(*(AD_INITIAL_VERIFIED_CAS *)src);
	    break;
	case 37:
	    *dst = new PA_PK_AS_REP(*(PA_PK_AS_REP *)src);
	    break;
	case 38:
	    *dst = new KDCDHKeyInfo(*(KDCDHKeyInfo *)src);
	    break;
	case 39:
	    *dst = new ReplyKeyPack(*(ReplyKeyPack *)src);
	    break;
	case 40:
	    *dst = new TD_DH_PARAMETERS(*(TD_DH_PARAMETERS *)src);
	    break;
	case 41:
	    *dst = new Attribute(*(Attribute *)src);
	    break;
	case 42:
	    *dst = new X520name(*(X520name *)src);
	    break;
	case 43:
	    *dst = new X520CommonName(*(X520CommonName *)src);
	    break;
	case 44:
	    *dst = new X520LocalityName(*(X520LocalityName *)src);
	    break;
	case 45:
	    *dst = new X520StateOrProvinceName(*(X520StateOrProvinceName *)src);
	    break;
	case 46:
	    *dst = new X520OrganizationName(*(X520OrganizationName *)src);
	    break;
	case 47:
	    *dst = new X520OrganizationalUnitName(*(X520OrganizationalUnitName *)src);
	    break;
	case 48:
	    *dst = new X520Title(*(X520Title *)src);
	    break;
	case 49:
	    *dst = new X520dnQualifier(*(X520dnQualifier *)src);
	    break;
	case 50:
	    *dst = new X520countryName(*(X520countryName *)src);
	    break;
	case 51:
	    *dst = new X520SerialNumber(*(X520SerialNumber *)src);
	    break;
	case 52:
	    *dst = new X520Pseudonym(*(X520Pseudonym *)src);
	    break;
	case 53:
	    *dst = new DomainComponent(*(DomainComponent *)src);
	    break;
	case 54:
	    *dst = new EmailAddress(*(EmailAddress *)src);
	    break;
	case 55:
	    *dst = new DistinguishedName(*(DistinguishedName *)src);
	    break;
	case 56:
	    *dst = new DirectoryString(*(DirectoryString *)src);
	    break;
	case 57:
	    *dst = new Certificate(*(Certificate *)src);
	    break;
	case 58:
	    *dst = new CertificateList(*(CertificateList *)src);
	    break;
	case 59:
	    *dst = new ORAddress(*(ORAddress *)src);
	    break;
	case 60:
	    *dst = new CommonName(*(CommonName *)src);
	    break;
	case 61:
	    *dst = new TeletexCommonName(*(TeletexCommonName *)src);
	    break;
	case 62:
	    *dst = new TeletexOrganizationName(*(TeletexOrganizationName *)src);
	    break;
	case 63:
	    *dst = new TeletexPersonalName(*(TeletexPersonalName *)src);
	    break;
	case 64:
	    *dst = new TeletexOrganizationalUnitNames(*(TeletexOrganizationalUnitNames *)src);
	    break;
	case 65:
	    *dst = new PDSName(*(PDSName *)src);
	    break;
	case 66:
	    *dst = new PhysicalDeliveryCountryName(*(PhysicalDeliveryCountryName *)src);
	    break;
	case 67:
	    *dst = new PostalCode(*(PostalCode *)src);
	    break;
	case 68:
	    *dst = new PhysicalDeliveryOfficeName(*(PhysicalDeliveryOfficeName *)src);
	    break;
	case 69:
	    *dst = new PhysicalDeliveryOfficeNumber(*(PhysicalDeliveryOfficeNumber *)src);
	    break;
	case 70:
	    *dst = new ExtensionORAddressComponents(*(ExtensionORAddressComponents *)src);
	    break;
	case 71:
	    *dst = new PhysicalDeliveryPersonalName(*(PhysicalDeliveryPersonalName *)src);
	    break;
	case 72:
	    *dst = new PhysicalDeliveryOrganizationName(*(PhysicalDeliveryOrganizationName *)src);
	    break;
	case 73:
	    *dst = new ExtensionPhysicalDeliveryAddressComponents(*(ExtensionPhysicalDeliveryAddressComponents *)src);
	    break;
	case 74:
	    *dst = new UnformattedPostalAddress(*(UnformattedPostalAddress *)src);
	    break;
	case 75:
	    *dst = new StreetAddress(*(StreetAddress *)src);
	    break;
	case 76:
	    *dst = new PostOfficeBoxAddress(*(PostOfficeBoxAddress *)src);
	    break;
	case 77:
	    *dst = new PosteRestanteAddress(*(PosteRestanteAddress *)src);
	    break;
	case 78:
	    *dst = new UniquePostalName(*(UniquePostalName *)src);
	    break;
	case 79:
	    *dst = new LocalPostalAttributes(*(LocalPostalAttributes *)src);
	    break;
	case 80:
	    *dst = new ExtendedNetworkAddress(*(ExtendedNetworkAddress *)src);
	    break;
	case 81:
	    *dst = osscppMalloc(sizeof(TerminalType));
	    if (*dst)
		**(TerminalType **)dst = *(TerminalType *)src;
	    break;
	case 82:
	    *dst = new TeletexDomainDefinedAttributes(*(TeletexDomainDefinedAttributes *)src);
	    break;
	case 83:
	    *dst = new AuthPack_OLD(*(AuthPack_OLD *)src);
	    break;
	case 84:
	    *dst = new KERB_REPLY_KEY_PACKAGE(*(KERB_REPLY_KEY_PACKAGE *)src);
	    break;
	case 85:
	    *dst = new PA_FOR_USER_ENC(*(PA_FOR_USER_ENC *)src);
	    break;
	case 86:
	    *dst = new PA_S4U_X509_USER(*(PA_S4U_X509_USER *)src);
	    break;
	case 87:
	    *dst = new PA_PAC_OPTIONS(*(PA_PAC_OPTIONS *)src);
	    break;
	case 88:
	    *dst = new KERB_PA_PAC_REQUEST(*(KERB_PA_PAC_REQUEST *)src);
	    break;
	case 89:
	    *dst = new KERB_LOCAL(*(KERB_LOCAL *)src);
	    break;
	case 90:
	    *dst = new KERB_AD_RESTRICTION_ENTRY(*(KERB_AD_RESTRICTION_ENTRY *)src);
	    break;
	case 91:
	    *dst = osscppMalloc(sizeof(PA_SUPPORTED_ENCTYPES));
	    if (*dst)
		**(PA_SUPPORTED_ENCTYPES **)dst = *(PA_SUPPORTED_ENCTYPES *)src;
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    if (*dst == 0)
	return OSS_NO_MEMORY;
    return 0;
}

int cbd_asn1_TableType::equal(void *data1, void *data2, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    return *(Ticket *)data1 == *(Ticket *)data2;
	case 2:
	    return *(EncTicketPart *)data1 == *(EncTicketPart *)data2;
	case 3:
	    return *(AS_REQ *)data1 == *(AS_REQ *)data2;
	case 4:
	    return *(TGS_REQ *)data1 == *(TGS_REQ *)data2;
	case 5:
	    return *(KDC_REQ_BODY *)data1 == *(KDC_REQ_BODY *)data2;
	case 6:
	    return *(AS_REP *)data1 == *(AS_REP *)data2;
	case 7:
	    return *(TGS_REP *)data1 == *(TGS_REP *)data2;
	case 8:
	    return *(EncASRepPart *)data1 == *(EncASRepPart *)data2;
	case 9:
	    return *(EncTGSRepPart *)data1 == *(EncTGSRepPart *)data2;
	case 10:
	    return *(AP_REQ *)data1 == *(AP_REQ *)data2;
	case 11:
	    return *(Authenticator *)data1 == *(Authenticator *)data2;
	case 12:
	    return *(AP_REP *)data1 == *(AP_REP *)data2;
	case 13:
	    return *(EncAPRepPart *)data1 == *(EncAPRepPart *)data2;
	case 14:
	    return *(KRB_SAFE *)data1 == *(KRB_SAFE *)data2;
	case 15:
	    return *(KRB_PRIV *)data1 == *(KRB_PRIV *)data2;
	case 16:
	    return *(EncKrbPrivPart *)data1 == *(EncKrbPrivPart *)data2;
	case 17:
	    return *(KRB_CRED *)data1 == *(KRB_CRED *)data2;
	case 18:
	    return *(EncKrbCredPart *)data1 == *(EncKrbCredPart *)data2;
	case 19:
	    return *(KRB_ERROR *)data1 == *(KRB_ERROR *)data2;
	case 20:
	    return *(METHOD_DATA *)data1 == *(METHOD_DATA *)data2;
	case 21:
	    return *(TYPED_DATA *)data1 == *(TYPED_DATA *)data2;
	case 22:
	    return *(PA_ENC_TIMESTAMP *)data1 == *(PA_ENC_TIMESTAMP *)data2;
	case 23:
	    return *(PA_ENC_TS_ENC *)data1 == *(PA_ENC_TS_ENC *)data2;
	case 24:
	    return *(ETYPE_INFO *)data1 == *(ETYPE_INFO *)data2;
	case 25:
	    return *(ETYPE_INFO2 *)data1 == *(ETYPE_INFO2 *)data2;
	case 26:
	    return *(AD_IF_RELEVANT *)data1 == *(AD_IF_RELEVANT *)data2;
	case 27:
	    return *(AD_KDCIssued *)data1 == *(AD_KDCIssued *)data2;
	case 28:
	    return *(AD_AND_OR *)data1 == *(AD_AND_OR *)data2;
	case 29:
	    return *(AD_MANDATORY_FOR_KDC *)data1 == *(AD_MANDATORY_FOR_KDC *)data2;
	case 30:
	    return *(ChangePasswdData *)data1 == *(ChangePasswdData *)data2;
	case 31:
	    return *(PA_PK_AS_REQ *)data1 == *(PA_PK_AS_REQ *)data2;
	case 32:
	    return *(AuthPack *)data1 == *(AuthPack *)data2;
	case 33:
	    return *(TD_TRUSTED_CERTIFIERS *)data1 == *(TD_TRUSTED_CERTIFIERS *)data2;
	case 34:
	    return *(TD_INVALID_CERTIFICATES *)data1 == *(TD_INVALID_CERTIFICATES *)data2;
	case 35:
	    return *(KRB5PrincipalName *)data1 == *(KRB5PrincipalName *)data2;
	case 36:
	    return *(AD_INITIAL_VERIFIED_CAS *)data1 == *(AD_INITIAL_VERIFIED_CAS *)data2;
	case 37:
	    return *(PA_PK_AS_REP *)data1 == *(PA_PK_AS_REP *)data2;
	case 38:
	    return *(KDCDHKeyInfo *)data1 == *(KDCDHKeyInfo *)data2;
	case 39:
	    return *(ReplyKeyPack *)data1 == *(ReplyKeyPack *)data2;
	case 40:
	    return *(TD_DH_PARAMETERS *)data1 == *(TD_DH_PARAMETERS *)data2;
	case 41:
	    return *(Attribute *)data1 == *(Attribute *)data2;
	case 42:
	    return *(X520name *)data1 == *(X520name *)data2;
	case 43:
	    return *(X520CommonName *)data1 == *(X520CommonName *)data2;
	case 44:
	    return *(X520LocalityName *)data1 == *(X520LocalityName *)data2;
	case 45:
	    return *(X520StateOrProvinceName *)data1 == *(X520StateOrProvinceName *)data2;
	case 46:
	    return *(X520OrganizationName *)data1 == *(X520OrganizationName *)data2;
	case 47:
	    return *(X520OrganizationalUnitName *)data1 == *(X520OrganizationalUnitName *)data2;
	case 48:
	    return *(X520Title *)data1 == *(X520Title *)data2;
	case 49:
	    return *(X520dnQualifier *)data1 == *(X520dnQualifier *)data2;
	case 50:
	    return *(X520countryName *)data1 == *(X520countryName *)data2;
	case 51:
	    return *(X520SerialNumber *)data1 == *(X520SerialNumber *)data2;
	case 52:
	    return *(X520Pseudonym *)data1 == *(X520Pseudonym *)data2;
	case 53:
	    return *(DomainComponent *)data1 == *(DomainComponent *)data2;
	case 54:
	    return *(EmailAddress *)data1 == *(EmailAddress *)data2;
	case 55:
	    return *(DistinguishedName *)data1 == *(DistinguishedName *)data2;
	case 56:
	    return *(DirectoryString *)data1 == *(DirectoryString *)data2;
	case 57:
	    return *(Certificate *)data1 == *(Certificate *)data2;
	case 58:
	    return *(CertificateList *)data1 == *(CertificateList *)data2;
	case 59:
	    return *(ORAddress *)data1 == *(ORAddress *)data2;
	case 60:
	    return *(CommonName *)data1 == *(CommonName *)data2;
	case 61:
	    return *(TeletexCommonName *)data1 == *(TeletexCommonName *)data2;
	case 62:
	    return *(TeletexOrganizationName *)data1 == *(TeletexOrganizationName *)data2;
	case 63:
	    return *(TeletexPersonalName *)data1 == *(TeletexPersonalName *)data2;
	case 64:
	    return *(TeletexOrganizationalUnitNames *)data1 == *(TeletexOrganizationalUnitNames *)data2;
	case 65:
	    return *(PDSName *)data1 == *(PDSName *)data2;
	case 66:
	    return *(PhysicalDeliveryCountryName *)data1 == *(PhysicalDeliveryCountryName *)data2;
	case 67:
	    return *(PostalCode *)data1 == *(PostalCode *)data2;
	case 68:
	    return *(PhysicalDeliveryOfficeName *)data1 == *(PhysicalDeliveryOfficeName *)data2;
	case 69:
	    return *(PhysicalDeliveryOfficeNumber *)data1 == *(PhysicalDeliveryOfficeNumber *)data2;
	case 70:
	    return *(ExtensionORAddressComponents *)data1 == *(ExtensionORAddressComponents *)data2;
	case 71:
	    return *(PhysicalDeliveryPersonalName *)data1 == *(PhysicalDeliveryPersonalName *)data2;
	case 72:
	    return *(PhysicalDeliveryOrganizationName *)data1 == *(PhysicalDeliveryOrganizationName *)data2;
	case 73:
	    return *(ExtensionPhysicalDeliveryAddressComponents *)data1 == *(ExtensionPhysicalDeliveryAddressComponents *)data2;
	case 74:
	    return *(UnformattedPostalAddress *)data1 == *(UnformattedPostalAddress *)data2;
	case 75:
	    return *(StreetAddress *)data1 == *(StreetAddress *)data2;
	case 76:
	    return *(PostOfficeBoxAddress *)data1 == *(PostOfficeBoxAddress *)data2;
	case 77:
	    return *(PosteRestanteAddress *)data1 == *(PosteRestanteAddress *)data2;
	case 78:
	    return *(UniquePostalName *)data1 == *(UniquePostalName *)data2;
	case 79:
	    return *(LocalPostalAttributes *)data1 == *(LocalPostalAttributes *)data2;
	case 80:
	    return *(ExtendedNetworkAddress *)data1 == *(ExtendedNetworkAddress *)data2;
	case 81:
	    return *(TerminalType *)data1 == *(TerminalType *)data2;
	case 82:
	    return *(TeletexDomainDefinedAttributes *)data1 == *(TeletexDomainDefinedAttributes *)data2;
	case 83:
	    return *(AuthPack_OLD *)data1 == *(AuthPack_OLD *)data2;
	case 84:
	    return *(KERB_REPLY_KEY_PACKAGE *)data1 == *(KERB_REPLY_KEY_PACKAGE *)data2;
	case 85:
	    return *(PA_FOR_USER_ENC *)data1 == *(PA_FOR_USER_ENC *)data2;
	case 86:
	    return *(PA_S4U_X509_USER *)data1 == *(PA_S4U_X509_USER *)data2;
	case 87:
	    return *(PA_PAC_OPTIONS *)data1 == *(PA_PAC_OPTIONS *)data2;
	case 88:
	    return *(KERB_PA_PAC_REQUEST *)data1 == *(KERB_PA_PAC_REQUEST *)data2;
	case 89:
	    return *(KERB_LOCAL *)data1 == *(KERB_LOCAL *)data2;
	case 90:
	    return *(KERB_AD_RESTRICTION_ENTRY *)data1 == *(KERB_AD_RESTRICTION_ENTRY *)data2;
	case 91:
	    return *(PA_SUPPORTED_ENCTYPES *)data1 == *(PA_SUPPORTED_ENCTYPES *)data2;
    }
    return 0;
}

static cbd_asn1_TableType cbd_asn1_Table;

/* Representation types */

/* Auxiliary data structures and functions for class __shared1 */

class __shared1_member {
public:
    __shared1_member *next;
    __shared1::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared1_member();
    __shared1_member(const __shared1::component & val);
};

void *__shared1_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared1_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared1_member::__shared1_member() {
}

__shared1_member::__shared1_member(const __shared1::component & val) {
    value = val;
}

static void *__shared1_copy(void *that) {
    return new __shared1_member(((__shared1_member *)that)->value);
}

static void __shared1_destroy(void *that) {
    delete (__shared1_member *)that;
}

static int __shared1_compare(void *val1, void *val2) {
    return (((__shared1_member *)val1)->value == ((__shared1_member *)val2)->value);
}

/* Constructors */

__shared1::__shared1() {
}

__shared1::__shared1(const __shared1 & that) {
    OSSTRY {
	do_copy(that, &__shared1_copy);
    } OSSCLEAN(__shared1)
}

/* Destructor */

__shared1::~__shared1() {
    do_destroy(&__shared1_destroy);
}

/* Operators: assignment, equality, inequality */

__shared1 & __shared1::operator = (const __shared1 & that) {
    do_destroy(&__shared1_destroy);
    do_copy(that, &__shared1_copy);
    return *this;
}

int __shared1::operator == (const __shared1 & that) const {
    return do_compare(that, &__shared1_compare);
}

int __shared1::operator != (const __shared1 & that) const {
    return !do_compare(that, &__shared1_compare);
}

/* Locate ("At" etc) methods */

__shared1::component *__shared1::at(OssIndex pos) {
    return &((__shared1_member *)pos)->value;
}

const __shared1::component *__shared1::at(OssIndex pos) const {
    return &((__shared1_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared1::prepend(const component & val) {
    __shared1_member *newrec = new __shared1_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared1::prepend(__shared1 *seq) {
    return do_prepend(seq);
}

OssIndex __shared1::insert_after(OssIndex pos, const component & val) {
    __shared1_member *newrec = new __shared1_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared1::insert_after(OssIndex pos, __shared1 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared1::remove_front() {
    __shared1_member *extr = (__shared1_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared1_destroy(extr);
    return 0;
}

int __shared1::remove_after(OssIndex pos) {
    __shared1_member *extr = (__shared1_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared1_destroy(extr);
    return 0;
}

/* Extract methods */

__shared1 *__shared1::extract_after(OssIndex begin, OssIndex end) {
    return (__shared1 *)do_extract_after(begin, end);
}

void *PrincipalName::operator new(size_t size) {
    return ossNewFunc(size);
}

void PrincipalName::operator delete(void *ptr) {
    asn1Free(ptr);
}

PrincipalName::PrincipalName() {
    memset(this, 0, sizeof(PrincipalName));
}

PrincipalName::PrincipalName(const PrincipalName & that) {
    OSSTRY {
	name_type_field = that.name_type_field;
	name_string_field = that.name_string_field;
    } OSSCLEAN(PrincipalName)
}

PrincipalName::PrincipalName(name_type name_type_val, const name_string & name_string_val) {
    OSSTRY {
	name_type_field = name_type_val;
	name_string_field = name_string_val;
    } OSSCLEAN(PrincipalName)
}

PrincipalName & PrincipalName::operator = (const PrincipalName & that) {
    if (this == &that)
	return *this;
    name_type_field = that.name_type_field;
    name_string_field = that.name_string_field;
    return *this;
}

int PrincipalName::operator == (const PrincipalName & that) const {
    if (name_type_field != that.name_type_field)
	return 0;
    if (name_string_field != that.name_string_field)
	return 0;
    return 1;
}

int PrincipalName::operator != (const PrincipalName & that) const {
    return !(operator ==(that));
}

PrincipalName::name_type & PrincipalName::get_name_type() {
    return name_type_field;
}

PrincipalName::name_type PrincipalName::get_name_type() const {
    return name_type_field;
}

void PrincipalName::set_name_type(name_type name_type_val) {
    name_type_field = name_type_val;
}

PrincipalName::name_string & PrincipalName::get_name_string() {
    return name_string_field;
}

const PrincipalName::name_string & PrincipalName::get_name_string() const {
    return name_string_field;
}

void PrincipalName::set_name_string(const name_string & name_string_val) {
    name_string_field = name_string_val;
}

void *HostAddress::operator new(size_t size) {
    return ossNewFunc(size);
}

void HostAddress::operator delete(void *ptr) {
    asn1Free(ptr);
}

HostAddress::HostAddress() {
    memset(this, 0, sizeof(HostAddress));
}

HostAddress::HostAddress(const HostAddress & that) {
    OSSTRY {
	addr_type_field = that.addr_type_field;
	address_field = that.address_field;
    } OSSCLEAN(HostAddress)
}

HostAddress::HostAddress(addr_type addr_type_val, const address & address_val) {
    OSSTRY {
	addr_type_field = addr_type_val;
	address_field = address_val;
    } OSSCLEAN(HostAddress)
}

HostAddress & HostAddress::operator = (const HostAddress & that) {
    if (this == &that)
	return *this;
    addr_type_field = that.addr_type_field;
    address_field = that.address_field;
    return *this;
}

int HostAddress::operator == (const HostAddress & that) const {
    if (addr_type_field != that.addr_type_field)
	return 0;
    if (address_field != that.address_field)
	return 0;
    return 1;
}

int HostAddress::operator != (const HostAddress & that) const {
    return !(operator ==(that));
}

HostAddress::addr_type & HostAddress::get_addr_type() {
    return addr_type_field;
}

HostAddress::addr_type HostAddress::get_addr_type() const {
    return addr_type_field;
}

void HostAddress::set_addr_type(addr_type addr_type_val) {
    addr_type_field = addr_type_val;
}

HostAddress::address & HostAddress::get_address() {
    return address_field;
}

const HostAddress::address & HostAddress::get_address() const {
    return address_field;
}

void HostAddress::set_address(const address & address_val) {
    address_field = address_val;
}

/* Auxiliary data structures and functions for class HostAddresses */

class HostAddresses_member {
public:
    HostAddresses_member *next;
    HostAddresses::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    HostAddresses_member();
    HostAddresses_member(const HostAddresses::component & val);
};

void *HostAddresses_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void HostAddresses_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

HostAddresses_member::HostAddresses_member() {
}

HostAddresses_member::HostAddresses_member(const HostAddresses::component & val) {
    value = val;
}

static void *HostAddresses_copy(void *that) {
    return new HostAddresses_member(((HostAddresses_member *)that)->value);
}

static void HostAddresses_destroy(void *that) {
    delete (HostAddresses_member *)that;
}

static int HostAddresses_compare(void *val1, void *val2) {
    return (((HostAddresses_member *)val1)->value == ((HostAddresses_member *)val2)->value);
}

/* Constructors */

HostAddresses::HostAddresses() {
}

HostAddresses::HostAddresses(const HostAddresses & that) {
    OSSTRY {
	do_copy(that, &HostAddresses_copy);
    } OSSCLEAN(HostAddresses)
}

/* Destructor */

HostAddresses::~HostAddresses() {
    do_destroy(&HostAddresses_destroy);
}

/* Operators: assignment, equality, inequality */

HostAddresses & HostAddresses::operator = (const HostAddresses & that) {
    do_destroy(&HostAddresses_destroy);
    do_copy(that, &HostAddresses_copy);
    return *this;
}

int HostAddresses::operator == (const HostAddresses & that) const {
    return do_compare(that, &HostAddresses_compare);
}

int HostAddresses::operator != (const HostAddresses & that) const {
    return !do_compare(that, &HostAddresses_compare);
}

/* Locate ("At" etc) methods */

HostAddresses::component *HostAddresses::at(OssIndex pos) {
    return &((HostAddresses_member *)pos)->value;
}

const HostAddresses::component *HostAddresses::at(OssIndex pos) const {
    return &((HostAddresses_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex HostAddresses::prepend(const component & val) {
    HostAddresses_member *newrec = new HostAddresses_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex HostAddresses::prepend(HostAddresses *seq) {
    return do_prepend(seq);
}

OssIndex HostAddresses::insert_after(OssIndex pos, const component & val) {
    HostAddresses_member *newrec = new HostAddresses_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex HostAddresses::insert_after(OssIndex pos, HostAddresses *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int HostAddresses::remove_front() {
    HostAddresses_member *extr = (HostAddresses_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    HostAddresses_destroy(extr);
    return 0;
}

int HostAddresses::remove_after(OssIndex pos) {
    HostAddresses_member *extr = (HostAddresses_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    HostAddresses_destroy(extr);
    return 0;
}

/* Extract methods */

HostAddresses *HostAddresses::extract_after(OssIndex begin, OssIndex end) {
    return (HostAddresses *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __shared2 */

class __shared2_member {
public:
    __shared2_member *next;
    __shared2::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared2_member();
    __shared2_member(const __shared2::component & val);
};

void *__shared2_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared2_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared2_member::__shared2_member() {
}

__shared2_member::__shared2_member(const __shared2::component & val) {
    value = val;
}

static void *__shared2_copy(void *that) {
    return new __shared2_member(((__shared2_member *)that)->value);
}

static void __shared2_destroy(void *that) {
    delete (__shared2_member *)that;
}

static int __shared2_compare(void *val1, void *val2) {
    return (((__shared2_member *)val1)->value == ((__shared2_member *)val2)->value);
}

/* Constructors */

__shared2::__shared2() {
}

__shared2::__shared2(const __shared2 & that) {
    OSSTRY {
	do_copy(that, &__shared2_copy);
    } OSSCLEAN(__shared2)
}

/* Destructor */

__shared2::~__shared2() {
    do_destroy(&__shared2_destroy);
}

/* Operators: assignment, equality, inequality */

__shared2 & __shared2::operator = (const __shared2 & that) {
    do_destroy(&__shared2_destroy);
    do_copy(that, &__shared2_copy);
    return *this;
}

int __shared2::operator == (const __shared2 & that) const {
    return do_compare(that, &__shared2_compare);
}

int __shared2::operator != (const __shared2 & that) const {
    return !do_compare(that, &__shared2_compare);
}

/* Locate ("At" etc) methods */

__shared2::component *__shared2::at(OssIndex pos) {
    return &((__shared2_member *)pos)->value;
}

const __shared2::component *__shared2::at(OssIndex pos) const {
    return &((__shared2_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared2::prepend(const component & val) {
    __shared2_member *newrec = new __shared2_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared2::prepend(__shared2 *seq) {
    return do_prepend(seq);
}

OssIndex __shared2::insert_after(OssIndex pos, const component & val) {
    __shared2_member *newrec = new __shared2_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared2::insert_after(OssIndex pos, __shared2 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared2::remove_front() {
    __shared2_member *extr = (__shared2_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared2_destroy(extr);
    return 0;
}

int __shared2::remove_after(OssIndex pos) {
    __shared2_member *extr = (__shared2_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared2_destroy(extr);
    return 0;
}

/* Extract methods */

__shared2 *__shared2::extract_after(OssIndex begin, OssIndex end) {
    return (__shared2 *)do_extract_after(begin, end);
}

void *__seq1::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq1::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq1::__seq1() {
    memset(this, 0, sizeof(__seq1));
}

__seq1::__seq1(const __seq1 & that) {
    OSSTRY {
	ad_type_field = that.ad_type_field;
	ad_data_field = that.ad_data_field;
    } OSSCLEAN(__seq1)
}

__seq1::__seq1(ad_type ad_type_val, const ad_data & ad_data_val) {
    OSSTRY {
	ad_type_field = ad_type_val;
	ad_data_field = ad_data_val;
    } OSSCLEAN(__seq1)
}

__seq1 & __seq1::operator = (const __seq1 & that) {
    if (this == &that)
	return *this;
    ad_type_field = that.ad_type_field;
    ad_data_field = that.ad_data_field;
    return *this;
}

int __seq1::operator == (const __seq1 & that) const {
    if (ad_type_field != that.ad_type_field)
	return 0;
    if (ad_data_field != that.ad_data_field)
	return 0;
    return 1;
}

int __seq1::operator != (const __seq1 & that) const {
    return !(operator ==(that));
}

__seq1::ad_type & __seq1::get_ad_type() {
    return ad_type_field;
}

__seq1::ad_type __seq1::get_ad_type() const {
    return ad_type_field;
}

void __seq1::set_ad_type(ad_type ad_type_val) {
    ad_type_field = ad_type_val;
}

__seq1::ad_data & __seq1::get_ad_data() {
    return ad_data_field;
}

const __seq1::ad_data & __seq1::get_ad_data() const {
    return ad_data_field;
}

void __seq1::set_ad_data(const ad_data & ad_data_val) {
    ad_data_field = ad_data_val;
}

void *PA_DATA::operator new(size_t size) {
    return ossNewFunc(size);
}

void PA_DATA::operator delete(void *ptr) {
    asn1Free(ptr);
}

PA_DATA::PA_DATA() {
    memset(this, 0, sizeof(PA_DATA));
}

PA_DATA::PA_DATA(const PA_DATA & that) {
    OSSTRY {
	padata_type_field = that.padata_type_field;
	padata_value_field = that.padata_value_field;
    } OSSCLEAN(PA_DATA)
}

PA_DATA::PA_DATA(padata_type padata_type_val, const padata_value & padata_value_val) {
    OSSTRY {
	padata_type_field = padata_type_val;
	padata_value_field = padata_value_val;
    } OSSCLEAN(PA_DATA)
}

PA_DATA & PA_DATA::operator = (const PA_DATA & that) {
    if (this == &that)
	return *this;
    padata_type_field = that.padata_type_field;
    padata_value_field = that.padata_value_field;
    return *this;
}

int PA_DATA::operator == (const PA_DATA & that) const {
    if (padata_type_field != that.padata_type_field)
	return 0;
    if (padata_value_field != that.padata_value_field)
	return 0;
    return 1;
}

int PA_DATA::operator != (const PA_DATA & that) const {
    return !(operator ==(that));
}

PA_DATA::padata_type & PA_DATA::get_padata_type() {
    return padata_type_field;
}

PA_DATA::padata_type PA_DATA::get_padata_type() const {
    return padata_type_field;
}

void PA_DATA::set_padata_type(padata_type padata_type_val) {
    padata_type_field = padata_type_val;
}

PA_DATA::padata_value & PA_DATA::get_padata_value() {
    return padata_value_field;
}

const PA_DATA::padata_value & PA_DATA::get_padata_value() const {
    return padata_value_field;
}

void PA_DATA::set_padata_value(const padata_value & padata_value_val) {
    padata_value_field = padata_value_val;
}

void *__shared3::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared3::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared3::__shared3() {
    memset(this, 0, sizeof(__shared3));
}

__shared3::__shared3(const __shared3 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	etype_field = that.etype_field;
	kvno_field = that.kvno_field;
	cipher_field = that.cipher_field;
    } OSSCLEAN(__shared3)
}

__shared3::__shared3(etype etype_val, kvno kvno_val, const cipher & cipher_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	etype_field = etype_val;
	kvno_field = kvno_val;
	cipher_field = cipher_val;
    } OSSCLEAN(__shared3)
}

__shared3::__shared3(etype etype_val, const cipher & cipher_val) {
    OSSTRY {
	bit_mask = 0;
	etype_field = etype_val;
	cipher_field = cipher_val;
    } OSSCLEAN(__shared3)
}

__shared3 & __shared3::operator = (const __shared3 & that) {
    if (this == &that)
	return *this;
    this->~__shared3();
    bit_mask = that.bit_mask;
    etype_field = that.etype_field;
    kvno_field = that.kvno_field;
    cipher_field = that.cipher_field;
    return *this;
}

int __shared3::operator == (const __shared3 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (etype_field != that.etype_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (kvno_field != that.kvno_field)
	    return 0;
    }
    if (cipher_field != that.cipher_field)
	return 0;
    return 1;
}

int __shared3::operator != (const __shared3 & that) const {
    return !(operator ==(that));
}

__shared3::etype & __shared3::get_etype() {
    return etype_field;
}

__shared3::etype __shared3::get_etype() const {
    return etype_field;
}

void __shared3::set_etype(etype etype_val) {
    etype_field = etype_val;
}

__shared3::kvno *__shared3::get_kvno() {
    if (bit_mask & 0x80000000)
	return &kvno_field;
    else
	return 0;
}

const __shared3::kvno *__shared3::get_kvno() const {
    if (bit_mask & 0x80000000)
	return &kvno_field;
    else
	return 0;
}

void __shared3::set_kvno(kvno kvno_val) {
    bit_mask |= 0x80000000;
    kvno_field = kvno_val;
}

int __shared3::kvno_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared3::omit_kvno() {
    bit_mask &= ~0x80000000;
}

__shared3::cipher & __shared3::get_cipher() {
    return cipher_field;
}

const __shared3::cipher & __shared3::get_cipher() const {
    return cipher_field;
}

void __shared3::set_cipher(const cipher & cipher_val) {
    cipher_field = cipher_val;
}

void *EncryptionKey::operator new(size_t size) {
    return ossNewFunc(size);
}

void EncryptionKey::operator delete(void *ptr) {
    asn1Free(ptr);
}

EncryptionKey::EncryptionKey() {
    memset(this, 0, sizeof(EncryptionKey));
}

EncryptionKey::EncryptionKey(const EncryptionKey & that) {
    OSSTRY {
	keytype_field = that.keytype_field;
	keyvalue_field = that.keyvalue_field;
    } OSSCLEAN(EncryptionKey)
}

EncryptionKey::EncryptionKey(keytype keytype_val, const keyvalue & keyvalue_val) {
    OSSTRY {
	keytype_field = keytype_val;
	keyvalue_field = keyvalue_val;
    } OSSCLEAN(EncryptionKey)
}

EncryptionKey & EncryptionKey::operator = (const EncryptionKey & that) {
    if (this == &that)
	return *this;
    keytype_field = that.keytype_field;
    keyvalue_field = that.keyvalue_field;
    return *this;
}

int EncryptionKey::operator == (const EncryptionKey & that) const {
    if (keytype_field != that.keytype_field)
	return 0;
    if (keyvalue_field != that.keyvalue_field)
	return 0;
    return 1;
}

int EncryptionKey::operator != (const EncryptionKey & that) const {
    return !(operator ==(that));
}

EncryptionKey::keytype & EncryptionKey::get_keytype() {
    return keytype_field;
}

EncryptionKey::keytype EncryptionKey::get_keytype() const {
    return keytype_field;
}

void EncryptionKey::set_keytype(keytype keytype_val) {
    keytype_field = keytype_val;
}

EncryptionKey::keyvalue & EncryptionKey::get_keyvalue() {
    return keyvalue_field;
}

const EncryptionKey::keyvalue & EncryptionKey::get_keyvalue() const {
    return keyvalue_field;
}

void EncryptionKey::set_keyvalue(const keyvalue & keyvalue_val) {
    keyvalue_field = keyvalue_val;
}

void *Checksum::operator new(size_t size) {
    return ossNewFunc(size);
}

void Checksum::operator delete(void *ptr) {
    asn1Free(ptr);
}

Checksum::Checksum() {
    memset(this, 0, sizeof(Checksum));
}

Checksum::Checksum(const Checksum & that) {
    OSSTRY {
	cksumtype_field = that.cksumtype_field;
	checksum_field = that.checksum_field;
    } OSSCLEAN(Checksum)
}

Checksum::Checksum(cksumtype cksumtype_val, const checksum & checksum_val) {
    OSSTRY {
	cksumtype_field = cksumtype_val;
	checksum_field = checksum_val;
    } OSSCLEAN(Checksum)
}

Checksum & Checksum::operator = (const Checksum & that) {
    if (this == &that)
	return *this;
    cksumtype_field = that.cksumtype_field;
    checksum_field = that.checksum_field;
    return *this;
}

int Checksum::operator == (const Checksum & that) const {
    if (cksumtype_field != that.cksumtype_field)
	return 0;
    if (checksum_field != that.checksum_field)
	return 0;
    return 1;
}

int Checksum::operator != (const Checksum & that) const {
    return !(operator ==(that));
}

Checksum::cksumtype & Checksum::get_cksumtype() {
    return cksumtype_field;
}

Checksum::cksumtype Checksum::get_cksumtype() const {
    return cksumtype_field;
}

void Checksum::set_cksumtype(cksumtype cksumtype_val) {
    cksumtype_field = cksumtype_val;
}

Checksum::checksum & Checksum::get_checksum() {
    return checksum_field;
}

const Checksum::checksum & Checksum::get_checksum() const {
    return checksum_field;
}

void Checksum::set_checksum(const checksum & checksum_val) {
    checksum_field = checksum_val;
}

void *Ticket::operator new(size_t size) {
    return ossNewFunc(size);
}

void Ticket::operator delete(void *ptr) {
    asn1Free(ptr);
}

Ticket::Ticket() {
    memset(this, 0, sizeof(Ticket));
}

Ticket::Ticket(const Ticket & that) {
    OSSTRY {
	tkt_vno_field = that.tkt_vno_field;
	realm_field = that.realm_field;
	sname_field = that.sname_field;
	enc_part_field = that.enc_part_field;
    } OSSCLEAN(Ticket)
}

Ticket::Ticket(tkt_vno tkt_vno_val, const realm & realm_val, const sname & sname_val, 
    const enc_part & enc_part_val) {
    OSSTRY {
	tkt_vno_field = tkt_vno_val;
	realm_field = realm_val;
	sname_field = sname_val;
	enc_part_field = enc_part_val;
    } OSSCLEAN(Ticket)
}

Ticket & Ticket::operator = (const Ticket & that) {
    if (this == &that)
	return *this;
    tkt_vno_field = that.tkt_vno_field;
    realm_field = that.realm_field;
    sname_field = that.sname_field;
    enc_part_field = that.enc_part_field;
    return *this;
}

int Ticket::operator == (const Ticket & that) const {
    if (tkt_vno_field != that.tkt_vno_field)
	return 0;
    if (realm_field != that.realm_field)
	return 0;
    if (sname_field != that.sname_field)
	return 0;
    if (enc_part_field != that.enc_part_field)
	return 0;
    return 1;
}

int Ticket::operator != (const Ticket & that) const {
    return !(operator ==(that));
}

Ticket::tkt_vno & Ticket::get_tkt_vno() {
    return tkt_vno_field;
}

Ticket::tkt_vno Ticket::get_tkt_vno() const {
    return tkt_vno_field;
}

void Ticket::set_tkt_vno(tkt_vno tkt_vno_val) {
    tkt_vno_field = tkt_vno_val;
}

Ticket::realm & Ticket::get_realm() {
    return realm_field;
}

const Ticket::realm & Ticket::get_realm() const {
    return realm_field;
}

void Ticket::set_realm(const realm & realm_val) {
    realm_field = realm_val;
}

Ticket::sname & Ticket::get_sname() {
    return sname_field;
}

const Ticket::sname & Ticket::get_sname() const {
    return sname_field;
}

void Ticket::set_sname(const sname & sname_val) {
    sname_field = sname_val;
}

Ticket::enc_part & Ticket::get_enc_part() {
    return enc_part_field;
}

const Ticket::enc_part & Ticket::get_enc_part() const {
    return enc_part_field;
}

void Ticket::set_enc_part(const enc_part & enc_part_val) {
    enc_part_field = enc_part_val;
}

void *TransitedEncoding::operator new(size_t size) {
    return ossNewFunc(size);
}

void TransitedEncoding::operator delete(void *ptr) {
    asn1Free(ptr);
}

TransitedEncoding::TransitedEncoding() {
    memset(this, 0, sizeof(TransitedEncoding));
}

TransitedEncoding::TransitedEncoding(const TransitedEncoding & that) {
    OSSTRY {
	tr_type_field = that.tr_type_field;
	contents_field = that.contents_field;
    } OSSCLEAN(TransitedEncoding)
}

TransitedEncoding::TransitedEncoding(tr_type tr_type_val, const contents & contents_val) {
    OSSTRY {
	tr_type_field = tr_type_val;
	contents_field = contents_val;
    } OSSCLEAN(TransitedEncoding)
}

TransitedEncoding & TransitedEncoding::operator = (const TransitedEncoding & that) {
    if (this == &that)
	return *this;
    tr_type_field = that.tr_type_field;
    contents_field = that.contents_field;
    return *this;
}

int TransitedEncoding::operator == (const TransitedEncoding & that) const {
    if (tr_type_field != that.tr_type_field)
	return 0;
    if (contents_field != that.contents_field)
	return 0;
    return 1;
}

int TransitedEncoding::operator != (const TransitedEncoding & that) const {
    return !(operator ==(that));
}

TransitedEncoding::tr_type & TransitedEncoding::get_tr_type() {
    return tr_type_field;
}

TransitedEncoding::tr_type TransitedEncoding::get_tr_type() const {
    return tr_type_field;
}

void TransitedEncoding::set_tr_type(tr_type tr_type_val) {
    tr_type_field = tr_type_val;
}

TransitedEncoding::contents & TransitedEncoding::get_contents() {
    return contents_field;
}

const TransitedEncoding::contents & TransitedEncoding::get_contents() const {
    return contents_field;
}

void TransitedEncoding::set_contents(const contents & contents_val) {
    contents_field = contents_val;
}

void *EncTicketPart::operator new(size_t size) {
    return ossNewFunc(size);
}

void EncTicketPart::operator delete(void *ptr) {
    asn1Free(ptr);
}

EncTicketPart::EncTicketPart() {
    memset(this, 0, sizeof(EncTicketPart));
}

EncTicketPart::EncTicketPart(const EncTicketPart & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	flags_field = that.flags_field;
	key_field = that.key_field;
	crealm_field = that.crealm_field;
	cname_field = that.cname_field;
	transited_field = that.transited_field;
	authtime_field = that.authtime_field;
	starttime_field = that.starttime_field;
	endtime_field = that.endtime_field;
	renew_till_field = that.renew_till_field;
	caddr_field = that.caddr_field;
	authorization_data_field = that.authorization_data_field;
    } OSSCLEAN(EncTicketPart)
}

EncTicketPart::EncTicketPart(const flags & flags_val, const key & key_val, const crealm & crealm_val, 
    const cname & cname_val, const transited & transited_val, const authtime & authtime_val, 
    const starttime & starttime_val, const endtime & endtime_val, const renew_till & renew_till_val, 
    const caddr & caddr_val, const authorization_data & authorization_data_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	flags_field = flags_val;
	key_field = key_val;
	crealm_field = crealm_val;
	cname_field = cname_val;
	transited_field = transited_val;
	authtime_field = authtime_val;
	starttime_field = starttime_val;
	endtime_field = endtime_val;
	renew_till_field = renew_till_val;
	caddr_field = caddr_val;
	authorization_data_field = authorization_data_val;
    } OSSCLEAN(EncTicketPart)
}

EncTicketPart::EncTicketPart(const flags & flags_val, const key & key_val, const crealm & crealm_val, 
    const cname & cname_val, const transited & transited_val, const authtime & authtime_val, 
    const endtime & endtime_val) {
    OSSTRY {
	bit_mask = 0;
	flags_field = flags_val;
	key_field = key_val;
	crealm_field = crealm_val;
	cname_field = cname_val;
	transited_field = transited_val;
	authtime_field = authtime_val;
	endtime_field = endtime_val;
    } OSSCLEAN(EncTicketPart)
}

EncTicketPart & EncTicketPart::operator = (const EncTicketPart & that) {
    if (this == &that)
	return *this;
    this->~EncTicketPart();
    bit_mask = that.bit_mask;
    flags_field = that.flags_field;
    key_field = that.key_field;
    crealm_field = that.crealm_field;
    cname_field = that.cname_field;
    transited_field = that.transited_field;
    authtime_field = that.authtime_field;
    starttime_field = that.starttime_field;
    endtime_field = that.endtime_field;
    renew_till_field = that.renew_till_field;
    caddr_field = that.caddr_field;
    authorization_data_field = that.authorization_data_field;
    return *this;
}

int EncTicketPart::operator == (const EncTicketPart & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (flags_field != that.flags_field)
	return 0;
    if (key_field != that.key_field)
	return 0;
    if (crealm_field != that.crealm_field)
	return 0;
    if (cname_field != that.cname_field)
	return 0;
    if (transited_field != that.transited_field)
	return 0;
    if (authtime_field != that.authtime_field)
	return 0;
    if (starttime_field != that.starttime_field)
	return 0;
    if (endtime_field != that.endtime_field)
	return 0;
    if (renew_till_field != that.renew_till_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (caddr_field != that.caddr_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (authorization_data_field != that.authorization_data_field)
	    return 0;
    }
    return 1;
}

int EncTicketPart::operator != (const EncTicketPart & that) const {
    return !(operator ==(that));
}

EncTicketPart::flags & EncTicketPart::get_flags() {
    return flags_field;
}

const EncTicketPart::flags & EncTicketPart::get_flags() const {
    return flags_field;
}

void EncTicketPart::set_flags(const flags & flags_val) {
    flags_field = flags_val;
}

EncTicketPart::key & EncTicketPart::get_key() {
    return key_field;
}

const EncTicketPart::key & EncTicketPart::get_key() const {
    return key_field;
}

void EncTicketPart::set_key(const key & key_val) {
    key_field = key_val;
}

EncTicketPart::crealm & EncTicketPart::get_crealm() {
    return crealm_field;
}

const EncTicketPart::crealm & EncTicketPart::get_crealm() const {
    return crealm_field;
}

void EncTicketPart::set_crealm(const crealm & crealm_val) {
    crealm_field = crealm_val;
}

EncTicketPart::cname & EncTicketPart::get_cname() {
    return cname_field;
}

const EncTicketPart::cname & EncTicketPart::get_cname() const {
    return cname_field;
}

void EncTicketPart::set_cname(const cname & cname_val) {
    cname_field = cname_val;
}

EncTicketPart::transited & EncTicketPart::get_transited() {
    return transited_field;
}

const EncTicketPart::transited & EncTicketPart::get_transited() const {
    return transited_field;
}

void EncTicketPart::set_transited(const transited & transited_val) {
    transited_field = transited_val;
}

EncTicketPart::authtime & EncTicketPart::get_authtime() {
    return authtime_field;
}

const EncTicketPart::authtime & EncTicketPart::get_authtime() const {
    return authtime_field;
}

void EncTicketPart::set_authtime(const authtime & authtime_val) {
    authtime_field = authtime_val;
}

EncTicketPart::starttime *EncTicketPart::get_starttime() {
    if (*(char **)&starttime_field)
	return &starttime_field;
    else
	return 0;
}

const EncTicketPart::starttime *EncTicketPart::get_starttime() const {
    if (*(char **)&starttime_field)
	return &starttime_field;
    else
	return 0;
}

void EncTicketPart::set_starttime(const starttime & starttime_val) {
    starttime_field = starttime_val;
}

int EncTicketPart::starttime_is_present() const {
    return !!(*(char **)&starttime_field);
}

void EncTicketPart::omit_starttime() {
    starttime_field.~OssGeneralizedTime();
}

EncTicketPart::endtime & EncTicketPart::get_endtime() {
    return endtime_field;
}

const EncTicketPart::endtime & EncTicketPart::get_endtime() const {
    return endtime_field;
}

void EncTicketPart::set_endtime(const endtime & endtime_val) {
    endtime_field = endtime_val;
}

EncTicketPart::renew_till *EncTicketPart::get_renew_till() {
    if (*(char **)&renew_till_field)
	return &renew_till_field;
    else
	return 0;
}

const EncTicketPart::renew_till *EncTicketPart::get_renew_till() const {
    if (*(char **)&renew_till_field)
	return &renew_till_field;
    else
	return 0;
}

void EncTicketPart::set_renew_till(const renew_till & renew_till_val) {
    renew_till_field = renew_till_val;
}

int EncTicketPart::renew_till_is_present() const {
    return !!(*(char **)&renew_till_field);
}

void EncTicketPart::omit_renew_till() {
    renew_till_field.~OssGeneralizedTime();
}

EncTicketPart::caddr *EncTicketPart::get_caddr() {
    if (bit_mask & 0x80000000)
	return &caddr_field;
    else
	return 0;
}

const EncTicketPart::caddr *EncTicketPart::get_caddr() const {
    if (bit_mask & 0x80000000)
	return &caddr_field;
    else
	return 0;
}

void EncTicketPart::set_caddr(const caddr & caddr_val) {
    bit_mask |= 0x80000000;
    caddr_field = caddr_val;
}

int EncTicketPart::caddr_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void EncTicketPart::omit_caddr() {
    caddr_field.~HostAddresses();
    bit_mask &= ~0x80000000;
}

EncTicketPart::authorization_data *EncTicketPart::get_authorization_data() {
    if (bit_mask & 0x40000000)
	return &authorization_data_field;
    else
	return 0;
}

const EncTicketPart::authorization_data *EncTicketPart::get_authorization_data() const {
    if (bit_mask & 0x40000000)
	return &authorization_data_field;
    else
	return 0;
}

void EncTicketPart::set_authorization_data(const authorization_data & authorization_data_val) {
    bit_mask |= 0x40000000;
    authorization_data_field = authorization_data_val;
}

int EncTicketPart::authorization_data_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void EncTicketPart::omit_authorization_data() {
    authorization_data_field.~__shared2();
    bit_mask &= ~0x40000000;
}

/* Auxiliary data structures and functions for class __seqof2 */

class __seqof2_member {
public:
    __seqof2_member *next;
    __seqof2::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
};

void *__seqof2_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof2_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

static void *__seqof2_copy(void *that) {
    __seqof2_member *result = new __seqof2_member;
    if (result)
	result->value = ((__seqof2_member *)that)->value;
    return result;
}

static void __seqof2_destroy(void *that) {
    delete (__seqof2_member *)that;
}

static int __seqof2_compare(void *val1, void *val2) {
    return (((__seqof2_member *)val1)->value == ((__seqof2_member *)val2)->value);
}

/* Constructors */

__seqof2::__seqof2() {
}

__seqof2::__seqof2(const __seqof2 & that) {
    OSSTRY {
	do_copy(that, &__seqof2_copy);
    } OSSCLEAN(__seqof2)
}

/* Destructor */

__seqof2::~__seqof2() {
    do_destroy(&__seqof2_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof2 & __seqof2::operator = (const __seqof2 & that) {
    do_destroy(&__seqof2_destroy);
    do_copy(that, &__seqof2_copy);
    return *this;
}

int __seqof2::operator == (const __seqof2 & that) const {
    return do_compare(that, &__seqof2_compare);
}

int __seqof2::operator != (const __seqof2 & that) const {
    return !do_compare(that, &__seqof2_compare);
}

/* Locate ("At" etc) methods */

__seqof2::component *__seqof2::at(OssIndex pos) {
    return &((__seqof2_member *)pos)->value;
}

const __seqof2::component *__seqof2::at(OssIndex pos) const {
    return &((__seqof2_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof2::prepend(component val) {
    __seqof2_member *newrec = new __seqof2_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_prepend(newrec);
}

OssIndex __seqof2::prepend(__seqof2 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof2::insert_after(OssIndex pos, component val) {
    __seqof2_member *newrec = new __seqof2_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof2::insert_after(OssIndex pos, __seqof2 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof2::remove_front() {
    __seqof2_member *extr = (__seqof2_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof2_destroy(extr);
    return 0;
}

int __seqof2::remove_after(OssIndex pos) {
    __seqof2_member *extr = (__seqof2_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof2_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof2 *__seqof2::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof2 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __shared4 */

class __shared4_member {
public:
    __shared4_member *next;
    __shared4::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared4_member();
    __shared4_member(const __shared4::component & val);
};

void *__shared4_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared4_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared4_member::__shared4_member() {
}

__shared4_member::__shared4_member(const __shared4::component & val) {
    value = val;
}

static void *__shared4_copy(void *that) {
    return new __shared4_member(((__shared4_member *)that)->value);
}

static void __shared4_destroy(void *that) {
    delete (__shared4_member *)that;
}

static int __shared4_compare(void *val1, void *val2) {
    return (((__shared4_member *)val1)->value == ((__shared4_member *)val2)->value);
}

/* Constructors */

__shared4::__shared4() {
}

__shared4::__shared4(const __shared4 & that) {
    OSSTRY {
	do_copy(that, &__shared4_copy);
    } OSSCLEAN(__shared4)
}

/* Destructor */

__shared4::~__shared4() {
    do_destroy(&__shared4_destroy);
}

/* Operators: assignment, equality, inequality */

__shared4 & __shared4::operator = (const __shared4 & that) {
    do_destroy(&__shared4_destroy);
    do_copy(that, &__shared4_copy);
    return *this;
}

int __shared4::operator == (const __shared4 & that) const {
    return do_compare(that, &__shared4_compare);
}

int __shared4::operator != (const __shared4 & that) const {
    return !do_compare(that, &__shared4_compare);
}

/* Locate ("At" etc) methods */

__shared4::component *__shared4::at(OssIndex pos) {
    return &((__shared4_member *)pos)->value;
}

const __shared4::component *__shared4::at(OssIndex pos) const {
    return &((__shared4_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared4::prepend(const component & val) {
    __shared4_member *newrec = new __shared4_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared4::prepend(__shared4 *seq) {
    return do_prepend(seq);
}

OssIndex __shared4::insert_after(OssIndex pos, const component & val) {
    __shared4_member *newrec = new __shared4_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared4::insert_after(OssIndex pos, __shared4 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared4::remove_front() {
    __shared4_member *extr = (__shared4_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared4_destroy(extr);
    return 0;
}

int __shared4::remove_after(OssIndex pos) {
    __shared4_member *extr = (__shared4_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared4_destroy(extr);
    return 0;
}

/* Extract methods */

__shared4 *__shared4::extract_after(OssIndex begin, OssIndex end) {
    return (__shared4 *)do_extract_after(begin, end);
}

void *KDC_REQ_BODY::operator new(size_t size) {
    return ossNewFunc(size);
}

void KDC_REQ_BODY::operator delete(void *ptr) {
    asn1Free(ptr);
}

KDC_REQ_BODY::KDC_REQ_BODY() {
    memset(this, 0, sizeof(KDC_REQ_BODY));
}

KDC_REQ_BODY::KDC_REQ_BODY(const KDC_REQ_BODY & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	kdc_options_field = that.kdc_options_field;
	cname_field = that.cname_field;
	realm_field = that.realm_field;
	sname_field = that.sname_field;
	from_field = that.from_field;
	till_field = that.till_field;
	rtime_field = that.rtime_field;
	nonce_field = that.nonce_field;
	etype_field = that.etype_field;
	addresses_field = that.addresses_field;
	enc_authorization_data_field = that.enc_authorization_data_field;
	additional_tickets_field = that.additional_tickets_field;
    } OSSCLEAN(KDC_REQ_BODY)
}

KDC_REQ_BODY::KDC_REQ_BODY(const kdc_options & kdc_options_val, const cname & cname_val, 
    const realm & realm_val, const sname & sname_val, const from & from_val, const till & till_val, 
    const rtime & rtime_val, nonce nonce_val, const etype & etype_val, const addresses & addresses_val, 
    const enc_authorization_data & enc_authorization_data_val, const additional_tickets & additional_tickets_val) {
    OSSTRY {
	bit_mask = 0xf8000000;
	kdc_options_field = kdc_options_val;
	cname_field = cname_val;
	realm_field = realm_val;
	sname_field = sname_val;
	from_field = from_val;
	till_field = till_val;
	rtime_field = rtime_val;
	nonce_field = nonce_val;
	etype_field = etype_val;
	addresses_field = addresses_val;
	enc_authorization_data_field = enc_authorization_data_val;
	additional_tickets_field = additional_tickets_val;
    } OSSCLEAN(KDC_REQ_BODY)
}

KDC_REQ_BODY::KDC_REQ_BODY(const kdc_options & kdc_options_val, const realm & realm_val, 
    const till & till_val, nonce nonce_val, const etype & etype_val) {
    OSSTRY {
	bit_mask = 0;
	kdc_options_field = kdc_options_val;
	realm_field = realm_val;
	till_field = till_val;
	nonce_field = nonce_val;
	etype_field = etype_val;
    } OSSCLEAN(KDC_REQ_BODY)
}

KDC_REQ_BODY & KDC_REQ_BODY::operator = (const KDC_REQ_BODY & that) {
    if (this == &that)
	return *this;
    this->~KDC_REQ_BODY();
    bit_mask = that.bit_mask;
    kdc_options_field = that.kdc_options_field;
    cname_field = that.cname_field;
    realm_field = that.realm_field;
    sname_field = that.sname_field;
    from_field = that.from_field;
    till_field = that.till_field;
    rtime_field = that.rtime_field;
    nonce_field = that.nonce_field;
    etype_field = that.etype_field;
    addresses_field = that.addresses_field;
    enc_authorization_data_field = that.enc_authorization_data_field;
    additional_tickets_field = that.additional_tickets_field;
    return *this;
}

int KDC_REQ_BODY::operator == (const KDC_REQ_BODY & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (kdc_options_field != that.kdc_options_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (cname_field != that.cname_field)
	    return 0;
    }
    if (realm_field != that.realm_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (sname_field != that.sname_field)
	    return 0;
    }
    if (from_field != that.from_field)
	return 0;
    if (till_field != that.till_field)
	return 0;
    if (rtime_field != that.rtime_field)
	return 0;
    if (nonce_field != that.nonce_field)
	return 0;
    if (etype_field != that.etype_field)
	return 0;
    if (bit_mask & 0x20000000) {
	if (addresses_field != that.addresses_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (enc_authorization_data_field != that.enc_authorization_data_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (additional_tickets_field != that.additional_tickets_field)
	    return 0;
    }
    return 1;
}

int KDC_REQ_BODY::operator != (const KDC_REQ_BODY & that) const {
    return !(operator ==(that));
}

KDC_REQ_BODY::kdc_options & KDC_REQ_BODY::get_kdc_options() {
    return kdc_options_field;
}

const KDC_REQ_BODY::kdc_options & KDC_REQ_BODY::get_kdc_options() const {
    return kdc_options_field;
}

void KDC_REQ_BODY::set_kdc_options(const kdc_options & kdc_options_val) {
    kdc_options_field = kdc_options_val;
}

KDC_REQ_BODY::cname *KDC_REQ_BODY::get_cname() {
    if (bit_mask & 0x80000000)
	return &cname_field;
    else
	return 0;
}

const KDC_REQ_BODY::cname *KDC_REQ_BODY::get_cname() const {
    if (bit_mask & 0x80000000)
	return &cname_field;
    else
	return 0;
}

void KDC_REQ_BODY::set_cname(const cname & cname_val) {
    bit_mask |= 0x80000000;
    cname_field = cname_val;
}

int KDC_REQ_BODY::cname_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void KDC_REQ_BODY::omit_cname() {
    cname_field.~PrincipalName();
    bit_mask &= ~0x80000000;
}

KDC_REQ_BODY::realm & KDC_REQ_BODY::get_realm() {
    return realm_field;
}

const KDC_REQ_BODY::realm & KDC_REQ_BODY::get_realm() const {
    return realm_field;
}

void KDC_REQ_BODY::set_realm(const realm & realm_val) {
    realm_field = realm_val;
}

KDC_REQ_BODY::sname *KDC_REQ_BODY::get_sname() {
    if (bit_mask & 0x40000000)
	return &sname_field;
    else
	return 0;
}

const KDC_REQ_BODY::sname *KDC_REQ_BODY::get_sname() const {
    if (bit_mask & 0x40000000)
	return &sname_field;
    else
	return 0;
}

void KDC_REQ_BODY::set_sname(const sname & sname_val) {
    bit_mask |= 0x40000000;
    sname_field = sname_val;
}

int KDC_REQ_BODY::sname_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void KDC_REQ_BODY::omit_sname() {
    sname_field.~PrincipalName();
    bit_mask &= ~0x40000000;
}

KDC_REQ_BODY::from *KDC_REQ_BODY::get_from() {
    if (*(char **)&from_field)
	return &from_field;
    else
	return 0;
}

const KDC_REQ_BODY::from *KDC_REQ_BODY::get_from() const {
    if (*(char **)&from_field)
	return &from_field;
    else
	return 0;
}

void KDC_REQ_BODY::set_from(const from & from_val) {
    from_field = from_val;
}

int KDC_REQ_BODY::from_is_present() const {
    return !!(*(char **)&from_field);
}

void KDC_REQ_BODY::omit_from() {
    from_field.~OssGeneralizedTime();
}

KDC_REQ_BODY::till & KDC_REQ_BODY::get_till() {
    return till_field;
}

const KDC_REQ_BODY::till & KDC_REQ_BODY::get_till() const {
    return till_field;
}

void KDC_REQ_BODY::set_till(const till & till_val) {
    till_field = till_val;
}

KDC_REQ_BODY::rtime *KDC_REQ_BODY::get_rtime() {
    if (*(char **)&rtime_field)
	return &rtime_field;
    else
	return 0;
}

const KDC_REQ_BODY::rtime *KDC_REQ_BODY::get_rtime() const {
    if (*(char **)&rtime_field)
	return &rtime_field;
    else
	return 0;
}

void KDC_REQ_BODY::set_rtime(const rtime & rtime_val) {
    rtime_field = rtime_val;
}

int KDC_REQ_BODY::rtime_is_present() const {
    return !!(*(char **)&rtime_field);
}

void KDC_REQ_BODY::omit_rtime() {
    rtime_field.~OssGeneralizedTime();
}

KDC_REQ_BODY::nonce & KDC_REQ_BODY::get_nonce() {
    return nonce_field;
}

KDC_REQ_BODY::nonce KDC_REQ_BODY::get_nonce() const {
    return nonce_field;
}

void KDC_REQ_BODY::set_nonce(nonce nonce_val) {
    nonce_field = nonce_val;
}

KDC_REQ_BODY::etype & KDC_REQ_BODY::get_etype() {
    return etype_field;
}

const KDC_REQ_BODY::etype & KDC_REQ_BODY::get_etype() const {
    return etype_field;
}

void KDC_REQ_BODY::set_etype(const etype & etype_val) {
    etype_field = etype_val;
}

KDC_REQ_BODY::addresses *KDC_REQ_BODY::get_addresses() {
    if (bit_mask & 0x20000000)
	return &addresses_field;
    else
	return 0;
}

const KDC_REQ_BODY::addresses *KDC_REQ_BODY::get_addresses() const {
    if (bit_mask & 0x20000000)
	return &addresses_field;
    else
	return 0;
}

void KDC_REQ_BODY::set_addresses(const addresses & addresses_val) {
    bit_mask |= 0x20000000;
    addresses_field = addresses_val;
}

int KDC_REQ_BODY::addresses_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void KDC_REQ_BODY::omit_addresses() {
    addresses_field.~HostAddresses();
    bit_mask &= ~0x20000000;
}

KDC_REQ_BODY::enc_authorization_data *KDC_REQ_BODY::get_enc_authorization_data() {
    if (bit_mask & 0x10000000)
	return &enc_authorization_data_field;
    else
	return 0;
}

const KDC_REQ_BODY::enc_authorization_data *KDC_REQ_BODY::get_enc_authorization_data() const {
    if (bit_mask & 0x10000000)
	return &enc_authorization_data_field;
    else
	return 0;
}

void KDC_REQ_BODY::set_enc_authorization_data(const enc_authorization_data & enc_authorization_data_val) {
    bit_mask |= 0x10000000;
    enc_authorization_data_field = enc_authorization_data_val;
}

int KDC_REQ_BODY::enc_authorization_data_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void KDC_REQ_BODY::omit_enc_authorization_data() {
    enc_authorization_data_field.~__shared3();
    bit_mask &= ~0x10000000;
}

KDC_REQ_BODY::additional_tickets *KDC_REQ_BODY::get_additional_tickets() {
    if (bit_mask & 0x8000000)
	return &additional_tickets_field;
    else
	return 0;
}

const KDC_REQ_BODY::additional_tickets *KDC_REQ_BODY::get_additional_tickets() const {
    if (bit_mask & 0x8000000)
	return &additional_tickets_field;
    else
	return 0;
}

void KDC_REQ_BODY::set_additional_tickets(const additional_tickets & additional_tickets_val) {
    bit_mask |= 0x8000000;
    additional_tickets_field = additional_tickets_val;
}

int KDC_REQ_BODY::additional_tickets_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void KDC_REQ_BODY::omit_additional_tickets() {
    additional_tickets_field.~__shared4();
    bit_mask &= ~0x8000000;
}

/* Auxiliary data structures and functions for class __shared5 */

class __shared5_member {
public:
    __shared5_member *next;
    __shared5::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared5_member();
    __shared5_member(const __shared5::component & val);
};

void *__shared5_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared5_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared5_member::__shared5_member() {
}

__shared5_member::__shared5_member(const __shared5::component & val) {
    value = val;
}

static void *__shared5_copy(void *that) {
    return new __shared5_member(((__shared5_member *)that)->value);
}

static void __shared5_destroy(void *that) {
    delete (__shared5_member *)that;
}

static int __shared5_compare(void *val1, void *val2) {
    return (((__shared5_member *)val1)->value == ((__shared5_member *)val2)->value);
}

/* Constructors */

__shared5::__shared5() {
}

__shared5::__shared5(const __shared5 & that) {
    OSSTRY {
	do_copy(that, &__shared5_copy);
    } OSSCLEAN(__shared5)
}

/* Destructor */

__shared5::~__shared5() {
    do_destroy(&__shared5_destroy);
}

/* Operators: assignment, equality, inequality */

__shared5 & __shared5::operator = (const __shared5 & that) {
    do_destroy(&__shared5_destroy);
    do_copy(that, &__shared5_copy);
    return *this;
}

int __shared5::operator == (const __shared5 & that) const {
    return do_compare(that, &__shared5_compare);
}

int __shared5::operator != (const __shared5 & that) const {
    return !do_compare(that, &__shared5_compare);
}

/* Locate ("At" etc) methods */

__shared5::component *__shared5::at(OssIndex pos) {
    return &((__shared5_member *)pos)->value;
}

const __shared5::component *__shared5::at(OssIndex pos) const {
    return &((__shared5_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared5::prepend(const component & val) {
    __shared5_member *newrec = new __shared5_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared5::prepend(__shared5 *seq) {
    return do_prepend(seq);
}

OssIndex __shared5::insert_after(OssIndex pos, const component & val) {
    __shared5_member *newrec = new __shared5_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared5::insert_after(OssIndex pos, __shared5 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared5::remove_front() {
    __shared5_member *extr = (__shared5_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared5_destroy(extr);
    return 0;
}

int __shared5::remove_after(OssIndex pos) {
    __shared5_member *extr = (__shared5_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared5_destroy(extr);
    return 0;
}

/* Extract methods */

__shared5 *__shared5::extract_after(OssIndex begin, OssIndex end) {
    return (__shared5 *)do_extract_after(begin, end);
}

void *__shared6::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared6::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared6::__shared6() {
    memset(this, 0, sizeof(__shared6));
}

__shared6::__shared6(const __shared6 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	pvno_field = that.pvno_field;
	msg_type_field = that.msg_type_field;
	padata_field = that.padata_field;
	req_body_field = that.req_body_field;
    } OSSCLEAN(__shared6)
}

__shared6::__shared6(pvno pvno_val, msg_type msg_type_val, const padata & padata_val, 
    const req_body & req_body_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	pvno_field = pvno_val;
	msg_type_field = msg_type_val;
	padata_field = padata_val;
	req_body_field = req_body_val;
    } OSSCLEAN(__shared6)
}

__shared6::__shared6(pvno pvno_val, msg_type msg_type_val, const req_body & req_body_val) {
    OSSTRY {
	bit_mask = 0;
	pvno_field = pvno_val;
	msg_type_field = msg_type_val;
	req_body_field = req_body_val;
    } OSSCLEAN(__shared6)
}

__shared6 & __shared6::operator = (const __shared6 & that) {
    if (this == &that)
	return *this;
    this->~__shared6();
    bit_mask = that.bit_mask;
    pvno_field = that.pvno_field;
    msg_type_field = that.msg_type_field;
    padata_field = that.padata_field;
    req_body_field = that.req_body_field;
    return *this;
}

int __shared6::operator == (const __shared6 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (pvno_field != that.pvno_field)
	return 0;
    if (msg_type_field != that.msg_type_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (padata_field != that.padata_field)
	    return 0;
    }
    if (req_body_field != that.req_body_field)
	return 0;
    return 1;
}

int __shared6::operator != (const __shared6 & that) const {
    return !(operator ==(that));
}

__shared6::pvno & __shared6::get_pvno() {
    return pvno_field;
}

__shared6::pvno __shared6::get_pvno() const {
    return pvno_field;
}

void __shared6::set_pvno(pvno pvno_val) {
    pvno_field = pvno_val;
}

__shared6::msg_type & __shared6::get_msg_type() {
    return msg_type_field;
}

__shared6::msg_type __shared6::get_msg_type() const {
    return msg_type_field;
}

void __shared6::set_msg_type(msg_type msg_type_val) {
    msg_type_field = msg_type_val;
}

__shared6::padata *__shared6::get_padata() {
    if (bit_mask & 0x80000000)
	return &padata_field;
    else
	return 0;
}

const __shared6::padata *__shared6::get_padata() const {
    if (bit_mask & 0x80000000)
	return &padata_field;
    else
	return 0;
}

void __shared6::set_padata(const padata & padata_val) {
    bit_mask |= 0x80000000;
    padata_field = padata_val;
}

int __shared6::padata_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared6::omit_padata() {
    padata_field.~__shared5();
    bit_mask &= ~0x80000000;
}

__shared6::req_body & __shared6::get_req_body() {
    return req_body_field;
}

const __shared6::req_body & __shared6::get_req_body() const {
    return req_body_field;
}

void __shared6::set_req_body(const req_body & req_body_val) {
    req_body_field = req_body_val;
}

void *__shared7::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared7::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared7::__shared7() {
    memset(this, 0, sizeof(__shared7));
}

__shared7::__shared7(const __shared7 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	pvno_field = that.pvno_field;
	msg_type_field = that.msg_type_field;
	padata_field = that.padata_field;
	crealm_field = that.crealm_field;
	cname_field = that.cname_field;
	ticket_field = that.ticket_field;
	enc_part_field = that.enc_part_field;
    } OSSCLEAN(__shared7)
}

__shared7::__shared7(pvno pvno_val, msg_type msg_type_val, const padata & padata_val, 
    const crealm & crealm_val, const cname & cname_val, const ticket & ticket_val, const enc_part & enc_part_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	pvno_field = pvno_val;
	msg_type_field = msg_type_val;
	padata_field = padata_val;
	crealm_field = crealm_val;
	cname_field = cname_val;
	ticket_field = ticket_val;
	enc_part_field = enc_part_val;
    } OSSCLEAN(__shared7)
}

__shared7::__shared7(pvno pvno_val, msg_type msg_type_val, const crealm & crealm_val, 
    const cname & cname_val, const ticket & ticket_val, const enc_part & enc_part_val) {
    OSSTRY {
	bit_mask = 0;
	pvno_field = pvno_val;
	msg_type_field = msg_type_val;
	crealm_field = crealm_val;
	cname_field = cname_val;
	ticket_field = ticket_val;
	enc_part_field = enc_part_val;
    } OSSCLEAN(__shared7)
}

__shared7 & __shared7::operator = (const __shared7 & that) {
    if (this == &that)
	return *this;
    this->~__shared7();
    bit_mask = that.bit_mask;
    pvno_field = that.pvno_field;
    msg_type_field = that.msg_type_field;
    padata_field = that.padata_field;
    crealm_field = that.crealm_field;
    cname_field = that.cname_field;
    ticket_field = that.ticket_field;
    enc_part_field = that.enc_part_field;
    return *this;
}

int __shared7::operator == (const __shared7 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (pvno_field != that.pvno_field)
	return 0;
    if (msg_type_field != that.msg_type_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (padata_field != that.padata_field)
	    return 0;
    }
    if (crealm_field != that.crealm_field)
	return 0;
    if (cname_field != that.cname_field)
	return 0;
    if (ticket_field != that.ticket_field)
	return 0;
    if (enc_part_field != that.enc_part_field)
	return 0;
    return 1;
}

int __shared7::operator != (const __shared7 & that) const {
    return !(operator ==(that));
}

__shared7::pvno & __shared7::get_pvno() {
    return pvno_field;
}

__shared7::pvno __shared7::get_pvno() const {
    return pvno_field;
}

void __shared7::set_pvno(pvno pvno_val) {
    pvno_field = pvno_val;
}

__shared7::msg_type & __shared7::get_msg_type() {
    return msg_type_field;
}

__shared7::msg_type __shared7::get_msg_type() const {
    return msg_type_field;
}

void __shared7::set_msg_type(msg_type msg_type_val) {
    msg_type_field = msg_type_val;
}

__shared7::padata *__shared7::get_padata() {
    if (bit_mask & 0x80000000)
	return &padata_field;
    else
	return 0;
}

const __shared7::padata *__shared7::get_padata() const {
    if (bit_mask & 0x80000000)
	return &padata_field;
    else
	return 0;
}

void __shared7::set_padata(const padata & padata_val) {
    bit_mask |= 0x80000000;
    padata_field = padata_val;
}

int __shared7::padata_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared7::omit_padata() {
    padata_field.~__shared5();
    bit_mask &= ~0x80000000;
}

__shared7::crealm & __shared7::get_crealm() {
    return crealm_field;
}

const __shared7::crealm & __shared7::get_crealm() const {
    return crealm_field;
}

void __shared7::set_crealm(const crealm & crealm_val) {
    crealm_field = crealm_val;
}

__shared7::cname & __shared7::get_cname() {
    return cname_field;
}

const __shared7::cname & __shared7::get_cname() const {
    return cname_field;
}

void __shared7::set_cname(const cname & cname_val) {
    cname_field = cname_val;
}

__shared7::ticket & __shared7::get_ticket() {
    return ticket_field;
}

const __shared7::ticket & __shared7::get_ticket() const {
    return ticket_field;
}

void __shared7::set_ticket(const ticket & ticket_val) {
    ticket_field = ticket_val;
}

__shared7::enc_part & __shared7::get_enc_part() {
    return enc_part_field;
}

const __shared7::enc_part & __shared7::get_enc_part() const {
    return enc_part_field;
}

void __shared7::set_enc_part(const enc_part & enc_part_val) {
    enc_part_field = enc_part_val;
}

/* Auxiliary data structures and functions for class LastReq */

class LastReq_member {
public:
    LastReq_member *next;
    LastReq::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    LastReq_member();
    LastReq_member(const LastReq::component & val);
};

void *LastReq_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void LastReq_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

LastReq_member::LastReq_member() {
}

LastReq_member::LastReq_member(const LastReq::component & val) {
    value = val;
}

static void *LastReq_copy(void *that) {
    return new LastReq_member(((LastReq_member *)that)->value);
}

static void LastReq_destroy(void *that) {
    delete (LastReq_member *)that;
}

static int LastReq_compare(void *val1, void *val2) {
    return (((LastReq_member *)val1)->value == ((LastReq_member *)val2)->value);
}

/* Constructors */

LastReq::LastReq() {
}

LastReq::LastReq(const LastReq & that) {
    OSSTRY {
	do_copy(that, &LastReq_copy);
    } OSSCLEAN(LastReq)
}

/* Destructor */

LastReq::~LastReq() {
    do_destroy(&LastReq_destroy);
}

/* Operators: assignment, equality, inequality */

LastReq & LastReq::operator = (const LastReq & that) {
    do_destroy(&LastReq_destroy);
    do_copy(that, &LastReq_copy);
    return *this;
}

int LastReq::operator == (const LastReq & that) const {
    return do_compare(that, &LastReq_compare);
}

int LastReq::operator != (const LastReq & that) const {
    return !do_compare(that, &LastReq_compare);
}

/* Locate ("At" etc) methods */

LastReq::component *LastReq::at(OssIndex pos) {
    return &((LastReq_member *)pos)->value;
}

const LastReq::component *LastReq::at(OssIndex pos) const {
    return &((LastReq_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex LastReq::prepend(const component & val) {
    LastReq_member *newrec = new LastReq_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex LastReq::prepend(LastReq *seq) {
    return do_prepend(seq);
}

OssIndex LastReq::insert_after(OssIndex pos, const component & val) {
    LastReq_member *newrec = new LastReq_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex LastReq::insert_after(OssIndex pos, LastReq *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int LastReq::remove_front() {
    LastReq_member *extr = (LastReq_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    LastReq_destroy(extr);
    return 0;
}

int LastReq::remove_after(OssIndex pos) {
    LastReq_member *extr = (LastReq_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    LastReq_destroy(extr);
    return 0;
}

/* Extract methods */

LastReq *LastReq::extract_after(OssIndex begin, OssIndex end) {
    return (LastReq *)do_extract_after(begin, end);
}

void *__shared8::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared8::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared8::__shared8() {
    memset(this, 0, sizeof(__shared8));
}

__shared8::__shared8(const __shared8 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	key_field = that.key_field;
	last_req_field = that.last_req_field;
	nonce_field = that.nonce_field;
	key_expiration_field = that.key_expiration_field;
	flags_field = that.flags_field;
	authtime_field = that.authtime_field;
	starttime_field = that.starttime_field;
	endtime_field = that.endtime_field;
	renew_till_field = that.renew_till_field;
	srealm_field = that.srealm_field;
	sname_field = that.sname_field;
	caddr_field = that.caddr_field;
	encrypted_pa_data_field = that.encrypted_pa_data_field;
    } OSSCLEAN(__shared8)
}

__shared8::__shared8(const key & key_val, const last_req & last_req_val, nonce nonce_val, 
    const key_expiration & key_expiration_val, const flags & flags_val, const authtime & authtime_val, 
    const starttime & starttime_val, const endtime & endtime_val, const renew_till & renew_till_val, 
    const srealm & srealm_val, const sname & sname_val, const caddr & caddr_val, const encrypted_pa_data & encrypted_pa_data_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	key_field = key_val;
	last_req_field = last_req_val;
	nonce_field = nonce_val;
	key_expiration_field = key_expiration_val;
	flags_field = flags_val;
	authtime_field = authtime_val;
	starttime_field = starttime_val;
	endtime_field = endtime_val;
	renew_till_field = renew_till_val;
	srealm_field = srealm_val;
	sname_field = sname_val;
	caddr_field = caddr_val;
	encrypted_pa_data_field = encrypted_pa_data_val;
    } OSSCLEAN(__shared8)
}

__shared8::__shared8(const key & key_val, const last_req & last_req_val, nonce nonce_val, 
    const flags & flags_val, const authtime & authtime_val, const endtime & endtime_val, 
    const srealm & srealm_val, const sname & sname_val) {
    OSSTRY {
	bit_mask = 0;
	key_field = key_val;
	last_req_field = last_req_val;
	nonce_field = nonce_val;
	flags_field = flags_val;
	authtime_field = authtime_val;
	endtime_field = endtime_val;
	srealm_field = srealm_val;
	sname_field = sname_val;
    } OSSCLEAN(__shared8)
}

__shared8 & __shared8::operator = (const __shared8 & that) {
    if (this == &that)
	return *this;
    this->~__shared8();
    bit_mask = that.bit_mask;
    key_field = that.key_field;
    last_req_field = that.last_req_field;
    nonce_field = that.nonce_field;
    key_expiration_field = that.key_expiration_field;
    flags_field = that.flags_field;
    authtime_field = that.authtime_field;
    starttime_field = that.starttime_field;
    endtime_field = that.endtime_field;
    renew_till_field = that.renew_till_field;
    srealm_field = that.srealm_field;
    sname_field = that.sname_field;
    caddr_field = that.caddr_field;
    encrypted_pa_data_field = that.encrypted_pa_data_field;
    return *this;
}

int __shared8::operator == (const __shared8 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (key_field != that.key_field)
	return 0;
    if (last_req_field != that.last_req_field)
	return 0;
    if (nonce_field != that.nonce_field)
	return 0;
    if (key_expiration_field != that.key_expiration_field)
	return 0;
    if (flags_field != that.flags_field)
	return 0;
    if (authtime_field != that.authtime_field)
	return 0;
    if (starttime_field != that.starttime_field)
	return 0;
    if (endtime_field != that.endtime_field)
	return 0;
    if (renew_till_field != that.renew_till_field)
	return 0;
    if (srealm_field != that.srealm_field)
	return 0;
    if (sname_field != that.sname_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (caddr_field != that.caddr_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (encrypted_pa_data_field != that.encrypted_pa_data_field)
	    return 0;
    }
    return 1;
}

int __shared8::operator != (const __shared8 & that) const {
    return !(operator ==(that));
}

__shared8::key & __shared8::get_key() {
    return key_field;
}

const __shared8::key & __shared8::get_key() const {
    return key_field;
}

void __shared8::set_key(const key & key_val) {
    key_field = key_val;
}

__shared8::last_req & __shared8::get_last_req() {
    return last_req_field;
}

const __shared8::last_req & __shared8::get_last_req() const {
    return last_req_field;
}

void __shared8::set_last_req(const last_req & last_req_val) {
    last_req_field = last_req_val;
}

__shared8::nonce & __shared8::get_nonce() {
    return nonce_field;
}

__shared8::nonce __shared8::get_nonce() const {
    return nonce_field;
}

void __shared8::set_nonce(nonce nonce_val) {
    nonce_field = nonce_val;
}

__shared8::key_expiration *__shared8::get_key_expiration() {
    if (*(char **)&key_expiration_field)
	return &key_expiration_field;
    else
	return 0;
}

const __shared8::key_expiration *__shared8::get_key_expiration() const {
    if (*(char **)&key_expiration_field)
	return &key_expiration_field;
    else
	return 0;
}

void __shared8::set_key_expiration(const key_expiration & key_expiration_val) {
    key_expiration_field = key_expiration_val;
}

int __shared8::key_expiration_is_present() const {
    return !!(*(char **)&key_expiration_field);
}

void __shared8::omit_key_expiration() {
    key_expiration_field.~OssGeneralizedTime();
}

__shared8::flags & __shared8::get_flags() {
    return flags_field;
}

const __shared8::flags & __shared8::get_flags() const {
    return flags_field;
}

void __shared8::set_flags(const flags & flags_val) {
    flags_field = flags_val;
}

__shared8::authtime & __shared8::get_authtime() {
    return authtime_field;
}

const __shared8::authtime & __shared8::get_authtime() const {
    return authtime_field;
}

void __shared8::set_authtime(const authtime & authtime_val) {
    authtime_field = authtime_val;
}

__shared8::starttime *__shared8::get_starttime() {
    if (*(char **)&starttime_field)
	return &starttime_field;
    else
	return 0;
}

const __shared8::starttime *__shared8::get_starttime() const {
    if (*(char **)&starttime_field)
	return &starttime_field;
    else
	return 0;
}

void __shared8::set_starttime(const starttime & starttime_val) {
    starttime_field = starttime_val;
}

int __shared8::starttime_is_present() const {
    return !!(*(char **)&starttime_field);
}

void __shared8::omit_starttime() {
    starttime_field.~OssGeneralizedTime();
}

__shared8::endtime & __shared8::get_endtime() {
    return endtime_field;
}

const __shared8::endtime & __shared8::get_endtime() const {
    return endtime_field;
}

void __shared8::set_endtime(const endtime & endtime_val) {
    endtime_field = endtime_val;
}

__shared8::renew_till *__shared8::get_renew_till() {
    if (*(char **)&renew_till_field)
	return &renew_till_field;
    else
	return 0;
}

const __shared8::renew_till *__shared8::get_renew_till() const {
    if (*(char **)&renew_till_field)
	return &renew_till_field;
    else
	return 0;
}

void __shared8::set_renew_till(const renew_till & renew_till_val) {
    renew_till_field = renew_till_val;
}

int __shared8::renew_till_is_present() const {
    return !!(*(char **)&renew_till_field);
}

void __shared8::omit_renew_till() {
    renew_till_field.~OssGeneralizedTime();
}

__shared8::srealm & __shared8::get_srealm() {
    return srealm_field;
}

const __shared8::srealm & __shared8::get_srealm() const {
    return srealm_field;
}

void __shared8::set_srealm(const srealm & srealm_val) {
    srealm_field = srealm_val;
}

__shared8::sname & __shared8::get_sname() {
    return sname_field;
}

const __shared8::sname & __shared8::get_sname() const {
    return sname_field;
}

void __shared8::set_sname(const sname & sname_val) {
    sname_field = sname_val;
}

__shared8::caddr *__shared8::get_caddr() {
    if (bit_mask & 0x80000000)
	return &caddr_field;
    else
	return 0;
}

const __shared8::caddr *__shared8::get_caddr() const {
    if (bit_mask & 0x80000000)
	return &caddr_field;
    else
	return 0;
}

void __shared8::set_caddr(const caddr & caddr_val) {
    bit_mask |= 0x80000000;
    caddr_field = caddr_val;
}

int __shared8::caddr_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared8::omit_caddr() {
    caddr_field.~HostAddresses();
    bit_mask &= ~0x80000000;
}

__shared8::encrypted_pa_data *__shared8::get_encrypted_pa_data() {
    if (bit_mask & 0x40000000)
	return &encrypted_pa_data_field;
    else
	return 0;
}

const __shared8::encrypted_pa_data *__shared8::get_encrypted_pa_data() const {
    if (bit_mask & 0x40000000)
	return &encrypted_pa_data_field;
    else
	return 0;
}

void __shared8::set_encrypted_pa_data(const encrypted_pa_data & encrypted_pa_data_val) {
    bit_mask |= 0x40000000;
    encrypted_pa_data_field = encrypted_pa_data_val;
}

int __shared8::encrypted_pa_data_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __shared8::omit_encrypted_pa_data() {
    encrypted_pa_data_field.~__shared5();
    bit_mask &= ~0x40000000;
}

void *__seq2::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq2::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq2::__seq2() {
    memset(this, 0, sizeof(__seq2));
}

__seq2::__seq2(const __seq2 & that) {
    OSSTRY {
	lr_type_field = that.lr_type_field;
	lr_value_field = that.lr_value_field;
    } OSSCLEAN(__seq2)
}

__seq2::__seq2(lr_type lr_type_val, const lr_value & lr_value_val) {
    OSSTRY {
	lr_type_field = lr_type_val;
	lr_value_field = lr_value_val;
    } OSSCLEAN(__seq2)
}

__seq2 & __seq2::operator = (const __seq2 & that) {
    if (this == &that)
	return *this;
    lr_type_field = that.lr_type_field;
    lr_value_field = that.lr_value_field;
    return *this;
}

int __seq2::operator == (const __seq2 & that) const {
    if (lr_type_field != that.lr_type_field)
	return 0;
    if (lr_value_field != that.lr_value_field)
	return 0;
    return 1;
}

int __seq2::operator != (const __seq2 & that) const {
    return !(operator ==(that));
}

__seq2::lr_type & __seq2::get_lr_type() {
    return lr_type_field;
}

__seq2::lr_type __seq2::get_lr_type() const {
    return lr_type_field;
}

void __seq2::set_lr_type(lr_type lr_type_val) {
    lr_type_field = lr_type_val;
}

__seq2::lr_value & __seq2::get_lr_value() {
    return lr_value_field;
}

const __seq2::lr_value & __seq2::get_lr_value() const {
    return lr_value_field;
}

void __seq2::set_lr_value(const lr_value & lr_value_val) {
    lr_value_field = lr_value_val;
}

void *AP_REQ::operator new(size_t size) {
    return ossNewFunc(size);
}

void AP_REQ::operator delete(void *ptr) {
    asn1Free(ptr);
}

AP_REQ::AP_REQ() {
    memset(this, 0, sizeof(AP_REQ));
}

AP_REQ::AP_REQ(const AP_REQ & that) {
    OSSTRY {
	pvno_field = that.pvno_field;
	msg_type_field = that.msg_type_field;
	ap_options_field = that.ap_options_field;
	ticket_field = that.ticket_field;
	authenticator_field = that.authenticator_field;
    } OSSCLEAN(AP_REQ)
}

AP_REQ::AP_REQ(pvno pvno_val, msg_type msg_type_val, const ap_options & ap_options_val, 
    const ticket & ticket_val, const authenticator & authenticator_val) {
    OSSTRY {
	pvno_field = pvno_val;
	msg_type_field = msg_type_val;
	ap_options_field = ap_options_val;
	ticket_field = ticket_val;
	authenticator_field = authenticator_val;
    } OSSCLEAN(AP_REQ)
}

AP_REQ & AP_REQ::operator = (const AP_REQ & that) {
    if (this == &that)
	return *this;
    pvno_field = that.pvno_field;
    msg_type_field = that.msg_type_field;
    ap_options_field = that.ap_options_field;
    ticket_field = that.ticket_field;
    authenticator_field = that.authenticator_field;
    return *this;
}

int AP_REQ::operator == (const AP_REQ & that) const {
    if (pvno_field != that.pvno_field)
	return 0;
    if (msg_type_field != that.msg_type_field)
	return 0;
    if (ap_options_field != that.ap_options_field)
	return 0;
    if (ticket_field != that.ticket_field)
	return 0;
    if (authenticator_field != that.authenticator_field)
	return 0;
    return 1;
}

int AP_REQ::operator != (const AP_REQ & that) const {
    return !(operator ==(that));
}

AP_REQ::pvno & AP_REQ::get_pvno() {
    return pvno_field;
}

AP_REQ::pvno AP_REQ::get_pvno() const {
    return pvno_field;
}

void AP_REQ::set_pvno(pvno pvno_val) {
    pvno_field = pvno_val;
}

AP_REQ::msg_type & AP_REQ::get_msg_type() {
    return msg_type_field;
}

AP_REQ::msg_type AP_REQ::get_msg_type() const {
    return msg_type_field;
}

void AP_REQ::set_msg_type(msg_type msg_type_val) {
    msg_type_field = msg_type_val;
}

AP_REQ::ap_options & AP_REQ::get_ap_options() {
    return ap_options_field;
}

const AP_REQ::ap_options & AP_REQ::get_ap_options() const {
    return ap_options_field;
}

void AP_REQ::set_ap_options(const ap_options & ap_options_val) {
    ap_options_field = ap_options_val;
}

AP_REQ::ticket & AP_REQ::get_ticket() {
    return ticket_field;
}

const AP_REQ::ticket & AP_REQ::get_ticket() const {
    return ticket_field;
}

void AP_REQ::set_ticket(const ticket & ticket_val) {
    ticket_field = ticket_val;
}

AP_REQ::authenticator & AP_REQ::get_authenticator() {
    return authenticator_field;
}

const AP_REQ::authenticator & AP_REQ::get_authenticator() const {
    return authenticator_field;
}

void AP_REQ::set_authenticator(const authenticator & authenticator_val) {
    authenticator_field = authenticator_val;
}

void *Authenticator::operator new(size_t size) {
    return ossNewFunc(size);
}

void Authenticator::operator delete(void *ptr) {
    asn1Free(ptr);
}

Authenticator::Authenticator() {
    memset(this, 0, sizeof(Authenticator));
}

Authenticator::Authenticator(const Authenticator & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	authenticator_vno_field = that.authenticator_vno_field;
	crealm_field = that.crealm_field;
	cname_field = that.cname_field;
	cksum_field = that.cksum_field;
	cusec_field = that.cusec_field;
	ctime_field = that.ctime_field;
	subkey_field = that.subkey_field;
	seq_number_field = that.seq_number_field;
	authorization_data_field = that.authorization_data_field;
    } OSSCLEAN(Authenticator)
}

Authenticator::Authenticator(authenticator_vno authenticator_vno_val, const crealm & crealm_val, 
    const cname & cname_val, const cksum & cksum_val, cusec cusec_val, const ctime & ctime_val, 
    const subkey & subkey_val, seq_number seq_number_val, const authorization_data & authorization_data_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	authenticator_vno_field = authenticator_vno_val;
	crealm_field = crealm_val;
	cname_field = cname_val;
	cksum_field = cksum_val;
	cusec_field = cusec_val;
	ctime_field = ctime_val;
	subkey_field = subkey_val;
	seq_number_field = seq_number_val;
	authorization_data_field = authorization_data_val;
    } OSSCLEAN(Authenticator)
}

Authenticator::Authenticator(authenticator_vno authenticator_vno_val, const crealm & crealm_val, 
    const cname & cname_val, cusec cusec_val, const ctime & ctime_val) {
    OSSTRY {
	bit_mask = 0;
	authenticator_vno_field = authenticator_vno_val;
	crealm_field = crealm_val;
	cname_field = cname_val;
	cusec_field = cusec_val;
	ctime_field = ctime_val;
    } OSSCLEAN(Authenticator)
}

Authenticator & Authenticator::operator = (const Authenticator & that) {
    if (this == &that)
	return *this;
    this->~Authenticator();
    bit_mask = that.bit_mask;
    authenticator_vno_field = that.authenticator_vno_field;
    crealm_field = that.crealm_field;
    cname_field = that.cname_field;
    cksum_field = that.cksum_field;
    cusec_field = that.cusec_field;
    ctime_field = that.ctime_field;
    subkey_field = that.subkey_field;
    seq_number_field = that.seq_number_field;
    authorization_data_field = that.authorization_data_field;
    return *this;
}

int Authenticator::operator == (const Authenticator & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (authenticator_vno_field != that.authenticator_vno_field)
	return 0;
    if (crealm_field != that.crealm_field)
	return 0;
    if (cname_field != that.cname_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (cksum_field != that.cksum_field)
	    return 0;
    }
    if (cusec_field != that.cusec_field)
	return 0;
    if (ctime_field != that.ctime_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (subkey_field != that.subkey_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (seq_number_field != that.seq_number_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (authorization_data_field != that.authorization_data_field)
	    return 0;
    }
    return 1;
}

int Authenticator::operator != (const Authenticator & that) const {
    return !(operator ==(that));
}

Authenticator::authenticator_vno & Authenticator::get_authenticator_vno() {
    return authenticator_vno_field;
}

Authenticator::authenticator_vno Authenticator::get_authenticator_vno() const {
    return authenticator_vno_field;
}

void Authenticator::set_authenticator_vno(authenticator_vno authenticator_vno_val) {
    authenticator_vno_field = authenticator_vno_val;
}

Authenticator::crealm & Authenticator::get_crealm() {
    return crealm_field;
}

const Authenticator::crealm & Authenticator::get_crealm() const {
    return crealm_field;
}

void Authenticator::set_crealm(const crealm & crealm_val) {
    crealm_field = crealm_val;
}

Authenticator::cname & Authenticator::get_cname() {
    return cname_field;
}

const Authenticator::cname & Authenticator::get_cname() const {
    return cname_field;
}

void Authenticator::set_cname(const cname & cname_val) {
    cname_field = cname_val;
}

Authenticator::cksum *Authenticator::get_cksum() {
    if (bit_mask & 0x80000000)
	return &cksum_field;
    else
	return 0;
}

const Authenticator::cksum *Authenticator::get_cksum() const {
    if (bit_mask & 0x80000000)
	return &cksum_field;
    else
	return 0;
}

void Authenticator::set_cksum(const cksum & cksum_val) {
    bit_mask |= 0x80000000;
    cksum_field = cksum_val;
}

int Authenticator::cksum_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void Authenticator::omit_cksum() {
    cksum_field.~Checksum();
    bit_mask &= ~0x80000000;
}

Authenticator::cusec & Authenticator::get_cusec() {
    return cusec_field;
}

Authenticator::cusec Authenticator::get_cusec() const {
    return cusec_field;
}

void Authenticator::set_cusec(cusec cusec_val) {
    cusec_field = cusec_val;
}

Authenticator::ctime & Authenticator::get_ctime() {
    return ctime_field;
}

const Authenticator::ctime & Authenticator::get_ctime() const {
    return ctime_field;
}

void Authenticator::set_ctime(const ctime & ctime_val) {
    ctime_field = ctime_val;
}

Authenticator::subkey *Authenticator::get_subkey() {
    if (bit_mask & 0x40000000)
	return &subkey_field;
    else
	return 0;
}

const Authenticator::subkey *Authenticator::get_subkey() const {
    if (bit_mask & 0x40000000)
	return &subkey_field;
    else
	return 0;
}

void Authenticator::set_subkey(const subkey & subkey_val) {
    bit_mask |= 0x40000000;
    subkey_field = subkey_val;
}

int Authenticator::subkey_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void Authenticator::omit_subkey() {
    subkey_field.~EncryptionKey();
    bit_mask &= ~0x40000000;
}

Authenticator::seq_number *Authenticator::get_seq_number() {
    if (bit_mask & 0x20000000)
	return &seq_number_field;
    else
	return 0;
}

const Authenticator::seq_number *Authenticator::get_seq_number() const {
    if (bit_mask & 0x20000000)
	return &seq_number_field;
    else
	return 0;
}

void Authenticator::set_seq_number(seq_number seq_number_val) {
    bit_mask |= 0x20000000;
    seq_number_field = seq_number_val;
}

int Authenticator::seq_number_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void Authenticator::omit_seq_number() {
    bit_mask &= ~0x20000000;
}

Authenticator::authorization_data *Authenticator::get_authorization_data() {
    if (bit_mask & 0x10000000)
	return &authorization_data_field;
    else
	return 0;
}

const Authenticator::authorization_data *Authenticator::get_authorization_data() const {
    if (bit_mask & 0x10000000)
	return &authorization_data_field;
    else
	return 0;
}

void Authenticator::set_authorization_data(const authorization_data & authorization_data_val) {
    bit_mask |= 0x10000000;
    authorization_data_field = authorization_data_val;
}

int Authenticator::authorization_data_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void Authenticator::omit_authorization_data() {
    authorization_data_field.~__shared2();
    bit_mask &= ~0x10000000;
}

void *__shared9::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared9::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared9::__shared9() {
    memset(this, 0, sizeof(__shared9));
}

__shared9::__shared9(const __shared9 & that) {
    OSSTRY {
	pvno_field = that.pvno_field;
	msg_type_field = that.msg_type_field;
	enc_part_field = that.enc_part_field;
    } OSSCLEAN(__shared9)
}

__shared9::__shared9(pvno pvno_val, msg_type msg_type_val, const enc_part & enc_part_val) {
    OSSTRY {
	pvno_field = pvno_val;
	msg_type_field = msg_type_val;
	enc_part_field = enc_part_val;
    } OSSCLEAN(__shared9)
}

__shared9 & __shared9::operator = (const __shared9 & that) {
    if (this == &that)
	return *this;
    pvno_field = that.pvno_field;
    msg_type_field = that.msg_type_field;
    enc_part_field = that.enc_part_field;
    return *this;
}

int __shared9::operator == (const __shared9 & that) const {
    if (pvno_field != that.pvno_field)
	return 0;
    if (msg_type_field != that.msg_type_field)
	return 0;
    if (enc_part_field != that.enc_part_field)
	return 0;
    return 1;
}

int __shared9::operator != (const __shared9 & that) const {
    return !(operator ==(that));
}

__shared9::pvno & __shared9::get_pvno() {
    return pvno_field;
}

__shared9::pvno __shared9::get_pvno() const {
    return pvno_field;
}

void __shared9::set_pvno(pvno pvno_val) {
    pvno_field = pvno_val;
}

__shared9::msg_type & __shared9::get_msg_type() {
    return msg_type_field;
}

__shared9::msg_type __shared9::get_msg_type() const {
    return msg_type_field;
}

void __shared9::set_msg_type(msg_type msg_type_val) {
    msg_type_field = msg_type_val;
}

__shared9::enc_part & __shared9::get_enc_part() {
    return enc_part_field;
}

const __shared9::enc_part & __shared9::get_enc_part() const {
    return enc_part_field;
}

void __shared9::set_enc_part(const enc_part & enc_part_val) {
    enc_part_field = enc_part_val;
}

void *EncAPRepPart::operator new(size_t size) {
    return ossNewFunc(size);
}

void EncAPRepPart::operator delete(void *ptr) {
    asn1Free(ptr);
}

EncAPRepPart::EncAPRepPart() {
    memset(this, 0, sizeof(EncAPRepPart));
}

EncAPRepPart::EncAPRepPart(const EncAPRepPart & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	ctime_field = that.ctime_field;
	cusec_field = that.cusec_field;
	subkey_field = that.subkey_field;
	seq_number_field = that.seq_number_field;
    } OSSCLEAN(EncAPRepPart)
}

EncAPRepPart::EncAPRepPart(const ctime & ctime_val, cusec cusec_val, const subkey & subkey_val, 
    seq_number seq_number_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	ctime_field = ctime_val;
	cusec_field = cusec_val;
	subkey_field = subkey_val;
	seq_number_field = seq_number_val;
    } OSSCLEAN(EncAPRepPart)
}

EncAPRepPart::EncAPRepPart(const ctime & ctime_val, cusec cusec_val) {
    OSSTRY {
	bit_mask = 0;
	ctime_field = ctime_val;
	cusec_field = cusec_val;
    } OSSCLEAN(EncAPRepPart)
}

EncAPRepPart & EncAPRepPart::operator = (const EncAPRepPart & that) {
    if (this == &that)
	return *this;
    this->~EncAPRepPart();
    bit_mask = that.bit_mask;
    ctime_field = that.ctime_field;
    cusec_field = that.cusec_field;
    subkey_field = that.subkey_field;
    seq_number_field = that.seq_number_field;
    return *this;
}

int EncAPRepPart::operator == (const EncAPRepPart & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (ctime_field != that.ctime_field)
	return 0;
    if (cusec_field != that.cusec_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (subkey_field != that.subkey_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (seq_number_field != that.seq_number_field)
	    return 0;
    }
    return 1;
}

int EncAPRepPart::operator != (const EncAPRepPart & that) const {
    return !(operator ==(that));
}

EncAPRepPart::ctime & EncAPRepPart::get_ctime() {
    return ctime_field;
}

const EncAPRepPart::ctime & EncAPRepPart::get_ctime() const {
    return ctime_field;
}

void EncAPRepPart::set_ctime(const ctime & ctime_val) {
    ctime_field = ctime_val;
}

EncAPRepPart::cusec & EncAPRepPart::get_cusec() {
    return cusec_field;
}

EncAPRepPart::cusec EncAPRepPart::get_cusec() const {
    return cusec_field;
}

void EncAPRepPart::set_cusec(cusec cusec_val) {
    cusec_field = cusec_val;
}

EncAPRepPart::subkey *EncAPRepPart::get_subkey() {
    if (bit_mask & 0x80000000)
	return &subkey_field;
    else
	return 0;
}

const EncAPRepPart::subkey *EncAPRepPart::get_subkey() const {
    if (bit_mask & 0x80000000)
	return &subkey_field;
    else
	return 0;
}

void EncAPRepPart::set_subkey(const subkey & subkey_val) {
    bit_mask |= 0x80000000;
    subkey_field = subkey_val;
}

int EncAPRepPart::subkey_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void EncAPRepPart::omit_subkey() {
    subkey_field.~EncryptionKey();
    bit_mask &= ~0x80000000;
}

EncAPRepPart::seq_number *EncAPRepPart::get_seq_number() {
    if (bit_mask & 0x40000000)
	return &seq_number_field;
    else
	return 0;
}

const EncAPRepPart::seq_number *EncAPRepPart::get_seq_number() const {
    if (bit_mask & 0x40000000)
	return &seq_number_field;
    else
	return 0;
}

void EncAPRepPart::set_seq_number(seq_number seq_number_val) {
    bit_mask |= 0x40000000;
    seq_number_field = seq_number_val;
}

int EncAPRepPart::seq_number_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void EncAPRepPart::omit_seq_number() {
    bit_mask &= ~0x40000000;
}

void *__shared10::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared10::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared10::__shared10() {
    memset(this, 0, sizeof(__shared10));
}

__shared10::__shared10(const __shared10 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	user_data_field = that.user_data_field;
	timestamp_field = that.timestamp_field;
	usec_field = that.usec_field;
	seq_number_field = that.seq_number_field;
	s_address_field = that.s_address_field;
	r_address_field = that.r_address_field;
    } OSSCLEAN(__shared10)
}

__shared10::__shared10(const user_data & user_data_val, const timestamp & timestamp_val, 
    usec usec_val, seq_number seq_number_val, const s_address & s_address_val, const r_address & r_address_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	user_data_field = user_data_val;
	timestamp_field = timestamp_val;
	usec_field = usec_val;
	seq_number_field = seq_number_val;
	s_address_field = s_address_val;
	r_address_field = r_address_val;
    } OSSCLEAN(__shared10)
}

__shared10::__shared10(const user_data & user_data_val, const s_address & s_address_val) {
    OSSTRY {
	bit_mask = 0;
	user_data_field = user_data_val;
	s_address_field = s_address_val;
    } OSSCLEAN(__shared10)
}

__shared10 & __shared10::operator = (const __shared10 & that) {
    if (this == &that)
	return *this;
    this->~__shared10();
    bit_mask = that.bit_mask;
    user_data_field = that.user_data_field;
    timestamp_field = that.timestamp_field;
    usec_field = that.usec_field;
    seq_number_field = that.seq_number_field;
    s_address_field = that.s_address_field;
    r_address_field = that.r_address_field;
    return *this;
}

int __shared10::operator == (const __shared10 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (user_data_field != that.user_data_field)
	return 0;
    if (timestamp_field != that.timestamp_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (usec_field != that.usec_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (seq_number_field != that.seq_number_field)
	    return 0;
    }
    if (s_address_field != that.s_address_field)
	return 0;
    if (bit_mask & 0x20000000) {
	if (r_address_field != that.r_address_field)
	    return 0;
    }
    return 1;
}

int __shared10::operator != (const __shared10 & that) const {
    return !(operator ==(that));
}

__shared10::user_data & __shared10::get_user_data() {
    return user_data_field;
}

const __shared10::user_data & __shared10::get_user_data() const {
    return user_data_field;
}

void __shared10::set_user_data(const user_data & user_data_val) {
    user_data_field = user_data_val;
}

__shared10::timestamp *__shared10::get_timestamp() {
    if (*(char **)&timestamp_field)
	return &timestamp_field;
    else
	return 0;
}

const __shared10::timestamp *__shared10::get_timestamp() const {
    if (*(char **)&timestamp_field)
	return &timestamp_field;
    else
	return 0;
}

void __shared10::set_timestamp(const timestamp & timestamp_val) {
    timestamp_field = timestamp_val;
}

int __shared10::timestamp_is_present() const {
    return !!(*(char **)&timestamp_field);
}

void __shared10::omit_timestamp() {
    timestamp_field.~OssGeneralizedTime();
}

__shared10::usec *__shared10::get_usec() {
    if (bit_mask & 0x80000000)
	return &usec_field;
    else
	return 0;
}

const __shared10::usec *__shared10::get_usec() const {
    if (bit_mask & 0x80000000)
	return &usec_field;
    else
	return 0;
}

void __shared10::set_usec(usec usec_val) {
    bit_mask |= 0x80000000;
    usec_field = usec_val;
}

int __shared10::usec_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared10::omit_usec() {
    bit_mask &= ~0x80000000;
}

__shared10::seq_number *__shared10::get_seq_number() {
    if (bit_mask & 0x40000000)
	return &seq_number_field;
    else
	return 0;
}

const __shared10::seq_number *__shared10::get_seq_number() const {
    if (bit_mask & 0x40000000)
	return &seq_number_field;
    else
	return 0;
}

void __shared10::set_seq_number(seq_number seq_number_val) {
    bit_mask |= 0x40000000;
    seq_number_field = seq_number_val;
}

int __shared10::seq_number_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __shared10::omit_seq_number() {
    bit_mask &= ~0x40000000;
}

__shared10::s_address & __shared10::get_s_address() {
    return s_address_field;
}

const __shared10::s_address & __shared10::get_s_address() const {
    return s_address_field;
}

void __shared10::set_s_address(const s_address & s_address_val) {
    s_address_field = s_address_val;
}

__shared10::r_address *__shared10::get_r_address() {
    if (bit_mask & 0x20000000)
	return &r_address_field;
    else
	return 0;
}

const __shared10::r_address *__shared10::get_r_address() const {
    if (bit_mask & 0x20000000)
	return &r_address_field;
    else
	return 0;
}

void __shared10::set_r_address(const r_address & r_address_val) {
    bit_mask |= 0x20000000;
    r_address_field = r_address_val;
}

int __shared10::r_address_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void __shared10::omit_r_address() {
    r_address_field.~HostAddress();
    bit_mask &= ~0x20000000;
}

void *KRB_SAFE::operator new(size_t size) {
    return ossNewFunc(size);
}

void KRB_SAFE::operator delete(void *ptr) {
    asn1Free(ptr);
}

KRB_SAFE::KRB_SAFE() {
    memset(this, 0, sizeof(KRB_SAFE));
}

KRB_SAFE::KRB_SAFE(const KRB_SAFE & that) {
    OSSTRY {
	pvno_field = that.pvno_field;
	msg_type_field = that.msg_type_field;
	safe_body_field = that.safe_body_field;
	cksum_field = that.cksum_field;
    } OSSCLEAN(KRB_SAFE)
}

KRB_SAFE::KRB_SAFE(pvno pvno_val, msg_type msg_type_val, const safe_body & safe_body_val, 
    const cksum & cksum_val) {
    OSSTRY {
	pvno_field = pvno_val;
	msg_type_field = msg_type_val;
	safe_body_field = safe_body_val;
	cksum_field = cksum_val;
    } OSSCLEAN(KRB_SAFE)
}

KRB_SAFE & KRB_SAFE::operator = (const KRB_SAFE & that) {
    if (this == &that)
	return *this;
    pvno_field = that.pvno_field;
    msg_type_field = that.msg_type_field;
    safe_body_field = that.safe_body_field;
    cksum_field = that.cksum_field;
    return *this;
}

int KRB_SAFE::operator == (const KRB_SAFE & that) const {
    if (pvno_field != that.pvno_field)
	return 0;
    if (msg_type_field != that.msg_type_field)
	return 0;
    if (safe_body_field != that.safe_body_field)
	return 0;
    if (cksum_field != that.cksum_field)
	return 0;
    return 1;
}

int KRB_SAFE::operator != (const KRB_SAFE & that) const {
    return !(operator ==(that));
}

KRB_SAFE::pvno & KRB_SAFE::get_pvno() {
    return pvno_field;
}

KRB_SAFE::pvno KRB_SAFE::get_pvno() const {
    return pvno_field;
}

void KRB_SAFE::set_pvno(pvno pvno_val) {
    pvno_field = pvno_val;
}

KRB_SAFE::msg_type & KRB_SAFE::get_msg_type() {
    return msg_type_field;
}

KRB_SAFE::msg_type KRB_SAFE::get_msg_type() const {
    return msg_type_field;
}

void KRB_SAFE::set_msg_type(msg_type msg_type_val) {
    msg_type_field = msg_type_val;
}

KRB_SAFE::safe_body & KRB_SAFE::get_safe_body() {
    return safe_body_field;
}

const KRB_SAFE::safe_body & KRB_SAFE::get_safe_body() const {
    return safe_body_field;
}

void KRB_SAFE::set_safe_body(const safe_body & safe_body_val) {
    safe_body_field = safe_body_val;
}

KRB_SAFE::cksum & KRB_SAFE::get_cksum() {
    return cksum_field;
}

const KRB_SAFE::cksum & KRB_SAFE::get_cksum() const {
    return cksum_field;
}

void KRB_SAFE::set_cksum(const cksum & cksum_val) {
    cksum_field = cksum_val;
}

void *KRB_CRED::operator new(size_t size) {
    return ossNewFunc(size);
}

void KRB_CRED::operator delete(void *ptr) {
    asn1Free(ptr);
}

KRB_CRED::KRB_CRED() {
    memset(this, 0, sizeof(KRB_CRED));
}

KRB_CRED::KRB_CRED(const KRB_CRED & that) {
    OSSTRY {
	pvno_field = that.pvno_field;
	msg_type_field = that.msg_type_field;
	tickets_field = that.tickets_field;
	enc_part_field = that.enc_part_field;
    } OSSCLEAN(KRB_CRED)
}

KRB_CRED::KRB_CRED(pvno pvno_val, msg_type msg_type_val, const tickets & tickets_val, 
    const enc_part & enc_part_val) {
    OSSTRY {
	pvno_field = pvno_val;
	msg_type_field = msg_type_val;
	tickets_field = tickets_val;
	enc_part_field = enc_part_val;
    } OSSCLEAN(KRB_CRED)
}

KRB_CRED & KRB_CRED::operator = (const KRB_CRED & that) {
    if (this == &that)
	return *this;
    pvno_field = that.pvno_field;
    msg_type_field = that.msg_type_field;
    tickets_field = that.tickets_field;
    enc_part_field = that.enc_part_field;
    return *this;
}

int KRB_CRED::operator == (const KRB_CRED & that) const {
    if (pvno_field != that.pvno_field)
	return 0;
    if (msg_type_field != that.msg_type_field)
	return 0;
    if (tickets_field != that.tickets_field)
	return 0;
    if (enc_part_field != that.enc_part_field)
	return 0;
    return 1;
}

int KRB_CRED::operator != (const KRB_CRED & that) const {
    return !(operator ==(that));
}

KRB_CRED::pvno & KRB_CRED::get_pvno() {
    return pvno_field;
}

KRB_CRED::pvno KRB_CRED::get_pvno() const {
    return pvno_field;
}

void KRB_CRED::set_pvno(pvno pvno_val) {
    pvno_field = pvno_val;
}

KRB_CRED::msg_type & KRB_CRED::get_msg_type() {
    return msg_type_field;
}

KRB_CRED::msg_type KRB_CRED::get_msg_type() const {
    return msg_type_field;
}

void KRB_CRED::set_msg_type(msg_type msg_type_val) {
    msg_type_field = msg_type_val;
}

KRB_CRED::tickets & KRB_CRED::get_tickets() {
    return tickets_field;
}

const KRB_CRED::tickets & KRB_CRED::get_tickets() const {
    return tickets_field;
}

void KRB_CRED::set_tickets(const tickets & tickets_val) {
    tickets_field = tickets_val;
}

KRB_CRED::enc_part & KRB_CRED::get_enc_part() {
    return enc_part_field;
}

const KRB_CRED::enc_part & KRB_CRED::get_enc_part() const {
    return enc_part_field;
}

void KRB_CRED::set_enc_part(const enc_part & enc_part_val) {
    enc_part_field = enc_part_val;
}

void *KrbCredInfo::operator new(size_t size) {
    return ossNewFunc(size);
}

void KrbCredInfo::operator delete(void *ptr) {
    asn1Free(ptr);
}

KrbCredInfo::KrbCredInfo() {
    memset(this, 0, sizeof(KrbCredInfo));
}

KrbCredInfo::KrbCredInfo(const KrbCredInfo & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	key_field = that.key_field;
	prealm_field = that.prealm_field;
	pname_field = that.pname_field;
	flags_field = that.flags_field;
	authtime_field = that.authtime_field;
	starttime_field = that.starttime_field;
	endtime_field = that.endtime_field;
	renew_till_field = that.renew_till_field;
	srealm_field = that.srealm_field;
	sname_field = that.sname_field;
	caddr_field = that.caddr_field;
    } OSSCLEAN(KrbCredInfo)
}

KrbCredInfo::KrbCredInfo(const key & key_val, const prealm & prealm_val, const pname & pname_val, 
    const flags & flags_val, const authtime & authtime_val, const starttime & starttime_val, 
    const endtime & endtime_val, const renew_till & renew_till_val, const srealm & srealm_val, 
    const sname & sname_val, const caddr & caddr_val) {
    OSSTRY {
	bit_mask = 0xfc000000;
	key_field = key_val;
	prealm_field = prealm_val;
	pname_field = pname_val;
	flags_field = flags_val;
	authtime_field = authtime_val;
	starttime_field = starttime_val;
	endtime_field = endtime_val;
	renew_till_field = renew_till_val;
	srealm_field = srealm_val;
	sname_field = sname_val;
	caddr_field = caddr_val;
    } OSSCLEAN(KrbCredInfo)
}

KrbCredInfo::KrbCredInfo(const key & key_val) {
    OSSTRY {
	bit_mask = 0;
	key_field = key_val;
    } OSSCLEAN(KrbCredInfo)
}

KrbCredInfo & KrbCredInfo::operator = (const KrbCredInfo & that) {
    if (this == &that)
	return *this;
    this->~KrbCredInfo();
    bit_mask = that.bit_mask;
    key_field = that.key_field;
    prealm_field = that.prealm_field;
    pname_field = that.pname_field;
    flags_field = that.flags_field;
    authtime_field = that.authtime_field;
    starttime_field = that.starttime_field;
    endtime_field = that.endtime_field;
    renew_till_field = that.renew_till_field;
    srealm_field = that.srealm_field;
    sname_field = that.sname_field;
    caddr_field = that.caddr_field;
    return *this;
}

int KrbCredInfo::operator == (const KrbCredInfo & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (key_field != that.key_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (prealm_field != that.prealm_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (pname_field != that.pname_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (flags_field != that.flags_field)
	    return 0;
    }
    if (authtime_field != that.authtime_field)
	return 0;
    if (starttime_field != that.starttime_field)
	return 0;
    if (endtime_field != that.endtime_field)
	return 0;
    if (renew_till_field != that.renew_till_field)
	return 0;
    if (bit_mask & 0x10000000) {
	if (srealm_field != that.srealm_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (sname_field != that.sname_field)
	    return 0;
    }
    if (bit_mask & 0x4000000) {
	if (caddr_field != that.caddr_field)
	    return 0;
    }
    return 1;
}

int KrbCredInfo::operator != (const KrbCredInfo & that) const {
    return !(operator ==(that));
}

KrbCredInfo::key & KrbCredInfo::get_key() {
    return key_field;
}

const KrbCredInfo::key & KrbCredInfo::get_key() const {
    return key_field;
}

void KrbCredInfo::set_key(const key & key_val) {
    key_field = key_val;
}

KrbCredInfo::prealm *KrbCredInfo::get_prealm() {
    if (bit_mask & 0x80000000)
	return &prealm_field;
    else
	return 0;
}

const KrbCredInfo::prealm *KrbCredInfo::get_prealm() const {
    if (bit_mask & 0x80000000)
	return &prealm_field;
    else
	return 0;
}

void KrbCredInfo::set_prealm(const prealm & prealm_val) {
    bit_mask |= 0x80000000;
    prealm_field = prealm_val;
}

int KrbCredInfo::prealm_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void KrbCredInfo::omit_prealm() {
    prealm_field.~OssString();
    bit_mask &= ~0x80000000;
}

KrbCredInfo::pname *KrbCredInfo::get_pname() {
    if (bit_mask & 0x40000000)
	return &pname_field;
    else
	return 0;
}

const KrbCredInfo::pname *KrbCredInfo::get_pname() const {
    if (bit_mask & 0x40000000)
	return &pname_field;
    else
	return 0;
}

void KrbCredInfo::set_pname(const pname & pname_val) {
    bit_mask |= 0x40000000;
    pname_field = pname_val;
}

int KrbCredInfo::pname_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void KrbCredInfo::omit_pname() {
    pname_field.~PrincipalName();
    bit_mask &= ~0x40000000;
}

KrbCredInfo::flags *KrbCredInfo::get_flags() {
    if (bit_mask & 0x20000000)
	return &flags_field;
    else
	return 0;
}

const KrbCredInfo::flags *KrbCredInfo::get_flags() const {
    if (bit_mask & 0x20000000)
	return &flags_field;
    else
	return 0;
}

void KrbCredInfo::set_flags(const flags & flags_val) {
    bit_mask |= 0x20000000;
    flags_field = flags_val;
}

int KrbCredInfo::flags_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void KrbCredInfo::omit_flags() {
    flags_field.~OssBitString();
    bit_mask &= ~0x20000000;
}

KrbCredInfo::authtime *KrbCredInfo::get_authtime() {
    if (*(char **)&authtime_field)
	return &authtime_field;
    else
	return 0;
}

const KrbCredInfo::authtime *KrbCredInfo::get_authtime() const {
    if (*(char **)&authtime_field)
	return &authtime_field;
    else
	return 0;
}

void KrbCredInfo::set_authtime(const authtime & authtime_val) {
    authtime_field = authtime_val;
}

int KrbCredInfo::authtime_is_present() const {
    return !!(*(char **)&authtime_field);
}

void KrbCredInfo::omit_authtime() {
    authtime_field.~OssGeneralizedTime();
}

KrbCredInfo::starttime *KrbCredInfo::get_starttime() {
    if (*(char **)&starttime_field)
	return &starttime_field;
    else
	return 0;
}

const KrbCredInfo::starttime *KrbCredInfo::get_starttime() const {
    if (*(char **)&starttime_field)
	return &starttime_field;
    else
	return 0;
}

void KrbCredInfo::set_starttime(const starttime & starttime_val) {
    starttime_field = starttime_val;
}

int KrbCredInfo::starttime_is_present() const {
    return !!(*(char **)&starttime_field);
}

void KrbCredInfo::omit_starttime() {
    starttime_field.~OssGeneralizedTime();
}

KrbCredInfo::endtime *KrbCredInfo::get_endtime() {
    if (*(char **)&endtime_field)
	return &endtime_field;
    else
	return 0;
}

const KrbCredInfo::endtime *KrbCredInfo::get_endtime() const {
    if (*(char **)&endtime_field)
	return &endtime_field;
    else
	return 0;
}

void KrbCredInfo::set_endtime(const endtime & endtime_val) {
    endtime_field = endtime_val;
}

int KrbCredInfo::endtime_is_present() const {
    return !!(*(char **)&endtime_field);
}

void KrbCredInfo::omit_endtime() {
    endtime_field.~OssGeneralizedTime();
}

KrbCredInfo::renew_till *KrbCredInfo::get_renew_till() {
    if (*(char **)&renew_till_field)
	return &renew_till_field;
    else
	return 0;
}

const KrbCredInfo::renew_till *KrbCredInfo::get_renew_till() const {
    if (*(char **)&renew_till_field)
	return &renew_till_field;
    else
	return 0;
}

void KrbCredInfo::set_renew_till(const renew_till & renew_till_val) {
    renew_till_field = renew_till_val;
}

int KrbCredInfo::renew_till_is_present() const {
    return !!(*(char **)&renew_till_field);
}

void KrbCredInfo::omit_renew_till() {
    renew_till_field.~OssGeneralizedTime();
}

KrbCredInfo::srealm *KrbCredInfo::get_srealm() {
    if (bit_mask & 0x10000000)
	return &srealm_field;
    else
	return 0;
}

const KrbCredInfo::srealm *KrbCredInfo::get_srealm() const {
    if (bit_mask & 0x10000000)
	return &srealm_field;
    else
	return 0;
}

void KrbCredInfo::set_srealm(const srealm & srealm_val) {
    bit_mask |= 0x10000000;
    srealm_field = srealm_val;
}

int KrbCredInfo::srealm_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void KrbCredInfo::omit_srealm() {
    srealm_field.~OssString();
    bit_mask &= ~0x10000000;
}

KrbCredInfo::sname *KrbCredInfo::get_sname() {
    if (bit_mask & 0x8000000)
	return &sname_field;
    else
	return 0;
}

const KrbCredInfo::sname *KrbCredInfo::get_sname() const {
    if (bit_mask & 0x8000000)
	return &sname_field;
    else
	return 0;
}

void KrbCredInfo::set_sname(const sname & sname_val) {
    bit_mask |= 0x8000000;
    sname_field = sname_val;
}

int KrbCredInfo::sname_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void KrbCredInfo::omit_sname() {
    sname_field.~PrincipalName();
    bit_mask &= ~0x8000000;
}

KrbCredInfo::caddr *KrbCredInfo::get_caddr() {
    if (bit_mask & 0x4000000)
	return &caddr_field;
    else
	return 0;
}

const KrbCredInfo::caddr *KrbCredInfo::get_caddr() const {
    if (bit_mask & 0x4000000)
	return &caddr_field;
    else
	return 0;
}

void KrbCredInfo::set_caddr(const caddr & caddr_val) {
    bit_mask |= 0x4000000;
    caddr_field = caddr_val;
}

int KrbCredInfo::caddr_is_present() const {
    return !!(bit_mask & 0x4000000);
}

void KrbCredInfo::omit_caddr() {
    caddr_field.~HostAddresses();
    bit_mask &= ~0x4000000;
}

/* Auxiliary data structures and functions for class __seqof8 */

class __seqof8_member {
public:
    __seqof8_member *next;
    __seqof8::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof8_member();
    __seqof8_member(const __seqof8::component & val);
};

void *__seqof8_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof8_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof8_member::__seqof8_member() {
}

__seqof8_member::__seqof8_member(const __seqof8::component & val) {
    value = val;
}

static void *__seqof8_copy(void *that) {
    return new __seqof8_member(((__seqof8_member *)that)->value);
}

static void __seqof8_destroy(void *that) {
    delete (__seqof8_member *)that;
}

static int __seqof8_compare(void *val1, void *val2) {
    return (((__seqof8_member *)val1)->value == ((__seqof8_member *)val2)->value);
}

/* Constructors */

__seqof8::__seqof8() {
}

__seqof8::__seqof8(const __seqof8 & that) {
    OSSTRY {
	do_copy(that, &__seqof8_copy);
    } OSSCLEAN(__seqof8)
}

/* Destructor */

__seqof8::~__seqof8() {
    do_destroy(&__seqof8_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof8 & __seqof8::operator = (const __seqof8 & that) {
    do_destroy(&__seqof8_destroy);
    do_copy(that, &__seqof8_copy);
    return *this;
}

int __seqof8::operator == (const __seqof8 & that) const {
    return do_compare(that, &__seqof8_compare);
}

int __seqof8::operator != (const __seqof8 & that) const {
    return !do_compare(that, &__seqof8_compare);
}

/* Locate ("At" etc) methods */

__seqof8::component *__seqof8::at(OssIndex pos) {
    return &((__seqof8_member *)pos)->value;
}

const __seqof8::component *__seqof8::at(OssIndex pos) const {
    return &((__seqof8_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof8::prepend(const component & val) {
    __seqof8_member *newrec = new __seqof8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof8::prepend(__seqof8 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof8::insert_after(OssIndex pos, const component & val) {
    __seqof8_member *newrec = new __seqof8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof8::insert_after(OssIndex pos, __seqof8 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof8::remove_front() {
    __seqof8_member *extr = (__seqof8_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof8_destroy(extr);
    return 0;
}

int __seqof8::remove_after(OssIndex pos) {
    __seqof8_member *extr = (__seqof8_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof8_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof8 *__seqof8::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof8 *)do_extract_after(begin, end);
}

void *EncKrbCredPart::operator new(size_t size) {
    return ossNewFunc(size);
}

void EncKrbCredPart::operator delete(void *ptr) {
    asn1Free(ptr);
}

EncKrbCredPart::EncKrbCredPart() {
    memset(this, 0, sizeof(EncKrbCredPart));
}

EncKrbCredPart::EncKrbCredPart(const EncKrbCredPart & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	ticket_info_field = that.ticket_info_field;
	nonce_field = that.nonce_field;
	timestamp_field = that.timestamp_field;
	usec_field = that.usec_field;
	s_address_field = that.s_address_field;
	r_address_field = that.r_address_field;
    } OSSCLEAN(EncKrbCredPart)
}

EncKrbCredPart::EncKrbCredPart(const ticket_info & ticket_info_val, nonce nonce_val, 
    const timestamp & timestamp_val, usec usec_val, const s_address & s_address_val, 
    const r_address & r_address_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	ticket_info_field = ticket_info_val;
	nonce_field = nonce_val;
	timestamp_field = timestamp_val;
	usec_field = usec_val;
	s_address_field = s_address_val;
	r_address_field = r_address_val;
    } OSSCLEAN(EncKrbCredPart)
}

EncKrbCredPart::EncKrbCredPart(const ticket_info & ticket_info_val) {
    OSSTRY {
	bit_mask = 0;
	ticket_info_field = ticket_info_val;
    } OSSCLEAN(EncKrbCredPart)
}

EncKrbCredPart & EncKrbCredPart::operator = (const EncKrbCredPart & that) {
    if (this == &that)
	return *this;
    this->~EncKrbCredPart();
    bit_mask = that.bit_mask;
    ticket_info_field = that.ticket_info_field;
    nonce_field = that.nonce_field;
    timestamp_field = that.timestamp_field;
    usec_field = that.usec_field;
    s_address_field = that.s_address_field;
    r_address_field = that.r_address_field;
    return *this;
}

int EncKrbCredPart::operator == (const EncKrbCredPart & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (ticket_info_field != that.ticket_info_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (nonce_field != that.nonce_field)
	    return 0;
    }
    if (timestamp_field != that.timestamp_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (usec_field != that.usec_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (s_address_field != that.s_address_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (r_address_field != that.r_address_field)
	    return 0;
    }
    return 1;
}

int EncKrbCredPart::operator != (const EncKrbCredPart & that) const {
    return !(operator ==(that));
}

EncKrbCredPart::ticket_info & EncKrbCredPart::get_ticket_info() {
    return ticket_info_field;
}

const EncKrbCredPart::ticket_info & EncKrbCredPart::get_ticket_info() const {
    return ticket_info_field;
}

void EncKrbCredPart::set_ticket_info(const ticket_info & ticket_info_val) {
    ticket_info_field = ticket_info_val;
}

EncKrbCredPart::nonce *EncKrbCredPart::get_nonce() {
    if (bit_mask & 0x80000000)
	return &nonce_field;
    else
	return 0;
}

const EncKrbCredPart::nonce *EncKrbCredPart::get_nonce() const {
    if (bit_mask & 0x80000000)
	return &nonce_field;
    else
	return 0;
}

void EncKrbCredPart::set_nonce(nonce nonce_val) {
    bit_mask |= 0x80000000;
    nonce_field = nonce_val;
}

int EncKrbCredPart::nonce_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void EncKrbCredPart::omit_nonce() {
    bit_mask &= ~0x80000000;
}

EncKrbCredPart::timestamp *EncKrbCredPart::get_timestamp() {
    if (*(char **)&timestamp_field)
	return &timestamp_field;
    else
	return 0;
}

const EncKrbCredPart::timestamp *EncKrbCredPart::get_timestamp() const {
    if (*(char **)&timestamp_field)
	return &timestamp_field;
    else
	return 0;
}

void EncKrbCredPart::set_timestamp(const timestamp & timestamp_val) {
    timestamp_field = timestamp_val;
}

int EncKrbCredPart::timestamp_is_present() const {
    return !!(*(char **)&timestamp_field);
}

void EncKrbCredPart::omit_timestamp() {
    timestamp_field.~OssGeneralizedTime();
}

EncKrbCredPart::usec *EncKrbCredPart::get_usec() {
    if (bit_mask & 0x40000000)
	return &usec_field;
    else
	return 0;
}

const EncKrbCredPart::usec *EncKrbCredPart::get_usec() const {
    if (bit_mask & 0x40000000)
	return &usec_field;
    else
	return 0;
}

void EncKrbCredPart::set_usec(usec usec_val) {
    bit_mask |= 0x40000000;
    usec_field = usec_val;
}

int EncKrbCredPart::usec_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void EncKrbCredPart::omit_usec() {
    bit_mask &= ~0x40000000;
}

EncKrbCredPart::s_address *EncKrbCredPart::get_s_address() {
    if (bit_mask & 0x20000000)
	return &s_address_field;
    else
	return 0;
}

const EncKrbCredPart::s_address *EncKrbCredPart::get_s_address() const {
    if (bit_mask & 0x20000000)
	return &s_address_field;
    else
	return 0;
}

void EncKrbCredPart::set_s_address(const s_address & s_address_val) {
    bit_mask |= 0x20000000;
    s_address_field = s_address_val;
}

int EncKrbCredPart::s_address_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void EncKrbCredPart::omit_s_address() {
    s_address_field.~HostAddress();
    bit_mask &= ~0x20000000;
}

EncKrbCredPart::r_address *EncKrbCredPart::get_r_address() {
    if (bit_mask & 0x10000000)
	return &r_address_field;
    else
	return 0;
}

const EncKrbCredPart::r_address *EncKrbCredPart::get_r_address() const {
    if (bit_mask & 0x10000000)
	return &r_address_field;
    else
	return 0;
}

void EncKrbCredPart::set_r_address(const r_address & r_address_val) {
    bit_mask |= 0x10000000;
    r_address_field = r_address_val;
}

int EncKrbCredPart::r_address_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void EncKrbCredPart::omit_r_address() {
    r_address_field.~HostAddress();
    bit_mask &= ~0x10000000;
}

void *KRB_ERROR::operator new(size_t size) {
    return ossNewFunc(size);
}

void KRB_ERROR::operator delete(void *ptr) {
    asn1Free(ptr);
}

KRB_ERROR::KRB_ERROR() {
    memset(this, 0, sizeof(KRB_ERROR));
}

KRB_ERROR::KRB_ERROR(const KRB_ERROR & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	pvno_field = that.pvno_field;
	msg_type_field = that.msg_type_field;
	ctime_field = that.ctime_field;
	cusec_field = that.cusec_field;
	stime_field = that.stime_field;
	susec_field = that.susec_field;
	error_code_field = that.error_code_field;
	crealm_field = that.crealm_field;
	cname_field = that.cname_field;
	realm_field = that.realm_field;
	sname_field = that.sname_field;
	e_text_field = that.e_text_field;
	e_data_field = that.e_data_field;
    } OSSCLEAN(KRB_ERROR)
}

KRB_ERROR::KRB_ERROR(pvno pvno_val, msg_type msg_type_val, const ctime & ctime_val, 
    cusec cusec_val, const stime & stime_val, susec susec_val, error_code error_code_val, 
    const crealm & crealm_val, const cname & cname_val, const realm & realm_val, const sname & sname_val, 
    const e_text & e_text_val, const e_data & e_data_val) {
    OSSTRY {
	bit_mask = 0xf8000000;
	pvno_field = pvno_val;
	msg_type_field = msg_type_val;
	ctime_field = ctime_val;
	cusec_field = cusec_val;
	stime_field = stime_val;
	susec_field = susec_val;
	error_code_field = error_code_val;
	crealm_field = crealm_val;
	cname_field = cname_val;
	realm_field = realm_val;
	sname_field = sname_val;
	e_text_field = e_text_val;
	e_data_field = e_data_val;
    } OSSCLEAN(KRB_ERROR)
}

KRB_ERROR::KRB_ERROR(pvno pvno_val, msg_type msg_type_val, const stime & stime_val, 
    susec susec_val, error_code error_code_val, const realm & realm_val, const sname & sname_val) {
    OSSTRY {
	bit_mask = 0;
	pvno_field = pvno_val;
	msg_type_field = msg_type_val;
	stime_field = stime_val;
	susec_field = susec_val;
	error_code_field = error_code_val;
	realm_field = realm_val;
	sname_field = sname_val;
    } OSSCLEAN(KRB_ERROR)
}

KRB_ERROR & KRB_ERROR::operator = (const KRB_ERROR & that) {
    if (this == &that)
	return *this;
    this->~KRB_ERROR();
    bit_mask = that.bit_mask;
    pvno_field = that.pvno_field;
    msg_type_field = that.msg_type_field;
    ctime_field = that.ctime_field;
    cusec_field = that.cusec_field;
    stime_field = that.stime_field;
    susec_field = that.susec_field;
    error_code_field = that.error_code_field;
    crealm_field = that.crealm_field;
    cname_field = that.cname_field;
    realm_field = that.realm_field;
    sname_field = that.sname_field;
    e_text_field = that.e_text_field;
    e_data_field = that.e_data_field;
    return *this;
}

int KRB_ERROR::operator == (const KRB_ERROR & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (pvno_field != that.pvno_field)
	return 0;
    if (msg_type_field != that.msg_type_field)
	return 0;
    if (ctime_field != that.ctime_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (cusec_field != that.cusec_field)
	    return 0;
    }
    if (stime_field != that.stime_field)
	return 0;
    if (susec_field != that.susec_field)
	return 0;
    if (error_code_field != that.error_code_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (crealm_field != that.crealm_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (cname_field != that.cname_field)
	    return 0;
    }
    if (realm_field != that.realm_field)
	return 0;
    if (sname_field != that.sname_field)
	return 0;
    if (bit_mask & 0x10000000) {
	if (e_text_field != that.e_text_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (e_data_field != that.e_data_field)
	    return 0;
    }
    return 1;
}

int KRB_ERROR::operator != (const KRB_ERROR & that) const {
    return !(operator ==(that));
}

KRB_ERROR::pvno & KRB_ERROR::get_pvno() {
    return pvno_field;
}

KRB_ERROR::pvno KRB_ERROR::get_pvno() const {
    return pvno_field;
}

void KRB_ERROR::set_pvno(pvno pvno_val) {
    pvno_field = pvno_val;
}

KRB_ERROR::msg_type & KRB_ERROR::get_msg_type() {
    return msg_type_field;
}

KRB_ERROR::msg_type KRB_ERROR::get_msg_type() const {
    return msg_type_field;
}

void KRB_ERROR::set_msg_type(msg_type msg_type_val) {
    msg_type_field = msg_type_val;
}

KRB_ERROR::ctime *KRB_ERROR::get_ctime() {
    if (*(char **)&ctime_field)
	return &ctime_field;
    else
	return 0;
}

const KRB_ERROR::ctime *KRB_ERROR::get_ctime() const {
    if (*(char **)&ctime_field)
	return &ctime_field;
    else
	return 0;
}

void KRB_ERROR::set_ctime(const ctime & ctime_val) {
    ctime_field = ctime_val;
}

int KRB_ERROR::ctime_is_present() const {
    return !!(*(char **)&ctime_field);
}

void KRB_ERROR::omit_ctime() {
    ctime_field.~OssGeneralizedTime();
}

KRB_ERROR::cusec *KRB_ERROR::get_cusec() {
    if (bit_mask & 0x80000000)
	return &cusec_field;
    else
	return 0;
}

const KRB_ERROR::cusec *KRB_ERROR::get_cusec() const {
    if (bit_mask & 0x80000000)
	return &cusec_field;
    else
	return 0;
}

void KRB_ERROR::set_cusec(cusec cusec_val) {
    bit_mask |= 0x80000000;
    cusec_field = cusec_val;
}

int KRB_ERROR::cusec_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void KRB_ERROR::omit_cusec() {
    bit_mask &= ~0x80000000;
}

KRB_ERROR::stime & KRB_ERROR::get_stime() {
    return stime_field;
}

const KRB_ERROR::stime & KRB_ERROR::get_stime() const {
    return stime_field;
}

void KRB_ERROR::set_stime(const stime & stime_val) {
    stime_field = stime_val;
}

KRB_ERROR::susec & KRB_ERROR::get_susec() {
    return susec_field;
}

KRB_ERROR::susec KRB_ERROR::get_susec() const {
    return susec_field;
}

void KRB_ERROR::set_susec(susec susec_val) {
    susec_field = susec_val;
}

KRB_ERROR::error_code & KRB_ERROR::get_error_code() {
    return error_code_field;
}

KRB_ERROR::error_code KRB_ERROR::get_error_code() const {
    return error_code_field;
}

void KRB_ERROR::set_error_code(error_code error_code_val) {
    error_code_field = error_code_val;
}

KRB_ERROR::crealm *KRB_ERROR::get_crealm() {
    if (bit_mask & 0x40000000)
	return &crealm_field;
    else
	return 0;
}

const KRB_ERROR::crealm *KRB_ERROR::get_crealm() const {
    if (bit_mask & 0x40000000)
	return &crealm_field;
    else
	return 0;
}

void KRB_ERROR::set_crealm(const crealm & crealm_val) {
    bit_mask |= 0x40000000;
    crealm_field = crealm_val;
}

int KRB_ERROR::crealm_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void KRB_ERROR::omit_crealm() {
    crealm_field.~OssString();
    bit_mask &= ~0x40000000;
}

KRB_ERROR::cname *KRB_ERROR::get_cname() {
    if (bit_mask & 0x20000000)
	return &cname_field;
    else
	return 0;
}

const KRB_ERROR::cname *KRB_ERROR::get_cname() const {
    if (bit_mask & 0x20000000)
	return &cname_field;
    else
	return 0;
}

void KRB_ERROR::set_cname(const cname & cname_val) {
    bit_mask |= 0x20000000;
    cname_field = cname_val;
}

int KRB_ERROR::cname_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void KRB_ERROR::omit_cname() {
    cname_field.~PrincipalName();
    bit_mask &= ~0x20000000;
}

KRB_ERROR::realm & KRB_ERROR::get_realm() {
    return realm_field;
}

const KRB_ERROR::realm & KRB_ERROR::get_realm() const {
    return realm_field;
}

void KRB_ERROR::set_realm(const realm & realm_val) {
    realm_field = realm_val;
}

KRB_ERROR::sname & KRB_ERROR::get_sname() {
    return sname_field;
}

const KRB_ERROR::sname & KRB_ERROR::get_sname() const {
    return sname_field;
}

void KRB_ERROR::set_sname(const sname & sname_val) {
    sname_field = sname_val;
}

KRB_ERROR::e_text *KRB_ERROR::get_e_text() {
    if (bit_mask & 0x10000000)
	return &e_text_field;
    else
	return 0;
}

const KRB_ERROR::e_text *KRB_ERROR::get_e_text() const {
    if (bit_mask & 0x10000000)
	return &e_text_field;
    else
	return 0;
}

void KRB_ERROR::set_e_text(const e_text & e_text_val) {
    bit_mask |= 0x10000000;
    e_text_field = e_text_val;
}

int KRB_ERROR::e_text_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void KRB_ERROR::omit_e_text() {
    e_text_field.~OssString();
    bit_mask &= ~0x10000000;
}

KRB_ERROR::e_data *KRB_ERROR::get_e_data() {
    if (bit_mask & 0x8000000)
	return &e_data_field;
    else
	return 0;
}

const KRB_ERROR::e_data *KRB_ERROR::get_e_data() const {
    if (bit_mask & 0x8000000)
	return &e_data_field;
    else
	return 0;
}

void KRB_ERROR::set_e_data(const e_data & e_data_val) {
    bit_mask |= 0x8000000;
    e_data_field = e_data_val;
}

int KRB_ERROR::e_data_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void KRB_ERROR::omit_e_data() {
    e_data_field.~OssString();
    bit_mask &= ~0x8000000;
}

/* Auxiliary data structures and functions for class TYPED_DATA */

class TYPED_DATA_member {
public:
    TYPED_DATA_member *next;
    TYPED_DATA::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    TYPED_DATA_member();
    TYPED_DATA_member(const TYPED_DATA::component & val);
};

void *TYPED_DATA_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void TYPED_DATA_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

TYPED_DATA_member::TYPED_DATA_member() {
}

TYPED_DATA_member::TYPED_DATA_member(const TYPED_DATA::component & val) {
    value = val;
}

static void *TYPED_DATA_copy(void *that) {
    return new TYPED_DATA_member(((TYPED_DATA_member *)that)->value);
}

static void TYPED_DATA_destroy(void *that) {
    delete (TYPED_DATA_member *)that;
}

static int TYPED_DATA_compare(void *val1, void *val2) {
    return (((TYPED_DATA_member *)val1)->value == ((TYPED_DATA_member *)val2)->value);
}

/* Constructors */

TYPED_DATA::TYPED_DATA() {
}

TYPED_DATA::TYPED_DATA(const TYPED_DATA & that) {
    OSSTRY {
	do_copy(that, &TYPED_DATA_copy);
    } OSSCLEAN(TYPED_DATA)
}

/* Destructor */

TYPED_DATA::~TYPED_DATA() {
    do_destroy(&TYPED_DATA_destroy);
}

/* Operators: assignment, equality, inequality */

TYPED_DATA & TYPED_DATA::operator = (const TYPED_DATA & that) {
    do_destroy(&TYPED_DATA_destroy);
    do_copy(that, &TYPED_DATA_copy);
    return *this;
}

int TYPED_DATA::operator == (const TYPED_DATA & that) const {
    return do_compare(that, &TYPED_DATA_compare);
}

int TYPED_DATA::operator != (const TYPED_DATA & that) const {
    return !do_compare(that, &TYPED_DATA_compare);
}

/* Locate ("At" etc) methods */

TYPED_DATA::component *TYPED_DATA::at(OssIndex pos) {
    return &((TYPED_DATA_member *)pos)->value;
}

const TYPED_DATA::component *TYPED_DATA::at(OssIndex pos) const {
    return &((TYPED_DATA_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex TYPED_DATA::prepend(const component & val) {
    TYPED_DATA_member *newrec = new TYPED_DATA_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex TYPED_DATA::prepend(TYPED_DATA *seq) {
    return do_prepend(seq);
}

OssIndex TYPED_DATA::insert_after(OssIndex pos, const component & val) {
    TYPED_DATA_member *newrec = new TYPED_DATA_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex TYPED_DATA::insert_after(OssIndex pos, TYPED_DATA *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int TYPED_DATA::remove_front() {
    TYPED_DATA_member *extr = (TYPED_DATA_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    TYPED_DATA_destroy(extr);
    return 0;
}

int TYPED_DATA::remove_after(OssIndex pos) {
    TYPED_DATA_member *extr = (TYPED_DATA_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    TYPED_DATA_destroy(extr);
    return 0;
}

/* Extract methods */

TYPED_DATA *TYPED_DATA::extract_after(OssIndex begin, OssIndex end) {
    return (TYPED_DATA *)do_extract_after(begin, end);
}

void *__seq3::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq3::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq3::__seq3() {
    memset(this, 0, sizeof(__seq3));
}

__seq3::__seq3(const __seq3 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	data_type_field = that.data_type_field;
	data_value_field = that.data_value_field;
    } OSSCLEAN(__seq3)
}

__seq3::__seq3(data_type data_type_val, const data_value & data_value_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	data_type_field = data_type_val;
	data_value_field = data_value_val;
    } OSSCLEAN(__seq3)
}

__seq3::__seq3(data_type data_type_val) {
    OSSTRY {
	bit_mask = 0;
	data_type_field = data_type_val;
    } OSSCLEAN(__seq3)
}

__seq3 & __seq3::operator = (const __seq3 & that) {
    if (this == &that)
	return *this;
    this->~__seq3();
    bit_mask = that.bit_mask;
    data_type_field = that.data_type_field;
    data_value_field = that.data_value_field;
    return *this;
}

int __seq3::operator == (const __seq3 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (data_type_field != that.data_type_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (data_value_field != that.data_value_field)
	    return 0;
    }
    return 1;
}

int __seq3::operator != (const __seq3 & that) const {
    return !(operator ==(that));
}

__seq3::data_type & __seq3::get_data_type() {
    return data_type_field;
}

__seq3::data_type __seq3::get_data_type() const {
    return data_type_field;
}

void __seq3::set_data_type(data_type data_type_val) {
    data_type_field = data_type_val;
}

__seq3::data_value *__seq3::get_data_value() {
    if (bit_mask & 0x80000000)
	return &data_value_field;
    else
	return 0;
}

const __seq3::data_value *__seq3::get_data_value() const {
    if (bit_mask & 0x80000000)
	return &data_value_field;
    else
	return 0;
}

void __seq3::set_data_value(const data_value & data_value_val) {
    bit_mask |= 0x80000000;
    data_value_field = data_value_val;
}

int __seq3::data_value_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq3::omit_data_value() {
    data_value_field.~OssString();
    bit_mask &= ~0x80000000;
}

void *PA_ENC_TS_ENC::operator new(size_t size) {
    return ossNewFunc(size);
}

void PA_ENC_TS_ENC::operator delete(void *ptr) {
    asn1Free(ptr);
}

PA_ENC_TS_ENC::PA_ENC_TS_ENC() {
    memset(this, 0, sizeof(PA_ENC_TS_ENC));
}

PA_ENC_TS_ENC::PA_ENC_TS_ENC(const PA_ENC_TS_ENC & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	patimestamp_field = that.patimestamp_field;
	pausec_field = that.pausec_field;
    } OSSCLEAN(PA_ENC_TS_ENC)
}

PA_ENC_TS_ENC::PA_ENC_TS_ENC(const patimestamp & patimestamp_val, pausec pausec_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	patimestamp_field = patimestamp_val;
	pausec_field = pausec_val;
    } OSSCLEAN(PA_ENC_TS_ENC)
}

PA_ENC_TS_ENC::PA_ENC_TS_ENC(const patimestamp & patimestamp_val) {
    OSSTRY {
	bit_mask = 0;
	patimestamp_field = patimestamp_val;
    } OSSCLEAN(PA_ENC_TS_ENC)
}

PA_ENC_TS_ENC & PA_ENC_TS_ENC::operator = (const PA_ENC_TS_ENC & that) {
    if (this == &that)
	return *this;
    this->~PA_ENC_TS_ENC();
    bit_mask = that.bit_mask;
    patimestamp_field = that.patimestamp_field;
    pausec_field = that.pausec_field;
    return *this;
}

int PA_ENC_TS_ENC::operator == (const PA_ENC_TS_ENC & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (patimestamp_field != that.patimestamp_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (pausec_field != that.pausec_field)
	    return 0;
    }
    return 1;
}

int PA_ENC_TS_ENC::operator != (const PA_ENC_TS_ENC & that) const {
    return !(operator ==(that));
}

PA_ENC_TS_ENC::patimestamp & PA_ENC_TS_ENC::get_patimestamp() {
    return patimestamp_field;
}

const PA_ENC_TS_ENC::patimestamp & PA_ENC_TS_ENC::get_patimestamp() const {
    return patimestamp_field;
}

void PA_ENC_TS_ENC::set_patimestamp(const patimestamp & patimestamp_val) {
    patimestamp_field = patimestamp_val;
}

PA_ENC_TS_ENC::pausec *PA_ENC_TS_ENC::get_pausec() {
    if (bit_mask & 0x80000000)
	return &pausec_field;
    else
	return 0;
}

const PA_ENC_TS_ENC::pausec *PA_ENC_TS_ENC::get_pausec() const {
    if (bit_mask & 0x80000000)
	return &pausec_field;
    else
	return 0;
}

void PA_ENC_TS_ENC::set_pausec(pausec pausec_val) {
    bit_mask |= 0x80000000;
    pausec_field = pausec_val;
}

int PA_ENC_TS_ENC::pausec_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void PA_ENC_TS_ENC::omit_pausec() {
    bit_mask &= ~0x80000000;
}

void *ETYPE_INFO_ENTRY::operator new(size_t size) {
    return ossNewFunc(size);
}

void ETYPE_INFO_ENTRY::operator delete(void *ptr) {
    asn1Free(ptr);
}

ETYPE_INFO_ENTRY::ETYPE_INFO_ENTRY() {
    memset(this, 0, sizeof(ETYPE_INFO_ENTRY));
}

ETYPE_INFO_ENTRY::ETYPE_INFO_ENTRY(const ETYPE_INFO_ENTRY & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	etype_field = that.etype_field;
	salt_field = that.salt_field;
    } OSSCLEAN(ETYPE_INFO_ENTRY)
}

ETYPE_INFO_ENTRY::ETYPE_INFO_ENTRY(etype etype_val, const salt & salt_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	etype_field = etype_val;
	salt_field = salt_val;
    } OSSCLEAN(ETYPE_INFO_ENTRY)
}

ETYPE_INFO_ENTRY::ETYPE_INFO_ENTRY(etype etype_val) {
    OSSTRY {
	bit_mask = 0;
	etype_field = etype_val;
    } OSSCLEAN(ETYPE_INFO_ENTRY)
}

ETYPE_INFO_ENTRY & ETYPE_INFO_ENTRY::operator = (const ETYPE_INFO_ENTRY & that) {
    if (this == &that)
	return *this;
    this->~ETYPE_INFO_ENTRY();
    bit_mask = that.bit_mask;
    etype_field = that.etype_field;
    salt_field = that.salt_field;
    return *this;
}

int ETYPE_INFO_ENTRY::operator == (const ETYPE_INFO_ENTRY & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (etype_field != that.etype_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (salt_field != that.salt_field)
	    return 0;
    }
    return 1;
}

int ETYPE_INFO_ENTRY::operator != (const ETYPE_INFO_ENTRY & that) const {
    return !(operator ==(that));
}

ETYPE_INFO_ENTRY::etype & ETYPE_INFO_ENTRY::get_etype() {
    return etype_field;
}

ETYPE_INFO_ENTRY::etype ETYPE_INFO_ENTRY::get_etype() const {
    return etype_field;
}

void ETYPE_INFO_ENTRY::set_etype(etype etype_val) {
    etype_field = etype_val;
}

ETYPE_INFO_ENTRY::salt *ETYPE_INFO_ENTRY::get_salt() {
    if (bit_mask & 0x80000000)
	return &salt_field;
    else
	return 0;
}

const ETYPE_INFO_ENTRY::salt *ETYPE_INFO_ENTRY::get_salt() const {
    if (bit_mask & 0x80000000)
	return &salt_field;
    else
	return 0;
}

void ETYPE_INFO_ENTRY::set_salt(const salt & salt_val) {
    bit_mask |= 0x80000000;
    salt_field = salt_val;
}

int ETYPE_INFO_ENTRY::salt_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ETYPE_INFO_ENTRY::omit_salt() {
    salt_field.~OssString();
    bit_mask &= ~0x80000000;
}

/* Auxiliary data structures and functions for class ETYPE_INFO */

class ETYPE_INFO_member {
public:
    ETYPE_INFO_member *next;
    ETYPE_INFO::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    ETYPE_INFO_member();
    ETYPE_INFO_member(const ETYPE_INFO::component & val);
};

void *ETYPE_INFO_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void ETYPE_INFO_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

ETYPE_INFO_member::ETYPE_INFO_member() {
}

ETYPE_INFO_member::ETYPE_INFO_member(const ETYPE_INFO::component & val) {
    value = val;
}

static void *ETYPE_INFO_copy(void *that) {
    return new ETYPE_INFO_member(((ETYPE_INFO_member *)that)->value);
}

static void ETYPE_INFO_destroy(void *that) {
    delete (ETYPE_INFO_member *)that;
}

static int ETYPE_INFO_compare(void *val1, void *val2) {
    return (((ETYPE_INFO_member *)val1)->value == ((ETYPE_INFO_member *)val2)->value);
}

/* Constructors */

ETYPE_INFO::ETYPE_INFO() {
}

ETYPE_INFO::ETYPE_INFO(const ETYPE_INFO & that) {
    OSSTRY {
	do_copy(that, &ETYPE_INFO_copy);
    } OSSCLEAN(ETYPE_INFO)
}

/* Destructor */

ETYPE_INFO::~ETYPE_INFO() {
    do_destroy(&ETYPE_INFO_destroy);
}

/* Operators: assignment, equality, inequality */

ETYPE_INFO & ETYPE_INFO::operator = (const ETYPE_INFO & that) {
    do_destroy(&ETYPE_INFO_destroy);
    do_copy(that, &ETYPE_INFO_copy);
    return *this;
}

int ETYPE_INFO::operator == (const ETYPE_INFO & that) const {
    return do_compare(that, &ETYPE_INFO_compare);
}

int ETYPE_INFO::operator != (const ETYPE_INFO & that) const {
    return !do_compare(that, &ETYPE_INFO_compare);
}

/* Locate ("At" etc) methods */

ETYPE_INFO::component *ETYPE_INFO::at(OssIndex pos) {
    return &((ETYPE_INFO_member *)pos)->value;
}

const ETYPE_INFO::component *ETYPE_INFO::at(OssIndex pos) const {
    return &((ETYPE_INFO_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex ETYPE_INFO::prepend(const component & val) {
    ETYPE_INFO_member *newrec = new ETYPE_INFO_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex ETYPE_INFO::prepend(ETYPE_INFO *seq) {
    return do_prepend(seq);
}

OssIndex ETYPE_INFO::insert_after(OssIndex pos, const component & val) {
    ETYPE_INFO_member *newrec = new ETYPE_INFO_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex ETYPE_INFO::insert_after(OssIndex pos, ETYPE_INFO *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int ETYPE_INFO::remove_front() {
    ETYPE_INFO_member *extr = (ETYPE_INFO_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    ETYPE_INFO_destroy(extr);
    return 0;
}

int ETYPE_INFO::remove_after(OssIndex pos) {
    ETYPE_INFO_member *extr = (ETYPE_INFO_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    ETYPE_INFO_destroy(extr);
    return 0;
}

/* Extract methods */

ETYPE_INFO *ETYPE_INFO::extract_after(OssIndex begin, OssIndex end) {
    return (ETYPE_INFO *)do_extract_after(begin, end);
}

void *ETYPE_INFO2_ENTRY::operator new(size_t size) {
    return ossNewFunc(size);
}

void ETYPE_INFO2_ENTRY::operator delete(void *ptr) {
    asn1Free(ptr);
}

ETYPE_INFO2_ENTRY::ETYPE_INFO2_ENTRY() {
    memset(this, 0, sizeof(ETYPE_INFO2_ENTRY));
}

ETYPE_INFO2_ENTRY::ETYPE_INFO2_ENTRY(const ETYPE_INFO2_ENTRY & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	etype_field = that.etype_field;
	salt_field = that.salt_field;
	s2kparams_field = that.s2kparams_field;
    } OSSCLEAN(ETYPE_INFO2_ENTRY)
}

ETYPE_INFO2_ENTRY::ETYPE_INFO2_ENTRY(etype etype_val, const salt & salt_val, const s2kparams & s2kparams_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	etype_field = etype_val;
	salt_field = salt_val;
	s2kparams_field = s2kparams_val;
    } OSSCLEAN(ETYPE_INFO2_ENTRY)
}

ETYPE_INFO2_ENTRY::ETYPE_INFO2_ENTRY(etype etype_val) {
    OSSTRY {
	bit_mask = 0;
	etype_field = etype_val;
    } OSSCLEAN(ETYPE_INFO2_ENTRY)
}

ETYPE_INFO2_ENTRY & ETYPE_INFO2_ENTRY::operator = (const ETYPE_INFO2_ENTRY & that) {
    if (this == &that)
	return *this;
    this->~ETYPE_INFO2_ENTRY();
    bit_mask = that.bit_mask;
    etype_field = that.etype_field;
    salt_field = that.salt_field;
    s2kparams_field = that.s2kparams_field;
    return *this;
}

int ETYPE_INFO2_ENTRY::operator == (const ETYPE_INFO2_ENTRY & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (etype_field != that.etype_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (salt_field != that.salt_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (s2kparams_field != that.s2kparams_field)
	    return 0;
    }
    return 1;
}

int ETYPE_INFO2_ENTRY::operator != (const ETYPE_INFO2_ENTRY & that) const {
    return !(operator ==(that));
}

ETYPE_INFO2_ENTRY::etype & ETYPE_INFO2_ENTRY::get_etype() {
    return etype_field;
}

ETYPE_INFO2_ENTRY::etype ETYPE_INFO2_ENTRY::get_etype() const {
    return etype_field;
}

void ETYPE_INFO2_ENTRY::set_etype(etype etype_val) {
    etype_field = etype_val;
}

ETYPE_INFO2_ENTRY::salt *ETYPE_INFO2_ENTRY::get_salt() {
    if (bit_mask & 0x80000000)
	return &salt_field;
    else
	return 0;
}

const ETYPE_INFO2_ENTRY::salt *ETYPE_INFO2_ENTRY::get_salt() const {
    if (bit_mask & 0x80000000)
	return &salt_field;
    else
	return 0;
}

void ETYPE_INFO2_ENTRY::set_salt(const salt & salt_val) {
    bit_mask |= 0x80000000;
    salt_field = salt_val;
}

int ETYPE_INFO2_ENTRY::salt_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ETYPE_INFO2_ENTRY::omit_salt() {
    salt_field.~OssString();
    bit_mask &= ~0x80000000;
}

ETYPE_INFO2_ENTRY::s2kparams *ETYPE_INFO2_ENTRY::get_s2kparams() {
    if (bit_mask & 0x40000000)
	return &s2kparams_field;
    else
	return 0;
}

const ETYPE_INFO2_ENTRY::s2kparams *ETYPE_INFO2_ENTRY::get_s2kparams() const {
    if (bit_mask & 0x40000000)
	return &s2kparams_field;
    else
	return 0;
}

void ETYPE_INFO2_ENTRY::set_s2kparams(const s2kparams & s2kparams_val) {
    bit_mask |= 0x40000000;
    s2kparams_field = s2kparams_val;
}

int ETYPE_INFO2_ENTRY::s2kparams_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void ETYPE_INFO2_ENTRY::omit_s2kparams() {
    s2kparams_field.~OssString();
    bit_mask &= ~0x40000000;
}

/* Auxiliary data structures and functions for class ETYPE_INFO2 */

class ETYPE_INFO2_member {
public:
    ETYPE_INFO2_member *next;
    ETYPE_INFO2::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    ETYPE_INFO2_member();
    ETYPE_INFO2_member(const ETYPE_INFO2::component & val);
};

void *ETYPE_INFO2_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void ETYPE_INFO2_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

ETYPE_INFO2_member::ETYPE_INFO2_member() {
}

ETYPE_INFO2_member::ETYPE_INFO2_member(const ETYPE_INFO2::component & val) {
    value = val;
}

static void *ETYPE_INFO2_copy(void *that) {
    return new ETYPE_INFO2_member(((ETYPE_INFO2_member *)that)->value);
}

static void ETYPE_INFO2_destroy(void *that) {
    delete (ETYPE_INFO2_member *)that;
}

static int ETYPE_INFO2_compare(void *val1, void *val2) {
    return (((ETYPE_INFO2_member *)val1)->value == ((ETYPE_INFO2_member *)val2)->value);
}

/* Constructors */

ETYPE_INFO2::ETYPE_INFO2() {
}

ETYPE_INFO2::ETYPE_INFO2(const ETYPE_INFO2 & that) {
    OSSTRY {
	do_copy(that, &ETYPE_INFO2_copy);
    } OSSCLEAN(ETYPE_INFO2)
}

/* Destructor */

ETYPE_INFO2::~ETYPE_INFO2() {
    do_destroy(&ETYPE_INFO2_destroy);
}

/* Operators: assignment, equality, inequality */

ETYPE_INFO2 & ETYPE_INFO2::operator = (const ETYPE_INFO2 & that) {
    do_destroy(&ETYPE_INFO2_destroy);
    do_copy(that, &ETYPE_INFO2_copy);
    return *this;
}

int ETYPE_INFO2::operator == (const ETYPE_INFO2 & that) const {
    return do_compare(that, &ETYPE_INFO2_compare);
}

int ETYPE_INFO2::operator != (const ETYPE_INFO2 & that) const {
    return !do_compare(that, &ETYPE_INFO2_compare);
}

/* Locate ("At" etc) methods */

ETYPE_INFO2::component *ETYPE_INFO2::at(OssIndex pos) {
    return &((ETYPE_INFO2_member *)pos)->value;
}

const ETYPE_INFO2::component *ETYPE_INFO2::at(OssIndex pos) const {
    return &((ETYPE_INFO2_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex ETYPE_INFO2::prepend(const component & val) {
    ETYPE_INFO2_member *newrec = new ETYPE_INFO2_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex ETYPE_INFO2::prepend(ETYPE_INFO2 *seq) {
    return do_prepend(seq);
}

OssIndex ETYPE_INFO2::insert_after(OssIndex pos, const component & val) {
    ETYPE_INFO2_member *newrec = new ETYPE_INFO2_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex ETYPE_INFO2::insert_after(OssIndex pos, ETYPE_INFO2 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int ETYPE_INFO2::remove_front() {
    ETYPE_INFO2_member *extr = (ETYPE_INFO2_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    ETYPE_INFO2_destroy(extr);
    return 0;
}

int ETYPE_INFO2::remove_after(OssIndex pos) {
    ETYPE_INFO2_member *extr = (ETYPE_INFO2_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    ETYPE_INFO2_destroy(extr);
    return 0;
}

/* Extract methods */

ETYPE_INFO2 *ETYPE_INFO2::extract_after(OssIndex begin, OssIndex end) {
    return (ETYPE_INFO2 *)do_extract_after(begin, end);
}

void *AD_KDCIssued::operator new(size_t size) {
    return ossNewFunc(size);
}

void AD_KDCIssued::operator delete(void *ptr) {
    asn1Free(ptr);
}

AD_KDCIssued::AD_KDCIssued() {
    memset(this, 0, sizeof(AD_KDCIssued));
}

AD_KDCIssued::AD_KDCIssued(const AD_KDCIssued & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	ad_checksum_field = that.ad_checksum_field;
	i_realm_field = that.i_realm_field;
	i_sname_field = that.i_sname_field;
	elements_field = that.elements_field;
    } OSSCLEAN(AD_KDCIssued)
}

AD_KDCIssued::AD_KDCIssued(const ad_checksum & ad_checksum_val, const i_realm & i_realm_val, 
    const i_sname & i_sname_val, const elements & elements_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	ad_checksum_field = ad_checksum_val;
	i_realm_field = i_realm_val;
	i_sname_field = i_sname_val;
	elements_field = elements_val;
    } OSSCLEAN(AD_KDCIssued)
}

AD_KDCIssued::AD_KDCIssued(const ad_checksum & ad_checksum_val, const elements & elements_val) {
    OSSTRY {
	bit_mask = 0;
	ad_checksum_field = ad_checksum_val;
	elements_field = elements_val;
    } OSSCLEAN(AD_KDCIssued)
}

AD_KDCIssued & AD_KDCIssued::operator = (const AD_KDCIssued & that) {
    if (this == &that)
	return *this;
    this->~AD_KDCIssued();
    bit_mask = that.bit_mask;
    ad_checksum_field = that.ad_checksum_field;
    i_realm_field = that.i_realm_field;
    i_sname_field = that.i_sname_field;
    elements_field = that.elements_field;
    return *this;
}

int AD_KDCIssued::operator == (const AD_KDCIssued & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (ad_checksum_field != that.ad_checksum_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (i_realm_field != that.i_realm_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (i_sname_field != that.i_sname_field)
	    return 0;
    }
    if (elements_field != that.elements_field)
	return 0;
    return 1;
}

int AD_KDCIssued::operator != (const AD_KDCIssued & that) const {
    return !(operator ==(that));
}

AD_KDCIssued::ad_checksum & AD_KDCIssued::get_ad_checksum() {
    return ad_checksum_field;
}

const AD_KDCIssued::ad_checksum & AD_KDCIssued::get_ad_checksum() const {
    return ad_checksum_field;
}

void AD_KDCIssued::set_ad_checksum(const ad_checksum & ad_checksum_val) {
    ad_checksum_field = ad_checksum_val;
}

AD_KDCIssued::i_realm *AD_KDCIssued::get_i_realm() {
    if (bit_mask & 0x80000000)
	return &i_realm_field;
    else
	return 0;
}

const AD_KDCIssued::i_realm *AD_KDCIssued::get_i_realm() const {
    if (bit_mask & 0x80000000)
	return &i_realm_field;
    else
	return 0;
}

void AD_KDCIssued::set_i_realm(const i_realm & i_realm_val) {
    bit_mask |= 0x80000000;
    i_realm_field = i_realm_val;
}

int AD_KDCIssued::i_realm_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void AD_KDCIssued::omit_i_realm() {
    i_realm_field.~OssString();
    bit_mask &= ~0x80000000;
}

AD_KDCIssued::i_sname *AD_KDCIssued::get_i_sname() {
    if (bit_mask & 0x40000000)
	return &i_sname_field;
    else
	return 0;
}

const AD_KDCIssued::i_sname *AD_KDCIssued::get_i_sname() const {
    if (bit_mask & 0x40000000)
	return &i_sname_field;
    else
	return 0;
}

void AD_KDCIssued::set_i_sname(const i_sname & i_sname_val) {
    bit_mask |= 0x40000000;
    i_sname_field = i_sname_val;
}

int AD_KDCIssued::i_sname_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void AD_KDCIssued::omit_i_sname() {
    i_sname_field.~PrincipalName();
    bit_mask &= ~0x40000000;
}

AD_KDCIssued::elements & AD_KDCIssued::get_elements() {
    return elements_field;
}

const AD_KDCIssued::elements & AD_KDCIssued::get_elements() const {
    return elements_field;
}

void AD_KDCIssued::set_elements(const elements & elements_val) {
    elements_field = elements_val;
}

void *AD_AND_OR::operator new(size_t size) {
    return ossNewFunc(size);
}

void AD_AND_OR::operator delete(void *ptr) {
    asn1Free(ptr);
}

AD_AND_OR::AD_AND_OR() {
    memset(this, 0, sizeof(AD_AND_OR));
}

AD_AND_OR::AD_AND_OR(const AD_AND_OR & that) {
    OSSTRY {
	condition_count_field = that.condition_count_field;
	elements_field = that.elements_field;
    } OSSCLEAN(AD_AND_OR)
}

AD_AND_OR::AD_AND_OR(condition_count condition_count_val, const elements & elements_val) {
    OSSTRY {
	condition_count_field = condition_count_val;
	elements_field = elements_val;
    } OSSCLEAN(AD_AND_OR)
}

AD_AND_OR & AD_AND_OR::operator = (const AD_AND_OR & that) {
    if (this == &that)
	return *this;
    condition_count_field = that.condition_count_field;
    elements_field = that.elements_field;
    return *this;
}

int AD_AND_OR::operator == (const AD_AND_OR & that) const {
    if (condition_count_field != that.condition_count_field)
	return 0;
    if (elements_field != that.elements_field)
	return 0;
    return 1;
}

int AD_AND_OR::operator != (const AD_AND_OR & that) const {
    return !(operator ==(that));
}

AD_AND_OR::condition_count & AD_AND_OR::get_condition_count() {
    return condition_count_field;
}

AD_AND_OR::condition_count AD_AND_OR::get_condition_count() const {
    return condition_count_field;
}

void AD_AND_OR::set_condition_count(condition_count condition_count_val) {
    condition_count_field = condition_count_val;
}

AD_AND_OR::elements & AD_AND_OR::get_elements() {
    return elements_field;
}

const AD_AND_OR::elements & AD_AND_OR::get_elements() const {
    return elements_field;
}

void AD_AND_OR::set_elements(const elements & elements_val) {
    elements_field = elements_val;
}

void *ChangePasswdData::operator new(size_t size) {
    return ossNewFunc(size);
}

void ChangePasswdData::operator delete(void *ptr) {
    asn1Free(ptr);
}

ChangePasswdData::ChangePasswdData() {
    memset(this, 0, sizeof(ChangePasswdData));
}

ChangePasswdData::ChangePasswdData(const ChangePasswdData & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	newpasswd_field = that.newpasswd_field;
	targname_field = that.targname_field;
	targrealm_field = that.targrealm_field;
    } OSSCLEAN(ChangePasswdData)
}

ChangePasswdData::ChangePasswdData(const newpasswd & newpasswd_val, const targname & targname_val, 
    const targrealm & targrealm_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	newpasswd_field = newpasswd_val;
	targname_field = targname_val;
	targrealm_field = targrealm_val;
    } OSSCLEAN(ChangePasswdData)
}

ChangePasswdData::ChangePasswdData(const newpasswd & newpasswd_val) {
    OSSTRY {
	bit_mask = 0;
	newpasswd_field = newpasswd_val;
    } OSSCLEAN(ChangePasswdData)
}

ChangePasswdData & ChangePasswdData::operator = (const ChangePasswdData & that) {
    if (this == &that)
	return *this;
    this->~ChangePasswdData();
    bit_mask = that.bit_mask;
    newpasswd_field = that.newpasswd_field;
    targname_field = that.targname_field;
    targrealm_field = that.targrealm_field;
    return *this;
}

int ChangePasswdData::operator == (const ChangePasswdData & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (newpasswd_field != that.newpasswd_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (targname_field != that.targname_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (targrealm_field != that.targrealm_field)
	    return 0;
    }
    return 1;
}

int ChangePasswdData::operator != (const ChangePasswdData & that) const {
    return !(operator ==(that));
}

ChangePasswdData::newpasswd & ChangePasswdData::get_newpasswd() {
    return newpasswd_field;
}

const ChangePasswdData::newpasswd & ChangePasswdData::get_newpasswd() const {
    return newpasswd_field;
}

void ChangePasswdData::set_newpasswd(const newpasswd & newpasswd_val) {
    newpasswd_field = newpasswd_val;
}

ChangePasswdData::targname *ChangePasswdData::get_targname() {
    if (bit_mask & 0x80000000)
	return &targname_field;
    else
	return 0;
}

const ChangePasswdData::targname *ChangePasswdData::get_targname() const {
    if (bit_mask & 0x80000000)
	return &targname_field;
    else
	return 0;
}

void ChangePasswdData::set_targname(const targname & targname_val) {
    bit_mask |= 0x80000000;
    targname_field = targname_val;
}

int ChangePasswdData::targname_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ChangePasswdData::omit_targname() {
    targname_field.~PrincipalName();
    bit_mask &= ~0x80000000;
}

ChangePasswdData::targrealm *ChangePasswdData::get_targrealm() {
    if (bit_mask & 0x40000000)
	return &targrealm_field;
    else
	return 0;
}

const ChangePasswdData::targrealm *ChangePasswdData::get_targrealm() const {
    if (bit_mask & 0x40000000)
	return &targrealm_field;
    else
	return 0;
}

void ChangePasswdData::set_targrealm(const targrealm & targrealm_val) {
    bit_mask |= 0x40000000;
    targrealm_field = targrealm_val;
}

int ChangePasswdData::targrealm_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void ChangePasswdData::omit_targrealm() {
    targrealm_field.~OssString();
    bit_mask &= ~0x40000000;
}

void *ExternalPrincipalIdentifier::operator new(size_t size) {
    return ossNewFunc(size);
}

void ExternalPrincipalIdentifier::operator delete(void *ptr) {
    asn1Free(ptr);
}

ExternalPrincipalIdentifier::ExternalPrincipalIdentifier() {
    memset(this, 0, sizeof(ExternalPrincipalIdentifier));
}

ExternalPrincipalIdentifier::ExternalPrincipalIdentifier(const ExternalPrincipalIdentifier & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	subjectName_field = that.subjectName_field;
	issuerAndSerialNumber_field = that.issuerAndSerialNumber_field;
	subjectKeyIdentifier_field = that.subjectKeyIdentifier_field;
    } OSSCLEAN(ExternalPrincipalIdentifier)
}

ExternalPrincipalIdentifier::ExternalPrincipalIdentifier(const subjectName & subjectName_val, 
    const issuerAndSerialNumber & issuerAndSerialNumber_val, const subjectKeyIdentifier & subjectKeyIdentifier_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	subjectName_field = subjectName_val;
	issuerAndSerialNumber_field = issuerAndSerialNumber_val;
	subjectKeyIdentifier_field = subjectKeyIdentifier_val;
    } OSSCLEAN(ExternalPrincipalIdentifier)
}

ExternalPrincipalIdentifier & ExternalPrincipalIdentifier::operator = (const ExternalPrincipalIdentifier & that) {
    if (this == &that)
	return *this;
    this->~ExternalPrincipalIdentifier();
    bit_mask = that.bit_mask;
    subjectName_field = that.subjectName_field;
    issuerAndSerialNumber_field = that.issuerAndSerialNumber_field;
    subjectKeyIdentifier_field = that.subjectKeyIdentifier_field;
    return *this;
}

int ExternalPrincipalIdentifier::operator == (const ExternalPrincipalIdentifier & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (subjectName_field != that.subjectName_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (issuerAndSerialNumber_field != that.issuerAndSerialNumber_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (subjectKeyIdentifier_field != that.subjectKeyIdentifier_field)
	    return 0;
    }
    return 1;
}

int ExternalPrincipalIdentifier::operator != (const ExternalPrincipalIdentifier & that) const {
    return !(operator ==(that));
}

ExternalPrincipalIdentifier::subjectName *ExternalPrincipalIdentifier::get_subjectName() {
    if (bit_mask & 0x80000000)
	return &subjectName_field;
    else
	return 0;
}

const ExternalPrincipalIdentifier::subjectName *ExternalPrincipalIdentifier::get_subjectName() const {
    if (bit_mask & 0x80000000)
	return &subjectName_field;
    else
	return 0;
}

void ExternalPrincipalIdentifier::set_subjectName(const subjectName & subjectName_val) {
    bit_mask |= 0x80000000;
    subjectName_field = subjectName_val;
}

int ExternalPrincipalIdentifier::subjectName_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ExternalPrincipalIdentifier::omit_subjectName() {
    subjectName_field.~OssString();
    bit_mask &= ~0x80000000;
}

ExternalPrincipalIdentifier::issuerAndSerialNumber *ExternalPrincipalIdentifier::get_issuerAndSerialNumber() {
    if (bit_mask & 0x40000000)
	return &issuerAndSerialNumber_field;
    else
	return 0;
}

const ExternalPrincipalIdentifier::issuerAndSerialNumber *ExternalPrincipalIdentifier::get_issuerAndSerialNumber() const {
    if (bit_mask & 0x40000000)
	return &issuerAndSerialNumber_field;
    else
	return 0;
}

void ExternalPrincipalIdentifier::set_issuerAndSerialNumber(const issuerAndSerialNumber & issuerAndSerialNumber_val) {
    bit_mask |= 0x40000000;
    issuerAndSerialNumber_field = issuerAndSerialNumber_val;
}

int ExternalPrincipalIdentifier::issuerAndSerialNumber_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void ExternalPrincipalIdentifier::omit_issuerAndSerialNumber() {
    issuerAndSerialNumber_field.~OssString();
    bit_mask &= ~0x40000000;
}

ExternalPrincipalIdentifier::subjectKeyIdentifier *ExternalPrincipalIdentifier::get_subjectKeyIdentifier() {
    if (bit_mask & 0x20000000)
	return &subjectKeyIdentifier_field;
    else
	return 0;
}

const ExternalPrincipalIdentifier::subjectKeyIdentifier *ExternalPrincipalIdentifier::get_subjectKeyIdentifier() const {
    if (bit_mask & 0x20000000)
	return &subjectKeyIdentifier_field;
    else
	return 0;
}

void ExternalPrincipalIdentifier::set_subjectKeyIdentifier(const subjectKeyIdentifier & subjectKeyIdentifier_val) {
    bit_mask |= 0x20000000;
    subjectKeyIdentifier_field = subjectKeyIdentifier_val;
}

int ExternalPrincipalIdentifier::subjectKeyIdentifier_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void ExternalPrincipalIdentifier::omit_subjectKeyIdentifier() {
    subjectKeyIdentifier_field.~OssString();
    bit_mask &= ~0x20000000;
}

/* Auxiliary data structures and functions for class __shared11 */

class __shared11_member {
public:
    __shared11_member *next;
    __shared11::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared11_member();
    __shared11_member(const __shared11::component & val);
};

void *__shared11_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared11_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared11_member::__shared11_member() {
}

__shared11_member::__shared11_member(const __shared11::component & val) {
    value = val;
}

static void *__shared11_copy(void *that) {
    return new __shared11_member(((__shared11_member *)that)->value);
}

static void __shared11_destroy(void *that) {
    delete (__shared11_member *)that;
}

static int __shared11_compare(void *val1, void *val2) {
    return (((__shared11_member *)val1)->value == ((__shared11_member *)val2)->value);
}

/* Constructors */

__shared11::__shared11() {
}

__shared11::__shared11(const __shared11 & that) {
    OSSTRY {
	do_copy(that, &__shared11_copy);
    } OSSCLEAN(__shared11)
}

/* Destructor */

__shared11::~__shared11() {
    do_destroy(&__shared11_destroy);
}

/* Operators: assignment, equality, inequality */

__shared11 & __shared11::operator = (const __shared11 & that) {
    do_destroy(&__shared11_destroy);
    do_copy(that, &__shared11_copy);
    return *this;
}

int __shared11::operator == (const __shared11 & that) const {
    return do_compare(that, &__shared11_compare);
}

int __shared11::operator != (const __shared11 & that) const {
    return !do_compare(that, &__shared11_compare);
}

/* Locate ("At" etc) methods */

__shared11::component *__shared11::at(OssIndex pos) {
    return &((__shared11_member *)pos)->value;
}

const __shared11::component *__shared11::at(OssIndex pos) const {
    return &((__shared11_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared11::prepend(const component & val) {
    __shared11_member *newrec = new __shared11_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared11::prepend(__shared11 *seq) {
    return do_prepend(seq);
}

OssIndex __shared11::insert_after(OssIndex pos, const component & val) {
    __shared11_member *newrec = new __shared11_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared11::insert_after(OssIndex pos, __shared11 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared11::remove_front() {
    __shared11_member *extr = (__shared11_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared11_destroy(extr);
    return 0;
}

int __shared11::remove_after(OssIndex pos) {
    __shared11_member *extr = (__shared11_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared11_destroy(extr);
    return 0;
}

/* Extract methods */

__shared11 *__shared11::extract_after(OssIndex begin, OssIndex end) {
    return (__shared11 *)do_extract_after(begin, end);
}

void *PA_PK_AS_REQ::operator new(size_t size) {
    return ossNewFunc(size);
}

void PA_PK_AS_REQ::operator delete(void *ptr) {
    asn1Free(ptr);
}

PA_PK_AS_REQ::PA_PK_AS_REQ() {
    memset(this, 0, sizeof(PA_PK_AS_REQ));
}

PA_PK_AS_REQ::PA_PK_AS_REQ(const PA_PK_AS_REQ & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	signedAuthPack_field = that.signedAuthPack_field;
	trustedCertifiers_field = that.trustedCertifiers_field;
	kdcPkId_field = that.kdcPkId_field;
    } OSSCLEAN(PA_PK_AS_REQ)
}

PA_PK_AS_REQ::PA_PK_AS_REQ(const signedAuthPack & signedAuthPack_val, const trustedCertifiers & trustedCertifiers_val, 
    const kdcPkId & kdcPkId_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	signedAuthPack_field = signedAuthPack_val;
	trustedCertifiers_field = trustedCertifiers_val;
	kdcPkId_field = kdcPkId_val;
    } OSSCLEAN(PA_PK_AS_REQ)
}

PA_PK_AS_REQ::PA_PK_AS_REQ(const signedAuthPack & signedAuthPack_val) {
    OSSTRY {
	bit_mask = 0;
	signedAuthPack_field = signedAuthPack_val;
    } OSSCLEAN(PA_PK_AS_REQ)
}

PA_PK_AS_REQ & PA_PK_AS_REQ::operator = (const PA_PK_AS_REQ & that) {
    if (this == &that)
	return *this;
    this->~PA_PK_AS_REQ();
    bit_mask = that.bit_mask;
    signedAuthPack_field = that.signedAuthPack_field;
    trustedCertifiers_field = that.trustedCertifiers_field;
    kdcPkId_field = that.kdcPkId_field;
    return *this;
}

int PA_PK_AS_REQ::operator == (const PA_PK_AS_REQ & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (signedAuthPack_field != that.signedAuthPack_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (trustedCertifiers_field != that.trustedCertifiers_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (kdcPkId_field != that.kdcPkId_field)
	    return 0;
    }
    return 1;
}

int PA_PK_AS_REQ::operator != (const PA_PK_AS_REQ & that) const {
    return !(operator ==(that));
}

PA_PK_AS_REQ::signedAuthPack & PA_PK_AS_REQ::get_signedAuthPack() {
    return signedAuthPack_field;
}

const PA_PK_AS_REQ::signedAuthPack & PA_PK_AS_REQ::get_signedAuthPack() const {
    return signedAuthPack_field;
}

void PA_PK_AS_REQ::set_signedAuthPack(const signedAuthPack & signedAuthPack_val) {
    signedAuthPack_field = signedAuthPack_val;
}

PA_PK_AS_REQ::trustedCertifiers *PA_PK_AS_REQ::get_trustedCertifiers() {
    if (bit_mask & 0x80000000)
	return &trustedCertifiers_field;
    else
	return 0;
}

const PA_PK_AS_REQ::trustedCertifiers *PA_PK_AS_REQ::get_trustedCertifiers() const {
    if (bit_mask & 0x80000000)
	return &trustedCertifiers_field;
    else
	return 0;
}

void PA_PK_AS_REQ::set_trustedCertifiers(const trustedCertifiers & trustedCertifiers_val) {
    bit_mask |= 0x80000000;
    trustedCertifiers_field = trustedCertifiers_val;
}

int PA_PK_AS_REQ::trustedCertifiers_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void PA_PK_AS_REQ::omit_trustedCertifiers() {
    trustedCertifiers_field.~__shared11();
    bit_mask &= ~0x80000000;
}

PA_PK_AS_REQ::kdcPkId *PA_PK_AS_REQ::get_kdcPkId() {
    if (bit_mask & 0x40000000)
	return &kdcPkId_field;
    else
	return 0;
}

const PA_PK_AS_REQ::kdcPkId *PA_PK_AS_REQ::get_kdcPkId() const {
    if (bit_mask & 0x40000000)
	return &kdcPkId_field;
    else
	return 0;
}

void PA_PK_AS_REQ::set_kdcPkId(const kdcPkId & kdcPkId_val) {
    bit_mask |= 0x40000000;
    kdcPkId_field = kdcPkId_val;
}

int PA_PK_AS_REQ::kdcPkId_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void PA_PK_AS_REQ::omit_kdcPkId() {
    kdcPkId_field.~OssString();
    bit_mask &= ~0x40000000;
}

void *PKAuthenticator::operator new(size_t size) {
    return ossNewFunc(size);
}

void PKAuthenticator::operator delete(void *ptr) {
    asn1Free(ptr);
}

PKAuthenticator::PKAuthenticator() {
    memset(this, 0, sizeof(PKAuthenticator));
}

PKAuthenticator::PKAuthenticator(const PKAuthenticator & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	cusec_field = that.cusec_field;
	ctime_field = that.ctime_field;
	nonce_field = that.nonce_field;
	paChecksum_field = that.paChecksum_field;
    } OSSCLEAN(PKAuthenticator)
}

PKAuthenticator::PKAuthenticator(cusec cusec_val, const ctime & ctime_val, nonce nonce_val, 
    const paChecksum & paChecksum_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	cusec_field = cusec_val;
	ctime_field = ctime_val;
	nonce_field = nonce_val;
	paChecksum_field = paChecksum_val;
    } OSSCLEAN(PKAuthenticator)
}

PKAuthenticator::PKAuthenticator(cusec cusec_val, const ctime & ctime_val, nonce nonce_val) {
    OSSTRY {
	bit_mask = 0;
	cusec_field = cusec_val;
	ctime_field = ctime_val;
	nonce_field = nonce_val;
    } OSSCLEAN(PKAuthenticator)
}

PKAuthenticator & PKAuthenticator::operator = (const PKAuthenticator & that) {
    if (this == &that)
	return *this;
    this->~PKAuthenticator();
    bit_mask = that.bit_mask;
    cusec_field = that.cusec_field;
    ctime_field = that.ctime_field;
    nonce_field = that.nonce_field;
    paChecksum_field = that.paChecksum_field;
    return *this;
}

int PKAuthenticator::operator == (const PKAuthenticator & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (cusec_field != that.cusec_field)
	return 0;
    if (ctime_field != that.ctime_field)
	return 0;
    if (nonce_field != that.nonce_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (paChecksum_field != that.paChecksum_field)
	    return 0;
    }
    return 1;
}

int PKAuthenticator::operator != (const PKAuthenticator & that) const {
    return !(operator ==(that));
}

PKAuthenticator::cusec & PKAuthenticator::get_cusec() {
    return cusec_field;
}

PKAuthenticator::cusec PKAuthenticator::get_cusec() const {
    return cusec_field;
}

void PKAuthenticator::set_cusec(cusec cusec_val) {
    cusec_field = cusec_val;
}

PKAuthenticator::ctime & PKAuthenticator::get_ctime() {
    return ctime_field;
}

const PKAuthenticator::ctime & PKAuthenticator::get_ctime() const {
    return ctime_field;
}

void PKAuthenticator::set_ctime(const ctime & ctime_val) {
    ctime_field = ctime_val;
}

PKAuthenticator::nonce & PKAuthenticator::get_nonce() {
    return nonce_field;
}

PKAuthenticator::nonce PKAuthenticator::get_nonce() const {
    return nonce_field;
}

void PKAuthenticator::set_nonce(nonce nonce_val) {
    nonce_field = nonce_val;
}

PKAuthenticator::paChecksum *PKAuthenticator::get_paChecksum() {
    if (bit_mask & 0x80000000)
	return &paChecksum_field;
    else
	return 0;
}

const PKAuthenticator::paChecksum *PKAuthenticator::get_paChecksum() const {
    if (bit_mask & 0x80000000)
	return &paChecksum_field;
    else
	return 0;
}

void PKAuthenticator::set_paChecksum(const paChecksum & paChecksum_val) {
    bit_mask |= 0x80000000;
    paChecksum_field = paChecksum_val;
}

int PKAuthenticator::paChecksum_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void PKAuthenticator::omit_paChecksum() {
    paChecksum_field.~OssString();
    bit_mask &= ~0x80000000;
}

void *AlgorithmIdentifier::operator new(size_t size) {
    return ossNewFunc(size);
}

void AlgorithmIdentifier::operator delete(void *ptr) {
    asn1Free(ptr);
}

AlgorithmIdentifier::AlgorithmIdentifier() {
    memset(this, 0, sizeof(AlgorithmIdentifier));
}

AlgorithmIdentifier::AlgorithmIdentifier(const AlgorithmIdentifier & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	algorithm_field = that.algorithm_field;
	parameters_field = that.parameters_field;
    } OSSCLEAN(AlgorithmIdentifier)
}

AlgorithmIdentifier::AlgorithmIdentifier(const algorithm & algorithm_val, const parameters & parameters_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	algorithm_field = algorithm_val;
	parameters_field = parameters_val;
    } OSSCLEAN(AlgorithmIdentifier)
}

AlgorithmIdentifier::AlgorithmIdentifier(const algorithm & algorithm_val) {
    OSSTRY {
	bit_mask = 0;
	algorithm_field = algorithm_val;
    } OSSCLEAN(AlgorithmIdentifier)
}

AlgorithmIdentifier & AlgorithmIdentifier::operator = (const AlgorithmIdentifier & that) {
    if (this == &that)
	return *this;
    this->~AlgorithmIdentifier();
    bit_mask = that.bit_mask;
    algorithm_field = that.algorithm_field;
    parameters_field = that.parameters_field;
    return *this;
}

int AlgorithmIdentifier::operator == (const AlgorithmIdentifier & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (algorithm_field != that.algorithm_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (parameters_field != that.parameters_field)
	    return 0;
    }
    return 1;
}

int AlgorithmIdentifier::operator != (const AlgorithmIdentifier & that) const {
    return !(operator ==(that));
}

AlgorithmIdentifier::algorithm & AlgorithmIdentifier::get_algorithm() {
    return algorithm_field;
}

const AlgorithmIdentifier::algorithm & AlgorithmIdentifier::get_algorithm() const {
    return algorithm_field;
}

void AlgorithmIdentifier::set_algorithm(const algorithm & algorithm_val) {
    algorithm_field = algorithm_val;
}

AlgorithmIdentifier::parameters *AlgorithmIdentifier::get_parameters() {
    if (bit_mask & 0x80000000)
	return &parameters_field;
    else
	return 0;
}

const AlgorithmIdentifier::parameters *AlgorithmIdentifier::get_parameters() const {
    if (bit_mask & 0x80000000)
	return &parameters_field;
    else
	return 0;
}

void AlgorithmIdentifier::set_parameters(const parameters & parameters_val) {
    bit_mask |= 0x80000000;
    parameters_field = parameters_val;
}

int AlgorithmIdentifier::parameters_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void AlgorithmIdentifier::omit_parameters() {
    parameters_field.~OssString();
    bit_mask &= ~0x80000000;
}

void *SubjectPublicKeyInfo::operator new(size_t size) {
    return ossNewFunc(size);
}

void SubjectPublicKeyInfo::operator delete(void *ptr) {
    asn1Free(ptr);
}

SubjectPublicKeyInfo::SubjectPublicKeyInfo() {
    memset(this, 0, sizeof(SubjectPublicKeyInfo));
}

SubjectPublicKeyInfo::SubjectPublicKeyInfo(const SubjectPublicKeyInfo & that) {
    OSSTRY {
	algorithm_field = that.algorithm_field;
	subjectPublicKey_field = that.subjectPublicKey_field;
    } OSSCLEAN(SubjectPublicKeyInfo)
}

SubjectPublicKeyInfo::SubjectPublicKeyInfo(const algorithm & algorithm_val, const subjectPublicKey & subjectPublicKey_val) {
    OSSTRY {
	algorithm_field = algorithm_val;
	subjectPublicKey_field = subjectPublicKey_val;
    } OSSCLEAN(SubjectPublicKeyInfo)
}

SubjectPublicKeyInfo & SubjectPublicKeyInfo::operator = (const SubjectPublicKeyInfo & that) {
    if (this == &that)
	return *this;
    algorithm_field = that.algorithm_field;
    subjectPublicKey_field = that.subjectPublicKey_field;
    return *this;
}

int SubjectPublicKeyInfo::operator == (const SubjectPublicKeyInfo & that) const {
    if (algorithm_field != that.algorithm_field)
	return 0;
    if (subjectPublicKey_field != that.subjectPublicKey_field)
	return 0;
    return 1;
}

int SubjectPublicKeyInfo::operator != (const SubjectPublicKeyInfo & that) const {
    return !(operator ==(that));
}

SubjectPublicKeyInfo::algorithm & SubjectPublicKeyInfo::get_algorithm() {
    return algorithm_field;
}

const SubjectPublicKeyInfo::algorithm & SubjectPublicKeyInfo::get_algorithm() const {
    return algorithm_field;
}

void SubjectPublicKeyInfo::set_algorithm(const algorithm & algorithm_val) {
    algorithm_field = algorithm_val;
}

SubjectPublicKeyInfo::subjectPublicKey & SubjectPublicKeyInfo::get_subjectPublicKey() {
    return subjectPublicKey_field;
}

const SubjectPublicKeyInfo::subjectPublicKey & SubjectPublicKeyInfo::get_subjectPublicKey() const {
    return subjectPublicKey_field;
}

void SubjectPublicKeyInfo::set_subjectPublicKey(const subjectPublicKey & subjectPublicKey_val) {
    subjectPublicKey_field = subjectPublicKey_val;
}

/* Auxiliary data structures and functions for class __shared12 */

class __shared12_member {
public:
    __shared12_member *next;
    __shared12::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared12_member();
    __shared12_member(const __shared12::component & val);
};

void *__shared12_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared12_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared12_member::__shared12_member() {
}

__shared12_member::__shared12_member(const __shared12::component & val) {
    value = val;
}

static void *__shared12_copy(void *that) {
    return new __shared12_member(((__shared12_member *)that)->value);
}

static void __shared12_destroy(void *that) {
    delete (__shared12_member *)that;
}

static int __shared12_compare(void *val1, void *val2) {
    return (((__shared12_member *)val1)->value == ((__shared12_member *)val2)->value);
}

/* Constructors */

__shared12::__shared12() {
}

__shared12::__shared12(const __shared12 & that) {
    OSSTRY {
	do_copy(that, &__shared12_copy);
    } OSSCLEAN(__shared12)
}

/* Destructor */

__shared12::~__shared12() {
    do_destroy(&__shared12_destroy);
}

/* Operators: assignment, equality, inequality */

__shared12 & __shared12::operator = (const __shared12 & that) {
    do_destroy(&__shared12_destroy);
    do_copy(that, &__shared12_copy);
    return *this;
}

int __shared12::operator == (const __shared12 & that) const {
    return do_compare(that, &__shared12_compare);
}

int __shared12::operator != (const __shared12 & that) const {
    return !do_compare(that, &__shared12_compare);
}

/* Locate ("At" etc) methods */

__shared12::component *__shared12::at(OssIndex pos) {
    return &((__shared12_member *)pos)->value;
}

const __shared12::component *__shared12::at(OssIndex pos) const {
    return &((__shared12_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared12::prepend(const component & val) {
    __shared12_member *newrec = new __shared12_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared12::prepend(__shared12 *seq) {
    return do_prepend(seq);
}

OssIndex __shared12::insert_after(OssIndex pos, const component & val) {
    __shared12_member *newrec = new __shared12_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared12::insert_after(OssIndex pos, __shared12 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared12::remove_front() {
    __shared12_member *extr = (__shared12_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared12_destroy(extr);
    return 0;
}

int __shared12::remove_after(OssIndex pos) {
    __shared12_member *extr = (__shared12_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared12_destroy(extr);
    return 0;
}

/* Extract methods */

__shared12 *__shared12::extract_after(OssIndex begin, OssIndex end) {
    return (__shared12 *)do_extract_after(begin, end);
}

void *AuthPack::operator new(size_t size) {
    return ossNewFunc(size);
}

void AuthPack::operator delete(void *ptr) {
    asn1Free(ptr);
}

AuthPack::AuthPack() {
    memset(this, 0, sizeof(AuthPack));
}

AuthPack::AuthPack(const AuthPack & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	pkAuthenticator_field = that.pkAuthenticator_field;
	clientPublicValue_field = that.clientPublicValue_field;
	supportedCMSTypes_field = that.supportedCMSTypes_field;
	clientDHNonce_field = that.clientDHNonce_field;
    } OSSCLEAN(AuthPack)
}

AuthPack::AuthPack(const pkAuthenticator & pkAuthenticator_val, const clientPublicValue & clientPublicValue_val, 
    const supportedCMSTypes & supportedCMSTypes_val, const clientDHNonce & clientDHNonce_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	pkAuthenticator_field = pkAuthenticator_val;
	clientPublicValue_field = clientPublicValue_val;
	supportedCMSTypes_field = supportedCMSTypes_val;
	clientDHNonce_field = clientDHNonce_val;
    } OSSCLEAN(AuthPack)
}

AuthPack::AuthPack(const pkAuthenticator & pkAuthenticator_val) {
    OSSTRY {
	bit_mask = 0;
	pkAuthenticator_field = pkAuthenticator_val;
    } OSSCLEAN(AuthPack)
}

AuthPack & AuthPack::operator = (const AuthPack & that) {
    if (this == &that)
	return *this;
    this->~AuthPack();
    bit_mask = that.bit_mask;
    pkAuthenticator_field = that.pkAuthenticator_field;
    clientPublicValue_field = that.clientPublicValue_field;
    supportedCMSTypes_field = that.supportedCMSTypes_field;
    clientDHNonce_field = that.clientDHNonce_field;
    return *this;
}

int AuthPack::operator == (const AuthPack & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (pkAuthenticator_field != that.pkAuthenticator_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (clientPublicValue_field != that.clientPublicValue_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (supportedCMSTypes_field != that.supportedCMSTypes_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (clientDHNonce_field != that.clientDHNonce_field)
	    return 0;
    }
    return 1;
}

int AuthPack::operator != (const AuthPack & that) const {
    return !(operator ==(that));
}

AuthPack::pkAuthenticator & AuthPack::get_pkAuthenticator() {
    return pkAuthenticator_field;
}

const AuthPack::pkAuthenticator & AuthPack::get_pkAuthenticator() const {
    return pkAuthenticator_field;
}

void AuthPack::set_pkAuthenticator(const pkAuthenticator & pkAuthenticator_val) {
    pkAuthenticator_field = pkAuthenticator_val;
}

AuthPack::clientPublicValue *AuthPack::get_clientPublicValue() {
    if (bit_mask & 0x80000000)
	return &clientPublicValue_field;
    else
	return 0;
}

const AuthPack::clientPublicValue *AuthPack::get_clientPublicValue() const {
    if (bit_mask & 0x80000000)
	return &clientPublicValue_field;
    else
	return 0;
}

void AuthPack::set_clientPublicValue(const clientPublicValue & clientPublicValue_val) {
    bit_mask |= 0x80000000;
    clientPublicValue_field = clientPublicValue_val;
}

int AuthPack::clientPublicValue_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void AuthPack::omit_clientPublicValue() {
    clientPublicValue_field.~SubjectPublicKeyInfo();
    bit_mask &= ~0x80000000;
}

AuthPack::supportedCMSTypes *AuthPack::get_supportedCMSTypes() {
    if (bit_mask & 0x40000000)
	return &supportedCMSTypes_field;
    else
	return 0;
}

const AuthPack::supportedCMSTypes *AuthPack::get_supportedCMSTypes() const {
    if (bit_mask & 0x40000000)
	return &supportedCMSTypes_field;
    else
	return 0;
}

void AuthPack::set_supportedCMSTypes(const supportedCMSTypes & supportedCMSTypes_val) {
    bit_mask |= 0x40000000;
    supportedCMSTypes_field = supportedCMSTypes_val;
}

int AuthPack::supportedCMSTypes_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void AuthPack::omit_supportedCMSTypes() {
    supportedCMSTypes_field.~__shared12();
    bit_mask &= ~0x40000000;
}

AuthPack::clientDHNonce *AuthPack::get_clientDHNonce() {
    if (bit_mask & 0x20000000)
	return &clientDHNonce_field;
    else
	return 0;
}

const AuthPack::clientDHNonce *AuthPack::get_clientDHNonce() const {
    if (bit_mask & 0x20000000)
	return &clientDHNonce_field;
    else
	return 0;
}

void AuthPack::set_clientDHNonce(const clientDHNonce & clientDHNonce_val) {
    bit_mask |= 0x20000000;
    clientDHNonce_field = clientDHNonce_val;
}

int AuthPack::clientDHNonce_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void AuthPack::omit_clientDHNonce() {
    clientDHNonce_field.~OssString();
    bit_mask &= ~0x20000000;
}

void *KRB5PrincipalName::operator new(size_t size) {
    return ossNewFunc(size);
}

void KRB5PrincipalName::operator delete(void *ptr) {
    asn1Free(ptr);
}

KRB5PrincipalName::KRB5PrincipalName() {
    memset(this, 0, sizeof(KRB5PrincipalName));
}

KRB5PrincipalName::KRB5PrincipalName(const KRB5PrincipalName & that) {
    OSSTRY {
	realm_field = that.realm_field;
	principalName_field = that.principalName_field;
    } OSSCLEAN(KRB5PrincipalName)
}

KRB5PrincipalName::KRB5PrincipalName(const realm & realm_val, const principalName & principalName_val) {
    OSSTRY {
	realm_field = realm_val;
	principalName_field = principalName_val;
    } OSSCLEAN(KRB5PrincipalName)
}

KRB5PrincipalName & KRB5PrincipalName::operator = (const KRB5PrincipalName & that) {
    if (this == &that)
	return *this;
    realm_field = that.realm_field;
    principalName_field = that.principalName_field;
    return *this;
}

int KRB5PrincipalName::operator == (const KRB5PrincipalName & that) const {
    if (realm_field != that.realm_field)
	return 0;
    if (principalName_field != that.principalName_field)
	return 0;
    return 1;
}

int KRB5PrincipalName::operator != (const KRB5PrincipalName & that) const {
    return !(operator ==(that));
}

KRB5PrincipalName::realm & KRB5PrincipalName::get_realm() {
    return realm_field;
}

const KRB5PrincipalName::realm & KRB5PrincipalName::get_realm() const {
    return realm_field;
}

void KRB5PrincipalName::set_realm(const realm & realm_val) {
    realm_field = realm_val;
}

KRB5PrincipalName::principalName & KRB5PrincipalName::get_principalName() {
    return principalName_field;
}

const KRB5PrincipalName::principalName & KRB5PrincipalName::get_principalName() const {
    return principalName_field;
}

void KRB5PrincipalName::set_principalName(const principalName & principalName_val) {
    principalName_field = principalName_val;
}

void *DHRepInfo::operator new(size_t size) {
    return ossNewFunc(size);
}

void DHRepInfo::operator delete(void *ptr) {
    asn1Free(ptr);
}

DHRepInfo::DHRepInfo() {
    memset(this, 0, sizeof(DHRepInfo));
}

DHRepInfo::DHRepInfo(const DHRepInfo & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	dhSignedData_field = that.dhSignedData_field;
	serverDHNonce_field = that.serverDHNonce_field;
    } OSSCLEAN(DHRepInfo)
}

DHRepInfo::DHRepInfo(const dhSignedData & dhSignedData_val, const serverDHNonce & serverDHNonce_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	dhSignedData_field = dhSignedData_val;
	serverDHNonce_field = serverDHNonce_val;
    } OSSCLEAN(DHRepInfo)
}

DHRepInfo::DHRepInfo(const dhSignedData & dhSignedData_val) {
    OSSTRY {
	bit_mask = 0;
	dhSignedData_field = dhSignedData_val;
    } OSSCLEAN(DHRepInfo)
}

DHRepInfo & DHRepInfo::operator = (const DHRepInfo & that) {
    if (this == &that)
	return *this;
    this->~DHRepInfo();
    bit_mask = that.bit_mask;
    dhSignedData_field = that.dhSignedData_field;
    serverDHNonce_field = that.serverDHNonce_field;
    return *this;
}

int DHRepInfo::operator == (const DHRepInfo & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (dhSignedData_field != that.dhSignedData_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (serverDHNonce_field != that.serverDHNonce_field)
	    return 0;
    }
    return 1;
}

int DHRepInfo::operator != (const DHRepInfo & that) const {
    return !(operator ==(that));
}

DHRepInfo::dhSignedData & DHRepInfo::get_dhSignedData() {
    return dhSignedData_field;
}

const DHRepInfo::dhSignedData & DHRepInfo::get_dhSignedData() const {
    return dhSignedData_field;
}

void DHRepInfo::set_dhSignedData(const dhSignedData & dhSignedData_val) {
    dhSignedData_field = dhSignedData_val;
}

DHRepInfo::serverDHNonce *DHRepInfo::get_serverDHNonce() {
    if (bit_mask & 0x80000000)
	return &serverDHNonce_field;
    else
	return 0;
}

const DHRepInfo::serverDHNonce *DHRepInfo::get_serverDHNonce() const {
    if (bit_mask & 0x80000000)
	return &serverDHNonce_field;
    else
	return 0;
}

void DHRepInfo::set_serverDHNonce(const serverDHNonce & serverDHNonce_val) {
    bit_mask |= 0x80000000;
    serverDHNonce_field = serverDHNonce_val;
}

int DHRepInfo::serverDHNonce_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void DHRepInfo::omit_serverDHNonce() {
    serverDHNonce_field.~OssString();
    bit_mask &= ~0x80000000;
}

PA_PK_AS_REP::PA_PK_AS_REP() {
    memset(this, 0, sizeof(PA_PK_AS_REP));
}

PA_PK_AS_REP::PA_PK_AS_REP(const PA_PK_AS_REP & that) {
    memset(this, 0, sizeof(PA_PK_AS_REP));
    operator =(that);
}

PA_PK_AS_REP::~PA_PK_AS_REP() {
    cleanup();
}

PA_PK_AS_REP & PA_PK_AS_REP::operator = (const PA_PK_AS_REP & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case dhInfo_chosen:
	    if (that.dhInfo_field)
		dhInfo_field = new dhInfo(*that.dhInfo_field);
	    break;
	case encKeyPack_chosen:
	    *(encKeyPack *)&encKeyPack_field = *(encKeyPack *)&that.encKeyPack_field;
	    break;
    }
    return *this;
}

int PA_PK_AS_REP::operator == (const PA_PK_AS_REP & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case dhInfo_chosen:
	    if ((dhInfo_field) && (that.dhInfo_field))
		return (*dhInfo_field == *(that.dhInfo_field));
	    else if (!((!dhInfo_field) && (!that.dhInfo_field)))
		return 0;
	    break;
	case encKeyPack_chosen:
	    return *(encKeyPack *)&encKeyPack_field == *(encKeyPack *)&that.encKeyPack_field;
    }

    return 1;
}

int PA_PK_AS_REP::operator != (const PA_PK_AS_REP & that) const {
    return !(operator ==(that));
}

PA_PK_AS_REP::dhInfo *PA_PK_AS_REP::get_dhInfo() {
    if (_choice == dhInfo_chosen)
	return (dhInfo *)dhInfo_field;
    else
	return 0;
}

const PA_PK_AS_REP::dhInfo *PA_PK_AS_REP::get_dhInfo() const {
    if (_choice == dhInfo_chosen)
	return (const dhInfo *)dhInfo_field;
    else
	return 0;
}

void PA_PK_AS_REP::set_dhInfo(const dhInfo & dhInfo_val) {
    cleanup();
    dhInfo_field = new dhInfo(dhInfo_val);
    _choice = dhInfo_chosen;
}

PA_PK_AS_REP::encKeyPack *PA_PK_AS_REP::get_encKeyPack() {
    if (_choice == encKeyPack_chosen)
	return (encKeyPack *)&encKeyPack_field;
    else
	return 0;
}

const PA_PK_AS_REP::encKeyPack *PA_PK_AS_REP::get_encKeyPack() const {
    if (_choice == encKeyPack_chosen)
	return (const encKeyPack *)&encKeyPack_field;
    else
	return 0;
}

void PA_PK_AS_REP::set_encKeyPack(const encKeyPack & encKeyPack_val) {
    cleanup();
    *(encKeyPack *)&encKeyPack_field = encKeyPack_val;
    _choice = encKeyPack_chosen;
}

void PA_PK_AS_REP::cleanup() {
    switch (_choice) {
	case dhInfo_chosen:
	    if (dhInfo_field)
		delete dhInfo_field;
	    break;
	case encKeyPack_chosen:
	    ((encKeyPack *)&encKeyPack_field)->~OssString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *KDCDHKeyInfo::operator new(size_t size) {
    return ossNewFunc(size);
}

void KDCDHKeyInfo::operator delete(void *ptr) {
    asn1Free(ptr);
}

KDCDHKeyInfo::KDCDHKeyInfo() {
    memset(this, 0, sizeof(KDCDHKeyInfo));
}

KDCDHKeyInfo::KDCDHKeyInfo(const KDCDHKeyInfo & that) {
    OSSTRY {
	subjectPublicKey_field = that.subjectPublicKey_field;
	nonce_field = that.nonce_field;
	dhKeyExpiration_field = that.dhKeyExpiration_field;
    } OSSCLEAN(KDCDHKeyInfo)
}

KDCDHKeyInfo::KDCDHKeyInfo(const subjectPublicKey & subjectPublicKey_val, nonce nonce_val, 
    const dhKeyExpiration & dhKeyExpiration_val) {
    OSSTRY {
	subjectPublicKey_field = subjectPublicKey_val;
	nonce_field = nonce_val;
	dhKeyExpiration_field = dhKeyExpiration_val;
    } OSSCLEAN(KDCDHKeyInfo)
}

KDCDHKeyInfo::KDCDHKeyInfo(const subjectPublicKey & subjectPublicKey_val, nonce nonce_val) {
    OSSTRY {
	subjectPublicKey_field = subjectPublicKey_val;
	nonce_field = nonce_val;
    } OSSCLEAN(KDCDHKeyInfo)
}

KDCDHKeyInfo & KDCDHKeyInfo::operator = (const KDCDHKeyInfo & that) {
    if (this == &that)
	return *this;
    this->~KDCDHKeyInfo();
    subjectPublicKey_field = that.subjectPublicKey_field;
    nonce_field = that.nonce_field;
    dhKeyExpiration_field = that.dhKeyExpiration_field;
    return *this;
}

int KDCDHKeyInfo::operator == (const KDCDHKeyInfo & that) const {
    if (subjectPublicKey_field != that.subjectPublicKey_field)
	return 0;
    if (nonce_field != that.nonce_field)
	return 0;
    if (dhKeyExpiration_field != that.dhKeyExpiration_field)
	return 0;
    return 1;
}

int KDCDHKeyInfo::operator != (const KDCDHKeyInfo & that) const {
    return !(operator ==(that));
}

KDCDHKeyInfo::subjectPublicKey & KDCDHKeyInfo::get_subjectPublicKey() {
    return subjectPublicKey_field;
}

const KDCDHKeyInfo::subjectPublicKey & KDCDHKeyInfo::get_subjectPublicKey() const {
    return subjectPublicKey_field;
}

void KDCDHKeyInfo::set_subjectPublicKey(const subjectPublicKey & subjectPublicKey_val) {
    subjectPublicKey_field = subjectPublicKey_val;
}

KDCDHKeyInfo::nonce & KDCDHKeyInfo::get_nonce() {
    return nonce_field;
}

KDCDHKeyInfo::nonce KDCDHKeyInfo::get_nonce() const {
    return nonce_field;
}

void KDCDHKeyInfo::set_nonce(nonce nonce_val) {
    nonce_field = nonce_val;
}

KDCDHKeyInfo::dhKeyExpiration *KDCDHKeyInfo::get_dhKeyExpiration() {
    if (*(char **)&dhKeyExpiration_field)
	return &dhKeyExpiration_field;
    else
	return 0;
}

const KDCDHKeyInfo::dhKeyExpiration *KDCDHKeyInfo::get_dhKeyExpiration() const {
    if (*(char **)&dhKeyExpiration_field)
	return &dhKeyExpiration_field;
    else
	return 0;
}

void KDCDHKeyInfo::set_dhKeyExpiration(const dhKeyExpiration & dhKeyExpiration_val) {
    dhKeyExpiration_field = dhKeyExpiration_val;
}

int KDCDHKeyInfo::dhKeyExpiration_is_present() const {
    return !!(*(char **)&dhKeyExpiration_field);
}

void KDCDHKeyInfo::omit_dhKeyExpiration() {
    dhKeyExpiration_field.~OssGeneralizedTime();
}

void *ReplyKeyPack::operator new(size_t size) {
    return ossNewFunc(size);
}

void ReplyKeyPack::operator delete(void *ptr) {
    asn1Free(ptr);
}

ReplyKeyPack::ReplyKeyPack() {
    memset(this, 0, sizeof(ReplyKeyPack));
}

ReplyKeyPack::ReplyKeyPack(const ReplyKeyPack & that) {
    OSSTRY {
	replyKey_field = that.replyKey_field;
	asChecksum_field = that.asChecksum_field;
    } OSSCLEAN(ReplyKeyPack)
}

ReplyKeyPack::ReplyKeyPack(const replyKey & replyKey_val, const asChecksum & asChecksum_val) {
    OSSTRY {
	replyKey_field = replyKey_val;
	asChecksum_field = asChecksum_val;
    } OSSCLEAN(ReplyKeyPack)
}

ReplyKeyPack & ReplyKeyPack::operator = (const ReplyKeyPack & that) {
    if (this == &that)
	return *this;
    replyKey_field = that.replyKey_field;
    asChecksum_field = that.asChecksum_field;
    return *this;
}

int ReplyKeyPack::operator == (const ReplyKeyPack & that) const {
    if (replyKey_field != that.replyKey_field)
	return 0;
    if (asChecksum_field != that.asChecksum_field)
	return 0;
    return 1;
}

int ReplyKeyPack::operator != (const ReplyKeyPack & that) const {
    return !(operator ==(that));
}

ReplyKeyPack::replyKey & ReplyKeyPack::get_replyKey() {
    return replyKey_field;
}

const ReplyKeyPack::replyKey & ReplyKeyPack::get_replyKey() const {
    return replyKey_field;
}

void ReplyKeyPack::set_replyKey(const replyKey & replyKey_val) {
    replyKey_field = replyKey_val;
}

ReplyKeyPack::asChecksum & ReplyKeyPack::get_asChecksum() {
    return asChecksum_field;
}

const ReplyKeyPack::asChecksum & ReplyKeyPack::get_asChecksum() const {
    return asChecksum_field;
}

void ReplyKeyPack::set_asChecksum(const asChecksum & asChecksum_val) {
    asChecksum_field = asChecksum_val;
}

void *Attribute::operator new(size_t size) {
    return ossNewFunc(size);
}

void Attribute::operator delete(void *ptr) {
    asn1Free(ptr);
}

Attribute::Attribute() {
    memset(this, 0, sizeof(Attribute));
}

Attribute::Attribute(const Attribute & that) {
    OSSTRY {
	type_field = that.type_field;
	values_field = that.values_field;
    } OSSCLEAN(Attribute)
}

Attribute::Attribute(const type & type_val, const values & values_val) {
    OSSTRY {
	type_field = type_val;
	values_field = values_val;
    } OSSCLEAN(Attribute)
}

Attribute & Attribute::operator = (const Attribute & that) {
    if (this == &that)
	return *this;
    type_field = that.type_field;
    values_field = that.values_field;
    return *this;
}

int Attribute::operator == (const Attribute & that) const {
    if (type_field != that.type_field)
	return 0;
    if (values_field != that.values_field)
	return 0;
    return 1;
}

int Attribute::operator != (const Attribute & that) const {
    return !(operator ==(that));
}

Attribute::type & Attribute::get_type() {
    return type_field;
}

const Attribute::type & Attribute::get_type() const {
    return type_field;
}

void Attribute::set_type(const type & type_val) {
    type_field = type_val;
}

Attribute::values & Attribute::get_values() {
    return values_field;
}

const Attribute::values & Attribute::get_values() const {
    return values_field;
}

void Attribute::set_values(const values & values_val) {
    values_field = values_val;
}

void *AttributeTypeAndValue::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttributeTypeAndValue::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttributeTypeAndValue::AttributeTypeAndValue() {
    memset(this, 0, sizeof(AttributeTypeAndValue));
}

AttributeTypeAndValue::AttributeTypeAndValue(const AttributeTypeAndValue & that) {
    OSSTRY {
	type_field = that.type_field;
	value_field = that.value_field;
    } OSSCLEAN(AttributeTypeAndValue)
}

AttributeTypeAndValue::AttributeTypeAndValue(const type & type_val, const value & value_val) {
    OSSTRY {
	type_field = type_val;
	value_field = value_val;
    } OSSCLEAN(AttributeTypeAndValue)
}

AttributeTypeAndValue & AttributeTypeAndValue::operator = (const AttributeTypeAndValue & that) {
    if (this == &that)
	return *this;
    type_field = that.type_field;
    value_field = that.value_field;
    return *this;
}

int AttributeTypeAndValue::operator == (const AttributeTypeAndValue & that) const {
    if (type_field != that.type_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int AttributeTypeAndValue::operator != (const AttributeTypeAndValue & that) const {
    return !(operator ==(that));
}

AttributeTypeAndValue::type & AttributeTypeAndValue::get_type() {
    return type_field;
}

const AttributeTypeAndValue::type & AttributeTypeAndValue::get_type() const {
    return type_field;
}

void AttributeTypeAndValue::set_type(const type & type_val) {
    type_field = type_val;
}

AttributeTypeAndValue::value & AttributeTypeAndValue::get_value() {
    return value_field;
}

const AttributeTypeAndValue::value & AttributeTypeAndValue::get_value() const {
    return value_field;
}

void AttributeTypeAndValue::set_value(const value & value_val) {
    value_field = value_val;
}

__shared13::__shared13() {
    memset(this, 0, sizeof(__shared13));
}

__shared13::__shared13(const __shared13 & that) {
    memset(this, 0, sizeof(__shared13));
    operator =(that);
}

__shared13::~__shared13() {
    cleanup();
}

__shared13 & __shared13::operator = (const __shared13 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case teletexString_chosen:
	    *(teletexString *)&teletexString_field = *(teletexString *)&that.teletexString_field;
	    break;
	case printableString_chosen:
	    *(printableString *)&printableString_field = *(printableString *)&that.printableString_field;
	    break;
	case universalString_chosen:
	    *(universalString *)&universalString_field = *(universalString *)&that.universalString_field;
	    break;
	case utf8String_chosen:
	    *(utf8String *)&utf8String_field = *(utf8String *)&that.utf8String_field;
	    break;
	case bmpString_chosen:
	    *(bmpString *)&bmpString_field = *(bmpString *)&that.bmpString_field;
	    break;
    }
    return *this;
}

int __shared13::operator == (const __shared13 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case teletexString_chosen:
	    return *(teletexString *)&teletexString_field == *(teletexString *)&that.teletexString_field;
	case printableString_chosen:
	    return *(printableString *)&printableString_field == *(printableString *)&that.printableString_field;
	case universalString_chosen:
	    return *(universalString *)&universalString_field == *(universalString *)&that.universalString_field;
	case utf8String_chosen:
	    return *(utf8String *)&utf8String_field == *(utf8String *)&that.utf8String_field;
	case bmpString_chosen:
	    return *(bmpString *)&bmpString_field == *(bmpString *)&that.bmpString_field;
    }

    return 1;
}

int __shared13::operator != (const __shared13 & that) const {
    return !(operator ==(that));
}

__shared13::teletexString *__shared13::get_teletexString() {
    if (_choice == teletexString_chosen)
	return (teletexString *)&teletexString_field;
    else
	return 0;
}

const __shared13::teletexString *__shared13::get_teletexString() const {
    if (_choice == teletexString_chosen)
	return (const teletexString *)&teletexString_field;
    else
	return 0;
}

void __shared13::set_teletexString(const teletexString & teletexString_val) {
    cleanup();
    *(teletexString *)&teletexString_field = teletexString_val;
    _choice = teletexString_chosen;
}

__shared13::printableString *__shared13::get_printableString() {
    if (_choice == printableString_chosen)
	return (printableString *)&printableString_field;
    else
	return 0;
}

const __shared13::printableString *__shared13::get_printableString() const {
    if (_choice == printableString_chosen)
	return (const printableString *)&printableString_field;
    else
	return 0;
}

void __shared13::set_printableString(const printableString & printableString_val) {
    cleanup();
    *(printableString *)&printableString_field = printableString_val;
    _choice = printableString_chosen;
}

__shared13::universalString *__shared13::get_universalString() {
    if (_choice == universalString_chosen)
	return (universalString *)&universalString_field;
    else
	return 0;
}

const __shared13::universalString *__shared13::get_universalString() const {
    if (_choice == universalString_chosen)
	return (const universalString *)&universalString_field;
    else
	return 0;
}

void __shared13::set_universalString(const universalString & universalString_val) {
    cleanup();
    *(universalString *)&universalString_field = universalString_val;
    _choice = universalString_chosen;
}

__shared13::utf8String *__shared13::get_utf8String() {
    if (_choice == utf8String_chosen)
	return (utf8String *)&utf8String_field;
    else
	return 0;
}

const __shared13::utf8String *__shared13::get_utf8String() const {
    if (_choice == utf8String_chosen)
	return (const utf8String *)&utf8String_field;
    else
	return 0;
}

void __shared13::set_utf8String(const utf8String & utf8String_val) {
    cleanup();
    *(utf8String *)&utf8String_field = utf8String_val;
    _choice = utf8String_chosen;
}

__shared13::bmpString *__shared13::get_bmpString() {
    if (_choice == bmpString_chosen)
	return (bmpString *)&bmpString_field;
    else
	return 0;
}

const __shared13::bmpString *__shared13::get_bmpString() const {
    if (_choice == bmpString_chosen)
	return (const bmpString *)&bmpString_field;
    else
	return 0;
}

void __shared13::set_bmpString(const bmpString & bmpString_val) {
    cleanup();
    *(bmpString *)&bmpString_field = bmpString_val;
    _choice = bmpString_chosen;
}

void __shared13::cleanup() {
    switch (_choice) {
	case teletexString_chosen:
	    ((teletexString *)&teletexString_field)->~OssString();
	    break;
	case printableString_chosen:
	    ((printableString *)&printableString_field)->~OssString();
	    break;
	case universalString_chosen:
	    ((universalString *)&universalString_field)->~OssUniversalString();
	    break;
	case utf8String_chosen:
	    ((utf8String *)&utf8String_field)->~OssString();
	    break;
	case bmpString_chosen:
	    ((bmpString *)&bmpString_field)->~OssBMPString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __shared14 */

class __shared14_member {
public:
    __shared14_member *next;
    __shared14::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared14_member();
    __shared14_member(const __shared14::component & val);
};

void *__shared14_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared14_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared14_member::__shared14_member() {
}

__shared14_member::__shared14_member(const __shared14::component & val) {
    value = val;
}

static void *__shared14_copy(void *that) {
    return new __shared14_member(((__shared14_member *)that)->value);
}

static void __shared14_destroy(void *that) {
    delete (__shared14_member *)that;
}

static int __shared14_compare(void *val1, void *val2) {
    return (((__shared14_member *)val1)->value == ((__shared14_member *)val2)->value);
}

/* Constructors */

__shared14::__shared14() {
}

__shared14::__shared14(const __shared14 & that) {
    OSSTRY {
	do_copy(that, &__shared14_copy);
    } OSSCLEAN(__shared14)
}

/* Destructor */

__shared14::~__shared14() {
    do_destroy(&__shared14_destroy);
}

/* Operators: assignment, equality, inequality */

__shared14 & __shared14::operator = (const __shared14 & that) {
    do_destroy(&__shared14_destroy);
    do_copy(that, &__shared14_copy);
    return *this;
}

int __shared14::operator == (const __shared14 & that) const {
    return do_compare(that, &__shared14_compare);
}

int __shared14::operator != (const __shared14 & that) const {
    return !do_compare(that, &__shared14_compare);
}

/* Locate ("At" etc) methods */

__shared14::component *__shared14::at(OssIndex pos) {
    return &((__shared14_member *)pos)->value;
}

const __shared14::component *__shared14::at(OssIndex pos) const {
    return &((__shared14_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared14::prepend(const component & val) {
    __shared14_member *newrec = new __shared14_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared14::prepend(__shared14 *seq) {
    return do_prepend(seq);
}

OssIndex __shared14::insert_after(OssIndex pos, const component & val) {
    __shared14_member *newrec = new __shared14_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared14::insert_after(OssIndex pos, __shared14 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared14::remove_front() {
    __shared14_member *extr = (__shared14_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared14_destroy(extr);
    return 0;
}

int __shared14::remove_after(OssIndex pos) {
    __shared14_member *extr = (__shared14_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared14_destroy(extr);
    return 0;
}

/* Extract methods */

__shared14 *__shared14::extract_after(OssIndex begin, OssIndex end) {
    return (__shared14 *)do_extract_after(begin, end);
}

Name::Name() {
    memset(this, 0, sizeof(Name));
}

Name::Name(const Name & that) {
    memset(this, 0, sizeof(Name));
    operator =(that);
}

Name::~Name() {
    cleanup();
}

Name & Name::operator = (const Name & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case rdnSequence_chosen:
	    *(rdnSequence *)&rdnSequence_field = *(rdnSequence *)&that.rdnSequence_field;
	    break;
    }
    return *this;
}

int Name::operator == (const Name & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case rdnSequence_chosen:
	    return *(rdnSequence *)&rdnSequence_field == *(rdnSequence *)&that.rdnSequence_field;
    }

    return 1;
}

int Name::operator != (const Name & that) const {
    return !(operator ==(that));
}

Name::rdnSequence *Name::get_rdnSequence() {
    if (_choice == rdnSequence_chosen)
	return (rdnSequence *)&rdnSequence_field;
    else
	return 0;
}

const Name::rdnSequence *Name::get_rdnSequence() const {
    if (_choice == rdnSequence_chosen)
	return (const rdnSequence *)&rdnSequence_field;
    else
	return 0;
}

void Name::set_rdnSequence(const rdnSequence & rdnSequence_val) {
    cleanup();
    *(rdnSequence *)&rdnSequence_field = rdnSequence_val;
    _choice = rdnSequence_chosen;
}

void Name::cleanup() {
    switch (_choice) {
	case rdnSequence_chosen:
	    ((rdnSequence *)&rdnSequence_field)->~__shared14();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class RelativeDistinguishedName */

class RelativeDistinguishedName_member {
public:
    RelativeDistinguishedName_member *next;
    RelativeDistinguishedName::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    RelativeDistinguishedName_member();
    RelativeDistinguishedName_member(const RelativeDistinguishedName::component & val);
};

void *RelativeDistinguishedName_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void RelativeDistinguishedName_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

RelativeDistinguishedName_member::RelativeDistinguishedName_member() {
}

RelativeDistinguishedName_member::RelativeDistinguishedName_member(const RelativeDistinguishedName::component & val) {
    value = val;
}

static void *RelativeDistinguishedName_copy(void *that) {
    return new RelativeDistinguishedName_member(((RelativeDistinguishedName_member *)that)->value);
}

static void RelativeDistinguishedName_destroy(void *that) {
    delete (RelativeDistinguishedName_member *)that;
}

static int RelativeDistinguishedName_compare(void *val1, void *val2) {
    return (((RelativeDistinguishedName_member *)val1)->value == ((RelativeDistinguishedName_member *)val2)->value);
}

/* Constructors */

RelativeDistinguishedName::RelativeDistinguishedName() {
}

RelativeDistinguishedName::RelativeDistinguishedName(const RelativeDistinguishedName & that) {
    OSSTRY {
	do_copy(that, &RelativeDistinguishedName_copy);
    } OSSCLEAN(RelativeDistinguishedName)
}

/* Destructor */

RelativeDistinguishedName::~RelativeDistinguishedName() {
    do_destroy(&RelativeDistinguishedName_destroy);
}

/* Operators: assignment, equality, inequality */

RelativeDistinguishedName & RelativeDistinguishedName::operator = (const RelativeDistinguishedName & that) {
    do_destroy(&RelativeDistinguishedName_destroy);
    do_copy(that, &RelativeDistinguishedName_copy);
    return *this;
}

int RelativeDistinguishedName::operator == (const RelativeDistinguishedName & that) const {
    return do_compare(that, &RelativeDistinguishedName_compare);
}

int RelativeDistinguishedName::operator != (const RelativeDistinguishedName & that) const {
    return !do_compare(that, &RelativeDistinguishedName_compare);
}

/* Locate ("At" etc) methods */

RelativeDistinguishedName::component *RelativeDistinguishedName::at(OssIndex pos) {
    return &((RelativeDistinguishedName_member *)pos)->value;
}

const RelativeDistinguishedName::component *RelativeDistinguishedName::at(OssIndex pos) const {
    return &((RelativeDistinguishedName_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex RelativeDistinguishedName::prepend(const component & val) {
    RelativeDistinguishedName_member *newrec = new RelativeDistinguishedName_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex RelativeDistinguishedName::prepend(RelativeDistinguishedName *seq) {
    return do_prepend(seq);
}

OssIndex RelativeDistinguishedName::insert_after(OssIndex pos, const component & val) {
    RelativeDistinguishedName_member *newrec = new RelativeDistinguishedName_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex RelativeDistinguishedName::insert_after(OssIndex pos, RelativeDistinguishedName *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int RelativeDistinguishedName::remove_front() {
    RelativeDistinguishedName_member *extr = (RelativeDistinguishedName_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    RelativeDistinguishedName_destroy(extr);
    return 0;
}

int RelativeDistinguishedName::remove_after(OssIndex pos) {
    RelativeDistinguishedName_member *extr = (RelativeDistinguishedName_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    RelativeDistinguishedName_destroy(extr);
    return 0;
}

/* Extract methods */

RelativeDistinguishedName *RelativeDistinguishedName::extract_after(OssIndex begin, OssIndex end) {
    return (RelativeDistinguishedName *)do_extract_after(begin, end);
}

Time::Time() {
    memset(this, 0, sizeof(Time));
}

Time::Time(const Time & that) {
    memset(this, 0, sizeof(Time));
    operator =(that);
}

Time::~Time() {
    cleanup();
}

Time & Time::operator = (const Time & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case utcTime_chosen:
	    *(utcTime *)&utcTime_field = *(utcTime *)&that.utcTime_field;
	    break;
	case generalTime_chosen:
	    *(generalTime *)&generalTime_field = *(generalTime *)&that.generalTime_field;
	    break;
    }
    return *this;
}

int Time::operator == (const Time & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case utcTime_chosen:
	    return *(utcTime *)&utcTime_field == *(utcTime *)&that.utcTime_field;
	case generalTime_chosen:
	    return *(generalTime *)&generalTime_field == *(generalTime *)&that.generalTime_field;
    }

    return 1;
}

int Time::operator != (const Time & that) const {
    return !(operator ==(that));
}

Time::utcTime *Time::get_utcTime() {
    if (_choice == utcTime_chosen)
	return (utcTime *)&utcTime_field;
    else
	return 0;
}

const Time::utcTime *Time::get_utcTime() const {
    if (_choice == utcTime_chosen)
	return (const utcTime *)&utcTime_field;
    else
	return 0;
}

void Time::set_utcTime(const utcTime & utcTime_val) {
    cleanup();
    *(utcTime *)&utcTime_field = utcTime_val;
    _choice = utcTime_chosen;
}

Time::generalTime *Time::get_generalTime() {
    if (_choice == generalTime_chosen)
	return (generalTime *)&generalTime_field;
    else
	return 0;
}

const Time::generalTime *Time::get_generalTime() const {
    if (_choice == generalTime_chosen)
	return (const generalTime *)&generalTime_field;
    else
	return 0;
}

void Time::set_generalTime(const generalTime & generalTime_val) {
    cleanup();
    *(generalTime *)&generalTime_field = generalTime_val;
    _choice = generalTime_chosen;
}

void Time::cleanup() {
    switch (_choice) {
	case utcTime_chosen:
	    ((utcTime *)&utcTime_field)->~OssUTCTime();
	    break;
	case generalTime_chosen:
	    ((generalTime *)&generalTime_field)->~OssGeneralizedTime();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *Validity::operator new(size_t size) {
    return ossNewFunc(size);
}

void Validity::operator delete(void *ptr) {
    asn1Free(ptr);
}

Validity::Validity() {
    memset(this, 0, sizeof(Validity));
}

Validity::Validity(const Validity & that) {
    OSSTRY {
	notBefore_field = that.notBefore_field;
	notAfter_field = that.notAfter_field;
    } OSSCLEAN(Validity)
}

Validity::Validity(const notBefore & notBefore_val, const notAfter & notAfter_val) {
    OSSTRY {
	notBefore_field = notBefore_val;
	notAfter_field = notAfter_val;
    } OSSCLEAN(Validity)
}

Validity & Validity::operator = (const Validity & that) {
    if (this == &that)
	return *this;
    notBefore_field = that.notBefore_field;
    notAfter_field = that.notAfter_field;
    return *this;
}

int Validity::operator == (const Validity & that) const {
    if (notBefore_field != that.notBefore_field)
	return 0;
    if (notAfter_field != that.notAfter_field)
	return 0;
    return 1;
}

int Validity::operator != (const Validity & that) const {
    return !(operator ==(that));
}

Validity::notBefore & Validity::get_notBefore() {
    return notBefore_field;
}

const Validity::notBefore & Validity::get_notBefore() const {
    return notBefore_field;
}

void Validity::set_notBefore(const notBefore & notBefore_val) {
    notBefore_field = notBefore_val;
}

Validity::notAfter & Validity::get_notAfter() {
    return notAfter_field;
}

const Validity::notAfter & Validity::get_notAfter() const {
    return notAfter_field;
}

void Validity::set_notAfter(const notAfter & notAfter_val) {
    notAfter_field = notAfter_val;
}

/* Auxiliary data structures and functions for class __shared15 */

class __shared15_member {
public:
    __shared15_member *next;
    __shared15::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared15_member();
    __shared15_member(const __shared15::component & val);
};

void *__shared15_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared15_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared15_member::__shared15_member() {
}

__shared15_member::__shared15_member(const __shared15::component & val) {
    value = val;
}

static void *__shared15_copy(void *that) {
    return new __shared15_member(((__shared15_member *)that)->value);
}

static void __shared15_destroy(void *that) {
    delete (__shared15_member *)that;
}

static int __shared15_compare(void *val1, void *val2) {
    return (((__shared15_member *)val1)->value == ((__shared15_member *)val2)->value);
}

/* Constructors */

__shared15::__shared15() {
}

__shared15::__shared15(const __shared15 & that) {
    OSSTRY {
	do_copy(that, &__shared15_copy);
    } OSSCLEAN(__shared15)
}

/* Destructor */

__shared15::~__shared15() {
    do_destroy(&__shared15_destroy);
}

/* Operators: assignment, equality, inequality */

__shared15 & __shared15::operator = (const __shared15 & that) {
    do_destroy(&__shared15_destroy);
    do_copy(that, &__shared15_copy);
    return *this;
}

int __shared15::operator == (const __shared15 & that) const {
    return do_compare(that, &__shared15_compare);
}

int __shared15::operator != (const __shared15 & that) const {
    return !do_compare(that, &__shared15_compare);
}

/* Locate ("At" etc) methods */

__shared15::component *__shared15::at(OssIndex pos) {
    return &((__shared15_member *)pos)->value;
}

const __shared15::component *__shared15::at(OssIndex pos) const {
    return &((__shared15_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared15::prepend(const component & val) {
    __shared15_member *newrec = new __shared15_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared15::prepend(__shared15 *seq) {
    return do_prepend(seq);
}

OssIndex __shared15::insert_after(OssIndex pos, const component & val) {
    __shared15_member *newrec = new __shared15_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared15::insert_after(OssIndex pos, __shared15 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared15::remove_front() {
    __shared15_member *extr = (__shared15_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared15_destroy(extr);
    return 0;
}

int __shared15::remove_after(OssIndex pos) {
    __shared15_member *extr = (__shared15_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared15_destroy(extr);
    return 0;
}

/* Extract methods */

__shared15 *__shared15::extract_after(OssIndex begin, OssIndex end) {
    return (__shared15 *)do_extract_after(begin, end);
}

void *TBSCertificate::operator new(size_t size) {
    return ossNewFunc(size);
}

void TBSCertificate::operator delete(void *ptr) {
    asn1Free(ptr);
}

OSS_INT32 TBSCertificate::get_default_version() {
    return TBSCertificate::default_version;
}

TBSCertificate::TBSCertificate() {
    memset(this, 0, sizeof(TBSCertificate));
}

TBSCertificate::TBSCertificate(const TBSCertificate & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	version_field = that.version_field;
	serialNumber_field = that.serialNumber_field;
	signature_field = that.signature_field;
	issuer_field = that.issuer_field;
	validity_field = that.validity_field;
	subject_field = that.subject_field;
	subjectPublicKeyInfo_field = that.subjectPublicKeyInfo_field;
	issuerUniqueID_field = that.issuerUniqueID_field;
	subjectUniqueID_field = that.subjectUniqueID_field;
	extensions_field = that.extensions_field;
    } OSSCLEAN(TBSCertificate)
}

TBSCertificate::TBSCertificate(version version_val, serialNumber serialNumber_val, 
    const signature & signature_val, const issuer & issuer_val, const validity & validity_val, 
    const subject & subject_val, const subjectPublicKeyInfo & subjectPublicKeyInfo_val, 
    const issuerUniqueID & issuerUniqueID_val, const subjectUniqueID & subjectUniqueID_val, 
    const extensions & extensions_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	version_field = version_val;
	serialNumber_field = serialNumber_val;
	signature_field = signature_val;
	issuer_field = issuer_val;
	validity_field = validity_val;
	subject_field = subject_val;
	subjectPublicKeyInfo_field = subjectPublicKeyInfo_val;
	issuerUniqueID_field = issuerUniqueID_val;
	subjectUniqueID_field = subjectUniqueID_val;
	extensions_field = extensions_val;
    } OSSCLEAN(TBSCertificate)
}

TBSCertificate::TBSCertificate(serialNumber serialNumber_val, const signature & signature_val, 
    const issuer & issuer_val, const validity & validity_val, const subject & subject_val, 
    const subjectPublicKeyInfo & subjectPublicKeyInfo_val) {
    OSSTRY {
	bit_mask = 0;
	serialNumber_field = serialNumber_val;
	signature_field = signature_val;
	issuer_field = issuer_val;
	validity_field = validity_val;
	subject_field = subject_val;
	subjectPublicKeyInfo_field = subjectPublicKeyInfo_val;
    } OSSCLEAN(TBSCertificate)
}

TBSCertificate & TBSCertificate::operator = (const TBSCertificate & that) {
    if (this == &that)
	return *this;
    this->~TBSCertificate();
    bit_mask = that.bit_mask;
    version_field = that.version_field;
    serialNumber_field = that.serialNumber_field;
    signature_field = that.signature_field;
    issuer_field = that.issuer_field;
    validity_field = that.validity_field;
    subject_field = that.subject_field;
    subjectPublicKeyInfo_field = that.subjectPublicKeyInfo_field;
    issuerUniqueID_field = that.issuerUniqueID_field;
    subjectUniqueID_field = that.subjectUniqueID_field;
    extensions_field = that.extensions_field;
    return *this;
}

int TBSCertificate::operator == (const TBSCertificate & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (version_field != that.version_field)
	    return 0;
    }
    if (serialNumber_field != that.serialNumber_field)
	return 0;
    if (signature_field != that.signature_field)
	return 0;
    if (issuer_field != that.issuer_field)
	return 0;
    if (validity_field != that.validity_field)
	return 0;
    if (subject_field != that.subject_field)
	return 0;
    if (subjectPublicKeyInfo_field != that.subjectPublicKeyInfo_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (issuerUniqueID_field != that.issuerUniqueID_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (subjectUniqueID_field != that.subjectUniqueID_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (extensions_field != that.extensions_field)
	    return 0;
    }
    return 1;
}

int TBSCertificate::operator != (const TBSCertificate & that) const {
    return !(operator ==(that));
}

TBSCertificate::version *TBSCertificate::get_version() {
    if (bit_mask & 0x80000000)
	return &version_field;
    else
	return 0;
}

const TBSCertificate::version *TBSCertificate::get_version() const {
    if (bit_mask & 0x80000000)
	return &version_field;
    else
	return 0;
}

void TBSCertificate::set_version(version version_val) {
    bit_mask |= 0x80000000;
    version_field = version_val;
}

int TBSCertificate::version_is_default() const {
    return !(bit_mask & 0x80000000);
}

void TBSCertificate::set_default_version() {
    bit_mask &= ~0x80000000;
}

TBSCertificate::serialNumber & TBSCertificate::get_serialNumber() {
    return serialNumber_field;
}

TBSCertificate::serialNumber TBSCertificate::get_serialNumber() const {
    return serialNumber_field;
}

void TBSCertificate::set_serialNumber(serialNumber serialNumber_val) {
    serialNumber_field = serialNumber_val;
}

TBSCertificate::signature & TBSCertificate::get_signature() {
    return signature_field;
}

const TBSCertificate::signature & TBSCertificate::get_signature() const {
    return signature_field;
}

void TBSCertificate::set_signature(const signature & signature_val) {
    signature_field = signature_val;
}

TBSCertificate::issuer & TBSCertificate::get_issuer() {
    return issuer_field;
}

const TBSCertificate::issuer & TBSCertificate::get_issuer() const {
    return issuer_field;
}

void TBSCertificate::set_issuer(const issuer & issuer_val) {
    issuer_field = issuer_val;
}

TBSCertificate::validity & TBSCertificate::get_validity() {
    return validity_field;
}

const TBSCertificate::validity & TBSCertificate::get_validity() const {
    return validity_field;
}

void TBSCertificate::set_validity(const validity & validity_val) {
    validity_field = validity_val;
}

TBSCertificate::subject & TBSCertificate::get_subject() {
    return subject_field;
}

const TBSCertificate::subject & TBSCertificate::get_subject() const {
    return subject_field;
}

void TBSCertificate::set_subject(const subject & subject_val) {
    subject_field = subject_val;
}

TBSCertificate::subjectPublicKeyInfo & TBSCertificate::get_subjectPublicKeyInfo() {
    return subjectPublicKeyInfo_field;
}

const TBSCertificate::subjectPublicKeyInfo & TBSCertificate::get_subjectPublicKeyInfo() const {
    return subjectPublicKeyInfo_field;
}

void TBSCertificate::set_subjectPublicKeyInfo(const subjectPublicKeyInfo & subjectPublicKeyInfo_val) {
    subjectPublicKeyInfo_field = subjectPublicKeyInfo_val;
}

TBSCertificate::issuerUniqueID *TBSCertificate::get_issuerUniqueID() {
    if (bit_mask & 0x40000000)
	return &issuerUniqueID_field;
    else
	return 0;
}

const TBSCertificate::issuerUniqueID *TBSCertificate::get_issuerUniqueID() const {
    if (bit_mask & 0x40000000)
	return &issuerUniqueID_field;
    else
	return 0;
}

void TBSCertificate::set_issuerUniqueID(const issuerUniqueID & issuerUniqueID_val) {
    bit_mask |= 0x40000000;
    issuerUniqueID_field = issuerUniqueID_val;
}

int TBSCertificate::issuerUniqueID_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void TBSCertificate::omit_issuerUniqueID() {
    issuerUniqueID_field.~OssBitString();
    bit_mask &= ~0x40000000;
}

TBSCertificate::subjectUniqueID *TBSCertificate::get_subjectUniqueID() {
    if (bit_mask & 0x20000000)
	return &subjectUniqueID_field;
    else
	return 0;
}

const TBSCertificate::subjectUniqueID *TBSCertificate::get_subjectUniqueID() const {
    if (bit_mask & 0x20000000)
	return &subjectUniqueID_field;
    else
	return 0;
}

void TBSCertificate::set_subjectUniqueID(const subjectUniqueID & subjectUniqueID_val) {
    bit_mask |= 0x20000000;
    subjectUniqueID_field = subjectUniqueID_val;
}

int TBSCertificate::subjectUniqueID_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void TBSCertificate::omit_subjectUniqueID() {
    subjectUniqueID_field.~OssBitString();
    bit_mask &= ~0x20000000;
}

TBSCertificate::extensions *TBSCertificate::get_extensions() {
    if (bit_mask & 0x10000000)
	return &extensions_field;
    else
	return 0;
}

const TBSCertificate::extensions *TBSCertificate::get_extensions() const {
    if (bit_mask & 0x10000000)
	return &extensions_field;
    else
	return 0;
}

void TBSCertificate::set_extensions(const extensions & extensions_val) {
    bit_mask |= 0x10000000;
    extensions_field = extensions_val;
}

int TBSCertificate::extensions_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void TBSCertificate::omit_extensions() {
    extensions_field.~__shared15();
    bit_mask &= ~0x10000000;
}

void *Certificate::operator new(size_t size) {
    return ossNewFunc(size);
}

void Certificate::operator delete(void *ptr) {
    asn1Free(ptr);
}

Certificate::Certificate() {
    memset(this, 0, sizeof(Certificate));
}

Certificate::Certificate(const Certificate & that) {
    OSSTRY {
	tbsCertificate_field = that.tbsCertificate_field;
	signatureAlgorithm_field = that.signatureAlgorithm_field;
	signature_field = that.signature_field;
    } OSSCLEAN(Certificate)
}

Certificate::Certificate(const tbsCertificate & tbsCertificate_val, const signatureAlgorithm & signatureAlgorithm_val, 
    const signature & signature_val) {
    OSSTRY {
	tbsCertificate_field = tbsCertificate_val;
	signatureAlgorithm_field = signatureAlgorithm_val;
	signature_field = signature_val;
    } OSSCLEAN(Certificate)
}

Certificate & Certificate::operator = (const Certificate & that) {
    if (this == &that)
	return *this;
    tbsCertificate_field = that.tbsCertificate_field;
    signatureAlgorithm_field = that.signatureAlgorithm_field;
    signature_field = that.signature_field;
    return *this;
}

int Certificate::operator == (const Certificate & that) const {
    if (tbsCertificate_field != that.tbsCertificate_field)
	return 0;
    if (signatureAlgorithm_field != that.signatureAlgorithm_field)
	return 0;
    if (signature_field != that.signature_field)
	return 0;
    return 1;
}

int Certificate::operator != (const Certificate & that) const {
    return !(operator ==(that));
}

Certificate::tbsCertificate & Certificate::get_tbsCertificate() {
    return tbsCertificate_field;
}

const Certificate::tbsCertificate & Certificate::get_tbsCertificate() const {
    return tbsCertificate_field;
}

void Certificate::set_tbsCertificate(const tbsCertificate & tbsCertificate_val) {
    tbsCertificate_field = tbsCertificate_val;
}

Certificate::signatureAlgorithm & Certificate::get_signatureAlgorithm() {
    return signatureAlgorithm_field;
}

const Certificate::signatureAlgorithm & Certificate::get_signatureAlgorithm() const {
    return signatureAlgorithm_field;
}

void Certificate::set_signatureAlgorithm(const signatureAlgorithm & signatureAlgorithm_val) {
    signatureAlgorithm_field = signatureAlgorithm_val;
}

Certificate::signature & Certificate::get_signature() {
    return signature_field;
}

const Certificate::signature & Certificate::get_signature() const {
    return signature_field;
}

void Certificate::set_signature(const signature & signature_val) {
    signature_field = signature_val;
}

void *Extension::operator new(size_t size) {
    return ossNewFunc(size);
}

void Extension::operator delete(void *ptr) {
    asn1Free(ptr);
}

ossBoolean Extension::get_default_critical() {
    return Extension::default_critical;
}

Extension::Extension() {
    memset(this, 0, sizeof(Extension));
}

Extension::Extension(const Extension & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	extnID_field = that.extnID_field;
	critical_field = that.critical_field;
	extnValue_field = that.extnValue_field;
    } OSSCLEAN(Extension)
}

Extension::Extension(const extnID & extnID_val, critical critical_val, const extnValue & extnValue_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	extnID_field = extnID_val;
	critical_field = critical_val;
	extnValue_field = extnValue_val;
    } OSSCLEAN(Extension)
}

Extension::Extension(const extnID & extnID_val, const extnValue & extnValue_val) {
    OSSTRY {
	bit_mask = 0;
	extnID_field = extnID_val;
	extnValue_field = extnValue_val;
    } OSSCLEAN(Extension)
}

Extension & Extension::operator = (const Extension & that) {
    if (this == &that)
	return *this;
    this->~Extension();
    bit_mask = that.bit_mask;
    extnID_field = that.extnID_field;
    critical_field = that.critical_field;
    extnValue_field = that.extnValue_field;
    return *this;
}

int Extension::operator == (const Extension & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (extnID_field != that.extnID_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (critical_field != that.critical_field)
	    return 0;
    }
    if (extnValue_field != that.extnValue_field)
	return 0;
    return 1;
}

int Extension::operator != (const Extension & that) const {
    return !(operator ==(that));
}

Extension::extnID & Extension::get_extnID() {
    return extnID_field;
}

const Extension::extnID & Extension::get_extnID() const {
    return extnID_field;
}

void Extension::set_extnID(const extnID & extnID_val) {
    extnID_field = extnID_val;
}

Extension::critical *Extension::get_critical() {
    if (bit_mask & 0x80000000)
	return &critical_field;
    else
	return 0;
}

const Extension::critical *Extension::get_critical() const {
    if (bit_mask & 0x80000000)
	return &critical_field;
    else
	return 0;
}

void Extension::set_critical(critical critical_val) {
    bit_mask |= 0x80000000;
    critical_field = critical_val;
}

int Extension::critical_is_default() const {
    return !(bit_mask & 0x80000000);
}

void Extension::set_default_critical() {
    bit_mask &= ~0x80000000;
}

Extension::extnValue & Extension::get_extnValue() {
    return extnValue_field;
}

const Extension::extnValue & Extension::get_extnValue() const {
    return extnValue_field;
}

void Extension::set_extnValue(const extnValue & extnValue_val) {
    extnValue_field = extnValue_val;
}

/* Auxiliary data structures and functions for class __seqof11 */

class __seqof11_member {
public:
    __seqof11_member *next;
    __seqof11::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof11_member();
    __seqof11_member(const __seqof11::component & val);
};

void *__seqof11_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof11_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof11_member::__seqof11_member() {
}

__seqof11_member::__seqof11_member(const __seqof11::component & val) {
    value = val;
}

static void *__seqof11_copy(void *that) {
    return new __seqof11_member(((__seqof11_member *)that)->value);
}

static void __seqof11_destroy(void *that) {
    delete (__seqof11_member *)that;
}

static int __seqof11_compare(void *val1, void *val2) {
    return (((__seqof11_member *)val1)->value == ((__seqof11_member *)val2)->value);
}

/* Constructors */

__seqof11::__seqof11() {
}

__seqof11::__seqof11(const __seqof11 & that) {
    OSSTRY {
	do_copy(that, &__seqof11_copy);
    } OSSCLEAN(__seqof11)
}

/* Destructor */

__seqof11::~__seqof11() {
    do_destroy(&__seqof11_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof11 & __seqof11::operator = (const __seqof11 & that) {
    do_destroy(&__seqof11_destroy);
    do_copy(that, &__seqof11_copy);
    return *this;
}

int __seqof11::operator == (const __seqof11 & that) const {
    return do_compare(that, &__seqof11_compare);
}

int __seqof11::operator != (const __seqof11 & that) const {
    return !do_compare(that, &__seqof11_compare);
}

/* Locate ("At" etc) methods */

__seqof11::component *__seqof11::at(OssIndex pos) {
    return &((__seqof11_member *)pos)->value;
}

const __seqof11::component *__seqof11::at(OssIndex pos) const {
    return &((__seqof11_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof11::prepend(const component & val) {
    __seqof11_member *newrec = new __seqof11_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof11::prepend(__seqof11 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof11::insert_after(OssIndex pos, const component & val) {
    __seqof11_member *newrec = new __seqof11_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof11::insert_after(OssIndex pos, __seqof11 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof11::remove_front() {
    __seqof11_member *extr = (__seqof11_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof11_destroy(extr);
    return 0;
}

int __seqof11::remove_after(OssIndex pos) {
    __seqof11_member *extr = (__seqof11_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof11_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof11 *__seqof11::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof11 *)do_extract_after(begin, end);
}

void *TBSCertList::operator new(size_t size) {
    return ossNewFunc(size);
}

void TBSCertList::operator delete(void *ptr) {
    asn1Free(ptr);
}

TBSCertList::TBSCertList() {
    memset(this, 0, sizeof(TBSCertList));
}

TBSCertList::TBSCertList(const TBSCertList & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	version_field = that.version_field;
	signature_field = that.signature_field;
	issuer_field = that.issuer_field;
	thisUpdate_field = that.thisUpdate_field;
	nextUpdate_field = that.nextUpdate_field;
	revokedCertificates_field = that.revokedCertificates_field;
	crlExtensions_field = that.crlExtensions_field;
    } OSSCLEAN(TBSCertList)
}

TBSCertList::TBSCertList(version version_val, const signature & signature_val, const issuer & issuer_val, 
    const thisUpdate & thisUpdate_val, const nextUpdate & nextUpdate_val, const revokedCertificates & revokedCertificates_val, 
    const crlExtensions & crlExtensions_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	version_field = version_val;
	signature_field = signature_val;
	issuer_field = issuer_val;
	thisUpdate_field = thisUpdate_val;
	nextUpdate_field = nextUpdate_val;
	revokedCertificates_field = revokedCertificates_val;
	crlExtensions_field = crlExtensions_val;
    } OSSCLEAN(TBSCertList)
}

TBSCertList::TBSCertList(const signature & signature_val, const issuer & issuer_val, 
    const thisUpdate & thisUpdate_val) {
    OSSTRY {
	bit_mask = 0;
	signature_field = signature_val;
	issuer_field = issuer_val;
	thisUpdate_field = thisUpdate_val;
    } OSSCLEAN(TBSCertList)
}

TBSCertList & TBSCertList::operator = (const TBSCertList & that) {
    if (this == &that)
	return *this;
    this->~TBSCertList();
    bit_mask = that.bit_mask;
    version_field = that.version_field;
    signature_field = that.signature_field;
    issuer_field = that.issuer_field;
    thisUpdate_field = that.thisUpdate_field;
    nextUpdate_field = that.nextUpdate_field;
    revokedCertificates_field = that.revokedCertificates_field;
    crlExtensions_field = that.crlExtensions_field;
    return *this;
}

int TBSCertList::operator == (const TBSCertList & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (version_field != that.version_field)
	    return 0;
    }
    if (signature_field != that.signature_field)
	return 0;
    if (issuer_field != that.issuer_field)
	return 0;
    if (thisUpdate_field != that.thisUpdate_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (nextUpdate_field != that.nextUpdate_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (revokedCertificates_field != that.revokedCertificates_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (crlExtensions_field != that.crlExtensions_field)
	    return 0;
    }
    return 1;
}

int TBSCertList::operator != (const TBSCertList & that) const {
    return !(operator ==(that));
}

TBSCertList::version *TBSCertList::get_version() {
    if (bit_mask & 0x80000000)
	return &version_field;
    else
	return 0;
}

const TBSCertList::version *TBSCertList::get_version() const {
    if (bit_mask & 0x80000000)
	return &version_field;
    else
	return 0;
}

void TBSCertList::set_version(version version_val) {
    bit_mask |= 0x80000000;
    version_field = version_val;
}

int TBSCertList::version_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void TBSCertList::omit_version() {
    bit_mask &= ~0x80000000;
}

TBSCertList::signature & TBSCertList::get_signature() {
    return signature_field;
}

const TBSCertList::signature & TBSCertList::get_signature() const {
    return signature_field;
}

void TBSCertList::set_signature(const signature & signature_val) {
    signature_field = signature_val;
}

TBSCertList::issuer & TBSCertList::get_issuer() {
    return issuer_field;
}

const TBSCertList::issuer & TBSCertList::get_issuer() const {
    return issuer_field;
}

void TBSCertList::set_issuer(const issuer & issuer_val) {
    issuer_field = issuer_val;
}

TBSCertList::thisUpdate & TBSCertList::get_thisUpdate() {
    return thisUpdate_field;
}

const TBSCertList::thisUpdate & TBSCertList::get_thisUpdate() const {
    return thisUpdate_field;
}

void TBSCertList::set_thisUpdate(const thisUpdate & thisUpdate_val) {
    thisUpdate_field = thisUpdate_val;
}

TBSCertList::nextUpdate *TBSCertList::get_nextUpdate() {
    if (bit_mask & 0x40000000)
	return &nextUpdate_field;
    else
	return 0;
}

const TBSCertList::nextUpdate *TBSCertList::get_nextUpdate() const {
    if (bit_mask & 0x40000000)
	return &nextUpdate_field;
    else
	return 0;
}

void TBSCertList::set_nextUpdate(const nextUpdate & nextUpdate_val) {
    bit_mask |= 0x40000000;
    nextUpdate_field = nextUpdate_val;
}

int TBSCertList::nextUpdate_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void TBSCertList::omit_nextUpdate() {
    nextUpdate_field.~Time();
    bit_mask &= ~0x40000000;
}

TBSCertList::revokedCertificates *TBSCertList::get_revokedCertificates() {
    if (bit_mask & 0x20000000)
	return &revokedCertificates_field;
    else
	return 0;
}

const TBSCertList::revokedCertificates *TBSCertList::get_revokedCertificates() const {
    if (bit_mask & 0x20000000)
	return &revokedCertificates_field;
    else
	return 0;
}

void TBSCertList::set_revokedCertificates(const revokedCertificates & revokedCertificates_val) {
    bit_mask |= 0x20000000;
    revokedCertificates_field = revokedCertificates_val;
}

int TBSCertList::revokedCertificates_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void TBSCertList::omit_revokedCertificates() {
    revokedCertificates_field.~__seqof11();
    bit_mask &= ~0x20000000;
}

TBSCertList::crlExtensions *TBSCertList::get_crlExtensions() {
    if (bit_mask & 0x10000000)
	return &crlExtensions_field;
    else
	return 0;
}

const TBSCertList::crlExtensions *TBSCertList::get_crlExtensions() const {
    if (bit_mask & 0x10000000)
	return &crlExtensions_field;
    else
	return 0;
}

void TBSCertList::set_crlExtensions(const crlExtensions & crlExtensions_val) {
    bit_mask |= 0x10000000;
    crlExtensions_field = crlExtensions_val;
}

int TBSCertList::crlExtensions_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void TBSCertList::omit_crlExtensions() {
    crlExtensions_field.~__shared15();
    bit_mask &= ~0x10000000;
}

void *__seq4::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq4::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq4::__seq4() {
    memset(this, 0, sizeof(__seq4));
}

__seq4::__seq4(const __seq4 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	userCertificate_field = that.userCertificate_field;
	revocationDate_field = that.revocationDate_field;
	crlEntryExtensions_field = that.crlEntryExtensions_field;
    } OSSCLEAN(__seq4)
}

__seq4::__seq4(userCertificate userCertificate_val, const revocationDate & revocationDate_val, 
    const crlEntryExtensions & crlEntryExtensions_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	userCertificate_field = userCertificate_val;
	revocationDate_field = revocationDate_val;
	crlEntryExtensions_field = crlEntryExtensions_val;
    } OSSCLEAN(__seq4)
}

__seq4::__seq4(userCertificate userCertificate_val, const revocationDate & revocationDate_val) {
    OSSTRY {
	bit_mask = 0;
	userCertificate_field = userCertificate_val;
	revocationDate_field = revocationDate_val;
    } OSSCLEAN(__seq4)
}

__seq4 & __seq4::operator = (const __seq4 & that) {
    if (this == &that)
	return *this;
    this->~__seq4();
    bit_mask = that.bit_mask;
    userCertificate_field = that.userCertificate_field;
    revocationDate_field = that.revocationDate_field;
    crlEntryExtensions_field = that.crlEntryExtensions_field;
    return *this;
}

int __seq4::operator == (const __seq4 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (userCertificate_field != that.userCertificate_field)
	return 0;
    if (revocationDate_field != that.revocationDate_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (crlEntryExtensions_field != that.crlEntryExtensions_field)
	    return 0;
    }
    return 1;
}

int __seq4::operator != (const __seq4 & that) const {
    return !(operator ==(that));
}

__seq4::userCertificate & __seq4::get_userCertificate() {
    return userCertificate_field;
}

__seq4::userCertificate __seq4::get_userCertificate() const {
    return userCertificate_field;
}

void __seq4::set_userCertificate(userCertificate userCertificate_val) {
    userCertificate_field = userCertificate_val;
}

__seq4::revocationDate & __seq4::get_revocationDate() {
    return revocationDate_field;
}

const __seq4::revocationDate & __seq4::get_revocationDate() const {
    return revocationDate_field;
}

void __seq4::set_revocationDate(const revocationDate & revocationDate_val) {
    revocationDate_field = revocationDate_val;
}

__seq4::crlEntryExtensions *__seq4::get_crlEntryExtensions() {
    if (bit_mask & 0x80000000)
	return &crlEntryExtensions_field;
    else
	return 0;
}

const __seq4::crlEntryExtensions *__seq4::get_crlEntryExtensions() const {
    if (bit_mask & 0x80000000)
	return &crlEntryExtensions_field;
    else
	return 0;
}

void __seq4::set_crlEntryExtensions(const crlEntryExtensions & crlEntryExtensions_val) {
    bit_mask |= 0x80000000;
    crlEntryExtensions_field = crlEntryExtensions_val;
}

int __seq4::crlEntryExtensions_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq4::omit_crlEntryExtensions() {
    crlEntryExtensions_field.~__shared15();
    bit_mask &= ~0x80000000;
}

void *CertificateList::operator new(size_t size) {
    return ossNewFunc(size);
}

void CertificateList::operator delete(void *ptr) {
    asn1Free(ptr);
}

CertificateList::CertificateList() {
    memset(this, 0, sizeof(CertificateList));
}

CertificateList::CertificateList(const CertificateList & that) {
    OSSTRY {
	tbsCertList_field = that.tbsCertList_field;
	signatureAlgorithm_field = that.signatureAlgorithm_field;
	signature_field = that.signature_field;
    } OSSCLEAN(CertificateList)
}

CertificateList::CertificateList(const tbsCertList & tbsCertList_val, const signatureAlgorithm & signatureAlgorithm_val, 
    const signature & signature_val) {
    OSSTRY {
	tbsCertList_field = tbsCertList_val;
	signatureAlgorithm_field = signatureAlgorithm_val;
	signature_field = signature_val;
    } OSSCLEAN(CertificateList)
}

CertificateList & CertificateList::operator = (const CertificateList & that) {
    if (this == &that)
	return *this;
    tbsCertList_field = that.tbsCertList_field;
    signatureAlgorithm_field = that.signatureAlgorithm_field;
    signature_field = that.signature_field;
    return *this;
}

int CertificateList::operator == (const CertificateList & that) const {
    if (tbsCertList_field != that.tbsCertList_field)
	return 0;
    if (signatureAlgorithm_field != that.signatureAlgorithm_field)
	return 0;
    if (signature_field != that.signature_field)
	return 0;
    return 1;
}

int CertificateList::operator != (const CertificateList & that) const {
    return !(operator ==(that));
}

CertificateList::tbsCertList & CertificateList::get_tbsCertList() {
    return tbsCertList_field;
}

const CertificateList::tbsCertList & CertificateList::get_tbsCertList() const {
    return tbsCertList_field;
}

void CertificateList::set_tbsCertList(const tbsCertList & tbsCertList_val) {
    tbsCertList_field = tbsCertList_val;
}

CertificateList::signatureAlgorithm & CertificateList::get_signatureAlgorithm() {
    return signatureAlgorithm_field;
}

const CertificateList::signatureAlgorithm & CertificateList::get_signatureAlgorithm() const {
    return signatureAlgorithm_field;
}

void CertificateList::set_signatureAlgorithm(const signatureAlgorithm & signatureAlgorithm_val) {
    signatureAlgorithm_field = signatureAlgorithm_val;
}

CertificateList::signature & CertificateList::get_signature() {
    return signature_field;
}

const CertificateList::signature & CertificateList::get_signature() const {
    return signature_field;
}

void CertificateList::set_signature(const signature & signature_val) {
    signature_field = signature_val;
}

__shared16::__shared16() {
    memset(this, 0, sizeof(__shared16));
}

__shared16::__shared16(const __shared16 & that) {
    memset(this, 0, sizeof(__shared16));
    operator =(that);
}

__shared16::~__shared16() {
    cleanup();
}

__shared16 & __shared16::operator = (const __shared16 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case x121_dcc_code_chosen:
	    *(x121_dcc_code *)&x121_dcc_code_field = *(x121_dcc_code *)&that.x121_dcc_code_field;
	    break;
	case iso_3166_alpha2_code_chosen:
	    *(iso_3166_alpha2_code *)&iso_3166_alpha2_code_field = *(iso_3166_alpha2_code *)&that.iso_3166_alpha2_code_field;
	    break;
    }
    return *this;
}

int __shared16::operator == (const __shared16 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case x121_dcc_code_chosen:
	    return *(x121_dcc_code *)&x121_dcc_code_field == *(x121_dcc_code *)&that.x121_dcc_code_field;
	case iso_3166_alpha2_code_chosen:
	    return *(iso_3166_alpha2_code *)&iso_3166_alpha2_code_field == *(iso_3166_alpha2_code *)&that.iso_3166_alpha2_code_field;
    }

    return 1;
}

int __shared16::operator != (const __shared16 & that) const {
    return !(operator ==(that));
}

__shared16::x121_dcc_code *__shared16::get_x121_dcc_code() {
    if (_choice == x121_dcc_code_chosen)
	return (x121_dcc_code *)&x121_dcc_code_field;
    else
	return 0;
}

const __shared16::x121_dcc_code *__shared16::get_x121_dcc_code() const {
    if (_choice == x121_dcc_code_chosen)
	return (const x121_dcc_code *)&x121_dcc_code_field;
    else
	return 0;
}

void __shared16::set_x121_dcc_code(const x121_dcc_code & x121_dcc_code_val) {
    cleanup();
    *(x121_dcc_code *)&x121_dcc_code_field = x121_dcc_code_val;
    _choice = x121_dcc_code_chosen;
}

__shared16::iso_3166_alpha2_code *__shared16::get_iso_3166_alpha2_code() {
    if (_choice == iso_3166_alpha2_code_chosen)
	return (iso_3166_alpha2_code *)&iso_3166_alpha2_code_field;
    else
	return 0;
}

const __shared16::iso_3166_alpha2_code *__shared16::get_iso_3166_alpha2_code() const {
    if (_choice == iso_3166_alpha2_code_chosen)
	return (const iso_3166_alpha2_code *)&iso_3166_alpha2_code_field;
    else
	return 0;
}

void __shared16::set_iso_3166_alpha2_code(const iso_3166_alpha2_code & iso_3166_alpha2_code_val) {
    cleanup();
    *(iso_3166_alpha2_code *)&iso_3166_alpha2_code_field = iso_3166_alpha2_code_val;
    _choice = iso_3166_alpha2_code_chosen;
}

void __shared16::cleanup() {
    switch (_choice) {
	case x121_dcc_code_chosen:
	    ((x121_dcc_code *)&x121_dcc_code_field)->~OssString();
	    break;
	case iso_3166_alpha2_code_chosen:
	    ((iso_3166_alpha2_code *)&iso_3166_alpha2_code_field)->~OssString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

__shared17::__shared17() {
    memset(this, 0, sizeof(__shared17));
}

__shared17::__shared17(const __shared17 & that) {
    memset(this, 0, sizeof(__shared17));
    operator =(that);
}

__shared17::~__shared17() {
    cleanup();
}

__shared17 & __shared17::operator = (const __shared17 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case numeric_chosen:
	    *(numeric *)&numeric_field = *(numeric *)&that.numeric_field;
	    break;
	case printable_chosen:
	    *(printable *)&printable_field = *(printable *)&that.printable_field;
	    break;
    }
    return *this;
}

int __shared17::operator == (const __shared17 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case numeric_chosen:
	    return *(numeric *)&numeric_field == *(numeric *)&that.numeric_field;
	case printable_chosen:
	    return *(printable *)&printable_field == *(printable *)&that.printable_field;
    }

    return 1;
}

int __shared17::operator != (const __shared17 & that) const {
    return !(operator ==(that));
}

__shared17::numeric *__shared17::get_numeric() {
    if (_choice == numeric_chosen)
	return (numeric *)&numeric_field;
    else
	return 0;
}

const __shared17::numeric *__shared17::get_numeric() const {
    if (_choice == numeric_chosen)
	return (const numeric *)&numeric_field;
    else
	return 0;
}

void __shared17::set_numeric(const numeric & numeric_val) {
    cleanup();
    *(numeric *)&numeric_field = numeric_val;
    _choice = numeric_chosen;
}

__shared17::printable *__shared17::get_printable() {
    if (_choice == printable_chosen)
	return (printable *)&printable_field;
    else
	return 0;
}

const __shared17::printable *__shared17::get_printable() const {
    if (_choice == printable_chosen)
	return (const printable *)&printable_field;
    else
	return 0;
}

void __shared17::set_printable(const printable & printable_val) {
    cleanup();
    *(printable *)&printable_field = printable_val;
    _choice = printable_chosen;
}

void __shared17::cleanup() {
    switch (_choice) {
	case numeric_chosen:
	    ((numeric *)&numeric_field)->~OssString();
	    break;
	case printable_chosen:
	    ((printable *)&printable_field)->~OssString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *__shared18::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared18::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared18::__shared18() {
    memset(this, 0, sizeof(__shared18));
}

__shared18::__shared18(const __shared18 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	surname_field = that.surname_field;
	given_name_field = that.given_name_field;
	initials_field = that.initials_field;
	generation_qualifier_field = that.generation_qualifier_field;
    } OSSCLEAN(__shared18)
}

__shared18::__shared18(const surname & surname_val, const given_name & given_name_val, 
    const initials & initials_val, const generation_qualifier & generation_qualifier_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	surname_field = surname_val;
	given_name_field = given_name_val;
	initials_field = initials_val;
	generation_qualifier_field = generation_qualifier_val;
    } OSSCLEAN(__shared18)
}

__shared18::__shared18(const surname & surname_val) {
    OSSTRY {
	bit_mask = 0;
	surname_field = surname_val;
    } OSSCLEAN(__shared18)
}

__shared18 & __shared18::operator = (const __shared18 & that) {
    if (this == &that)
	return *this;
    this->~__shared18();
    bit_mask = that.bit_mask;
    surname_field = that.surname_field;
    given_name_field = that.given_name_field;
    initials_field = that.initials_field;
    generation_qualifier_field = that.generation_qualifier_field;
    return *this;
}

int __shared18::operator == (const __shared18 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (surname_field != that.surname_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (given_name_field != that.given_name_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (initials_field != that.initials_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (generation_qualifier_field != that.generation_qualifier_field)
	    return 0;
    }
    return 1;
}

int __shared18::operator != (const __shared18 & that) const {
    return !(operator ==(that));
}

__shared18::surname & __shared18::get_surname() {
    return surname_field;
}

const __shared18::surname & __shared18::get_surname() const {
    return surname_field;
}

void __shared18::set_surname(const surname & surname_val) {
    surname_field = surname_val;
}

__shared18::given_name *__shared18::get_given_name() {
    if (bit_mask & 0x80000000)
	return &given_name_field;
    else
	return 0;
}

const __shared18::given_name *__shared18::get_given_name() const {
    if (bit_mask & 0x80000000)
	return &given_name_field;
    else
	return 0;
}

void __shared18::set_given_name(const given_name & given_name_val) {
    bit_mask |= 0x80000000;
    given_name_field = given_name_val;
}

int __shared18::given_name_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared18::omit_given_name() {
    given_name_field.~OssString();
    bit_mask &= ~0x80000000;
}

__shared18::initials *__shared18::get_initials() {
    if (bit_mask & 0x40000000)
	return &initials_field;
    else
	return 0;
}

const __shared18::initials *__shared18::get_initials() const {
    if (bit_mask & 0x40000000)
	return &initials_field;
    else
	return 0;
}

void __shared18::set_initials(const initials & initials_val) {
    bit_mask |= 0x40000000;
    initials_field = initials_val;
}

int __shared18::initials_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __shared18::omit_initials() {
    initials_field.~OssString();
    bit_mask &= ~0x40000000;
}

__shared18::generation_qualifier *__shared18::get_generation_qualifier() {
    if (bit_mask & 0x20000000)
	return &generation_qualifier_field;
    else
	return 0;
}

const __shared18::generation_qualifier *__shared18::get_generation_qualifier() const {
    if (bit_mask & 0x20000000)
	return &generation_qualifier_field;
    else
	return 0;
}

void __shared18::set_generation_qualifier(const generation_qualifier & generation_qualifier_val) {
    bit_mask |= 0x20000000;
    generation_qualifier_field = generation_qualifier_val;
}

int __shared18::generation_qualifier_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void __shared18::omit_generation_qualifier() {
    generation_qualifier_field.~OssString();
    bit_mask &= ~0x20000000;
}

void *BuiltInStandardAttributes::operator new(size_t size) {
    return ossNewFunc(size);
}

void BuiltInStandardAttributes::operator delete(void *ptr) {
    asn1Free(ptr);
}

BuiltInStandardAttributes::BuiltInStandardAttributes() {
    memset(this, 0, sizeof(BuiltInStandardAttributes));
}

BuiltInStandardAttributes::BuiltInStandardAttributes(const BuiltInStandardAttributes & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	country_name_field = that.country_name_field;
	administration_domain_name_field = that.administration_domain_name_field;
	network_address_field = that.network_address_field;
	terminal_identifier_field = that.terminal_identifier_field;
	private_domain_name_field = that.private_domain_name_field;
	organization_name_field = that.organization_name_field;
	numeric_user_identifier_field = that.numeric_user_identifier_field;
	personal_name_field = that.personal_name_field;
	organizational_unit_names_field = that.organizational_unit_names_field;
    } OSSCLEAN(BuiltInStandardAttributes)
}

BuiltInStandardAttributes::BuiltInStandardAttributes(const country_name & country_name_val, 
    const administration_domain_name & administration_domain_name_val, const network_address & network_address_val, 
    const terminal_identifier & terminal_identifier_val, const private_domain_name & private_domain_name_val, 
    const organization_name & organization_name_val, const numeric_user_identifier & numeric_user_identifier_val, 
    const personal_name & personal_name_val, const organizational_unit_names & organizational_unit_names_val) {
    OSSTRY {
	bit_mask = 0xff800000;
	country_name_field = country_name_val;
	administration_domain_name_field = administration_domain_name_val;
	network_address_field = network_address_val;
	terminal_identifier_field = terminal_identifier_val;
	private_domain_name_field = private_domain_name_val;
	organization_name_field = organization_name_val;
	numeric_user_identifier_field = numeric_user_identifier_val;
	personal_name_field = personal_name_val;
	organizational_unit_names_field = organizational_unit_names_val;
    } OSSCLEAN(BuiltInStandardAttributes)
}

BuiltInStandardAttributes & BuiltInStandardAttributes::operator = (const BuiltInStandardAttributes & that) {
    if (this == &that)
	return *this;
    this->~BuiltInStandardAttributes();
    bit_mask = that.bit_mask;
    country_name_field = that.country_name_field;
    administration_domain_name_field = that.administration_domain_name_field;
    network_address_field = that.network_address_field;
    terminal_identifier_field = that.terminal_identifier_field;
    private_domain_name_field = that.private_domain_name_field;
    organization_name_field = that.organization_name_field;
    numeric_user_identifier_field = that.numeric_user_identifier_field;
    personal_name_field = that.personal_name_field;
    organizational_unit_names_field = that.organizational_unit_names_field;
    return *this;
}

int BuiltInStandardAttributes::operator == (const BuiltInStandardAttributes & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (country_name_field != that.country_name_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (administration_domain_name_field != that.administration_domain_name_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (network_address_field != that.network_address_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (terminal_identifier_field != that.terminal_identifier_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (private_domain_name_field != that.private_domain_name_field)
	    return 0;
    }
    if (bit_mask & 0x4000000) {
	if (organization_name_field != that.organization_name_field)
	    return 0;
    }
    if (bit_mask & 0x2000000) {
	if (numeric_user_identifier_field != that.numeric_user_identifier_field)
	    return 0;
    }
    if (bit_mask & 0x1000000) {
	if (personal_name_field != that.personal_name_field)
	    return 0;
    }
    if (bit_mask & 0x800000) {
	if (organizational_unit_names_field != that.organizational_unit_names_field)
	    return 0;
    }
    return 1;
}

int BuiltInStandardAttributes::operator != (const BuiltInStandardAttributes & that) const {
    return !(operator ==(that));
}

BuiltInStandardAttributes::country_name *BuiltInStandardAttributes::get_country_name() {
    if (bit_mask & 0x80000000)
	return &country_name_field;
    else
	return 0;
}

const BuiltInStandardAttributes::country_name *BuiltInStandardAttributes::get_country_name() const {
    if (bit_mask & 0x80000000)
	return &country_name_field;
    else
	return 0;
}

void BuiltInStandardAttributes::set_country_name(const country_name & country_name_val) {
    bit_mask |= 0x80000000;
    country_name_field = country_name_val;
}

int BuiltInStandardAttributes::country_name_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void BuiltInStandardAttributes::omit_country_name() {
    country_name_field.~__shared16();
    bit_mask &= ~0x80000000;
}

BuiltInStandardAttributes::administration_domain_name *BuiltInStandardAttributes::get_administration_domain_name() {
    if (bit_mask & 0x40000000)
	return &administration_domain_name_field;
    else
	return 0;
}

const BuiltInStandardAttributes::administration_domain_name *BuiltInStandardAttributes::get_administration_domain_name() const {
    if (bit_mask & 0x40000000)
	return &administration_domain_name_field;
    else
	return 0;
}

void BuiltInStandardAttributes::set_administration_domain_name(const administration_domain_name & administration_domain_name_val) {
    bit_mask |= 0x40000000;
    administration_domain_name_field = administration_domain_name_val;
}

int BuiltInStandardAttributes::administration_domain_name_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void BuiltInStandardAttributes::omit_administration_domain_name() {
    administration_domain_name_field.~__shared17();
    bit_mask &= ~0x40000000;
}

BuiltInStandardAttributes::network_address *BuiltInStandardAttributes::get_network_address() {
    if (bit_mask & 0x20000000)
	return &network_address_field;
    else
	return 0;
}

const BuiltInStandardAttributes::network_address *BuiltInStandardAttributes::get_network_address() const {
    if (bit_mask & 0x20000000)
	return &network_address_field;
    else
	return 0;
}

void BuiltInStandardAttributes::set_network_address(const network_address & network_address_val) {
    bit_mask |= 0x20000000;
    network_address_field = network_address_val;
}

int BuiltInStandardAttributes::network_address_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void BuiltInStandardAttributes::omit_network_address() {
    network_address_field.~OssString();
    bit_mask &= ~0x20000000;
}

BuiltInStandardAttributes::terminal_identifier *BuiltInStandardAttributes::get_terminal_identifier() {
    if (bit_mask & 0x10000000)
	return &terminal_identifier_field;
    else
	return 0;
}

const BuiltInStandardAttributes::terminal_identifier *BuiltInStandardAttributes::get_terminal_identifier() const {
    if (bit_mask & 0x10000000)
	return &terminal_identifier_field;
    else
	return 0;
}

void BuiltInStandardAttributes::set_terminal_identifier(const terminal_identifier & terminal_identifier_val) {
    bit_mask |= 0x10000000;
    terminal_identifier_field = terminal_identifier_val;
}

int BuiltInStandardAttributes::terminal_identifier_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void BuiltInStandardAttributes::omit_terminal_identifier() {
    terminal_identifier_field.~OssString();
    bit_mask &= ~0x10000000;
}

BuiltInStandardAttributes::private_domain_name *BuiltInStandardAttributes::get_private_domain_name() {
    if (bit_mask & 0x8000000)
	return &private_domain_name_field;
    else
	return 0;
}

const BuiltInStandardAttributes::private_domain_name *BuiltInStandardAttributes::get_private_domain_name() const {
    if (bit_mask & 0x8000000)
	return &private_domain_name_field;
    else
	return 0;
}

void BuiltInStandardAttributes::set_private_domain_name(const private_domain_name & private_domain_name_val) {
    bit_mask |= 0x8000000;
    private_domain_name_field = private_domain_name_val;
}

int BuiltInStandardAttributes::private_domain_name_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void BuiltInStandardAttributes::omit_private_domain_name() {
    private_domain_name_field.~__shared17();
    bit_mask &= ~0x8000000;
}

BuiltInStandardAttributes::organization_name *BuiltInStandardAttributes::get_organization_name() {
    if (bit_mask & 0x4000000)
	return &organization_name_field;
    else
	return 0;
}

const BuiltInStandardAttributes::organization_name *BuiltInStandardAttributes::get_organization_name() const {
    if (bit_mask & 0x4000000)
	return &organization_name_field;
    else
	return 0;
}

void BuiltInStandardAttributes::set_organization_name(const organization_name & organization_name_val) {
    bit_mask |= 0x4000000;
    organization_name_field = organization_name_val;
}

int BuiltInStandardAttributes::organization_name_is_present() const {
    return !!(bit_mask & 0x4000000);
}

void BuiltInStandardAttributes::omit_organization_name() {
    organization_name_field.~OssString();
    bit_mask &= ~0x4000000;
}

BuiltInStandardAttributes::numeric_user_identifier *BuiltInStandardAttributes::get_numeric_user_identifier() {
    if (bit_mask & 0x2000000)
	return &numeric_user_identifier_field;
    else
	return 0;
}

const BuiltInStandardAttributes::numeric_user_identifier *BuiltInStandardAttributes::get_numeric_user_identifier() const {
    if (bit_mask & 0x2000000)
	return &numeric_user_identifier_field;
    else
	return 0;
}

void BuiltInStandardAttributes::set_numeric_user_identifier(const numeric_user_identifier & numeric_user_identifier_val) {
    bit_mask |= 0x2000000;
    numeric_user_identifier_field = numeric_user_identifier_val;
}

int BuiltInStandardAttributes::numeric_user_identifier_is_present() const {
    return !!(bit_mask & 0x2000000);
}

void BuiltInStandardAttributes::omit_numeric_user_identifier() {
    numeric_user_identifier_field.~OssString();
    bit_mask &= ~0x2000000;
}

BuiltInStandardAttributes::personal_name *BuiltInStandardAttributes::get_personal_name() {
    if (bit_mask & 0x1000000)
	return &personal_name_field;
    else
	return 0;
}

const BuiltInStandardAttributes::personal_name *BuiltInStandardAttributes::get_personal_name() const {
    if (bit_mask & 0x1000000)
	return &personal_name_field;
    else
	return 0;
}

void BuiltInStandardAttributes::set_personal_name(const personal_name & personal_name_val) {
    bit_mask |= 0x1000000;
    personal_name_field = personal_name_val;
}

int BuiltInStandardAttributes::personal_name_is_present() const {
    return !!(bit_mask & 0x1000000);
}

void BuiltInStandardAttributes::omit_personal_name() {
    personal_name_field.~__shared18();
    bit_mask &= ~0x1000000;
}

BuiltInStandardAttributes::organizational_unit_names *BuiltInStandardAttributes::get_organizational_unit_names() {
    if (bit_mask & 0x800000)
	return &organizational_unit_names_field;
    else
	return 0;
}

const BuiltInStandardAttributes::organizational_unit_names *BuiltInStandardAttributes::get_organizational_unit_names() const {
    if (bit_mask & 0x800000)
	return &organizational_unit_names_field;
    else
	return 0;
}

void BuiltInStandardAttributes::set_organizational_unit_names(const organizational_unit_names & organizational_unit_names_val) {
    bit_mask |= 0x800000;
    organizational_unit_names_field = organizational_unit_names_val;
}

int BuiltInStandardAttributes::organizational_unit_names_is_present() const {
    return !!(bit_mask & 0x800000);
}

void BuiltInStandardAttributes::omit_organizational_unit_names() {
    organizational_unit_names_field.~__shared1();
    bit_mask &= ~0x800000;
}

/* Auxiliary data structures and functions for class __shared20 */

class __shared20_member {
public:
    __shared20_member *next;
    __shared20::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared20_member();
    __shared20_member(const __shared20::component & val);
};

void *__shared20_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared20_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared20_member::__shared20_member() {
}

__shared20_member::__shared20_member(const __shared20::component & val) {
    value = val;
}

static void *__shared20_copy(void *that) {
    return new __shared20_member(((__shared20_member *)that)->value);
}

static void __shared20_destroy(void *that) {
    delete (__shared20_member *)that;
}

static int __shared20_compare(void *val1, void *val2) {
    return (((__shared20_member *)val1)->value == ((__shared20_member *)val2)->value);
}

/* Constructors */

__shared20::__shared20() {
}

__shared20::__shared20(const __shared20 & that) {
    OSSTRY {
	do_copy(that, &__shared20_copy);
    } OSSCLEAN(__shared20)
}

/* Destructor */

__shared20::~__shared20() {
    do_destroy(&__shared20_destroy);
}

/* Operators: assignment, equality, inequality */

__shared20 & __shared20::operator = (const __shared20 & that) {
    do_destroy(&__shared20_destroy);
    do_copy(that, &__shared20_copy);
    return *this;
}

int __shared20::operator == (const __shared20 & that) const {
    return do_compare(that, &__shared20_compare);
}

int __shared20::operator != (const __shared20 & that) const {
    return !do_compare(that, &__shared20_compare);
}

/* Locate ("At" etc) methods */

__shared20::component *__shared20::at(OssIndex pos) {
    return &((__shared20_member *)pos)->value;
}

const __shared20::component *__shared20::at(OssIndex pos) const {
    return &((__shared20_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared20::prepend(const component & val) {
    __shared20_member *newrec = new __shared20_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared20::prepend(__shared20 *seq) {
    return do_prepend(seq);
}

OssIndex __shared20::insert_after(OssIndex pos, const component & val) {
    __shared20_member *newrec = new __shared20_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared20::insert_after(OssIndex pos, __shared20 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared20::remove_front() {
    __shared20_member *extr = (__shared20_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared20_destroy(extr);
    return 0;
}

int __shared20::remove_after(OssIndex pos) {
    __shared20_member *extr = (__shared20_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared20_destroy(extr);
    return 0;
}

/* Extract methods */

__shared20 *__shared20::extract_after(OssIndex begin, OssIndex end) {
    return (__shared20 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class ExtensionAttributes */

class ExtensionAttributes_member {
public:
    ExtensionAttributes_member *next;
    ExtensionAttributes::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    ExtensionAttributes_member();
    ExtensionAttributes_member(const ExtensionAttributes::component & val);
};

void *ExtensionAttributes_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void ExtensionAttributes_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

ExtensionAttributes_member::ExtensionAttributes_member() {
}

ExtensionAttributes_member::ExtensionAttributes_member(const ExtensionAttributes::component & val) {
    value = val;
}

static void *ExtensionAttributes_copy(void *that) {
    return new ExtensionAttributes_member(((ExtensionAttributes_member *)that)->value);
}

static void ExtensionAttributes_destroy(void *that) {
    delete (ExtensionAttributes_member *)that;
}

static int ExtensionAttributes_compare(void *val1, void *val2) {
    return (((ExtensionAttributes_member *)val1)->value == ((ExtensionAttributes_member *)val2)->value);
}

/* Constructors */

ExtensionAttributes::ExtensionAttributes() {
}

ExtensionAttributes::ExtensionAttributes(const ExtensionAttributes & that) {
    OSSTRY {
	do_copy(that, &ExtensionAttributes_copy);
    } OSSCLEAN(ExtensionAttributes)
}

/* Destructor */

ExtensionAttributes::~ExtensionAttributes() {
    do_destroy(&ExtensionAttributes_destroy);
}

/* Operators: assignment, equality, inequality */

ExtensionAttributes & ExtensionAttributes::operator = (const ExtensionAttributes & that) {
    do_destroy(&ExtensionAttributes_destroy);
    do_copy(that, &ExtensionAttributes_copy);
    return *this;
}

int ExtensionAttributes::operator == (const ExtensionAttributes & that) const {
    return do_compare(that, &ExtensionAttributes_compare);
}

int ExtensionAttributes::operator != (const ExtensionAttributes & that) const {
    return !do_compare(that, &ExtensionAttributes_compare);
}

/* Locate ("At" etc) methods */

ExtensionAttributes::component *ExtensionAttributes::at(OssIndex pos) {
    return &((ExtensionAttributes_member *)pos)->value;
}

const ExtensionAttributes::component *ExtensionAttributes::at(OssIndex pos) const {
    return &((ExtensionAttributes_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex ExtensionAttributes::prepend(const component & val) {
    ExtensionAttributes_member *newrec = new ExtensionAttributes_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex ExtensionAttributes::prepend(ExtensionAttributes *seq) {
    return do_prepend(seq);
}

OssIndex ExtensionAttributes::insert_after(OssIndex pos, const component & val) {
    ExtensionAttributes_member *newrec = new ExtensionAttributes_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex ExtensionAttributes::insert_after(OssIndex pos, ExtensionAttributes *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int ExtensionAttributes::remove_front() {
    ExtensionAttributes_member *extr = (ExtensionAttributes_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    ExtensionAttributes_destroy(extr);
    return 0;
}

int ExtensionAttributes::remove_after(OssIndex pos) {
    ExtensionAttributes_member *extr = (ExtensionAttributes_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    ExtensionAttributes_destroy(extr);
    return 0;
}

/* Extract methods */

ExtensionAttributes *ExtensionAttributes::extract_after(OssIndex begin, OssIndex end) {
    return (ExtensionAttributes *)do_extract_after(begin, end);
}

void *ORAddress::operator new(size_t size) {
    return ossNewFunc(size);
}

void ORAddress::operator delete(void *ptr) {
    asn1Free(ptr);
}

ORAddress::ORAddress() {
    memset(this, 0, sizeof(ORAddress));
}

ORAddress::ORAddress(const ORAddress & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	built_in_standard_attributes_field = that.built_in_standard_attributes_field;
	built_in_domain_defined_attributes_field = that.built_in_domain_defined_attributes_field;
	extension_attributes_field = that.extension_attributes_field;
    } OSSCLEAN(ORAddress)
}

ORAddress::ORAddress(const built_in_standard_attributes & built_in_standard_attributes_val, 
    const built_in_domain_defined_attributes & built_in_domain_defined_attributes_val, 
    const extension_attributes & extension_attributes_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	built_in_standard_attributes_field = built_in_standard_attributes_val;
	built_in_domain_defined_attributes_field = built_in_domain_defined_attributes_val;
	extension_attributes_field = extension_attributes_val;
    } OSSCLEAN(ORAddress)
}

ORAddress::ORAddress(const built_in_standard_attributes & built_in_standard_attributes_val) {
    OSSTRY {
	bit_mask = 0;
	built_in_standard_attributes_field = built_in_standard_attributes_val;
    } OSSCLEAN(ORAddress)
}

ORAddress & ORAddress::operator = (const ORAddress & that) {
    if (this == &that)
	return *this;
    this->~ORAddress();
    bit_mask = that.bit_mask;
    built_in_standard_attributes_field = that.built_in_standard_attributes_field;
    built_in_domain_defined_attributes_field = that.built_in_domain_defined_attributes_field;
    extension_attributes_field = that.extension_attributes_field;
    return *this;
}

int ORAddress::operator == (const ORAddress & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (built_in_standard_attributes_field != that.built_in_standard_attributes_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (built_in_domain_defined_attributes_field != that.built_in_domain_defined_attributes_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (extension_attributes_field != that.extension_attributes_field)
	    return 0;
    }
    return 1;
}

int ORAddress::operator != (const ORAddress & that) const {
    return !(operator ==(that));
}

ORAddress::built_in_standard_attributes & ORAddress::get_built_in_standard_attributes() {
    return built_in_standard_attributes_field;
}

const ORAddress::built_in_standard_attributes & ORAddress::get_built_in_standard_attributes() const {
    return built_in_standard_attributes_field;
}

void ORAddress::set_built_in_standard_attributes(const built_in_standard_attributes & built_in_standard_attributes_val) {
    built_in_standard_attributes_field = built_in_standard_attributes_val;
}

ORAddress::built_in_domain_defined_attributes *ORAddress::get_built_in_domain_defined_attributes() {
    if (bit_mask & 0x80000000)
	return &built_in_domain_defined_attributes_field;
    else
	return 0;
}

const ORAddress::built_in_domain_defined_attributes *ORAddress::get_built_in_domain_defined_attributes() const {
    if (bit_mask & 0x80000000)
	return &built_in_domain_defined_attributes_field;
    else
	return 0;
}

void ORAddress::set_built_in_domain_defined_attributes(const built_in_domain_defined_attributes & built_in_domain_defined_attributes_val) {
    bit_mask |= 0x80000000;
    built_in_domain_defined_attributes_field = built_in_domain_defined_attributes_val;
}

int ORAddress::built_in_domain_defined_attributes_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ORAddress::omit_built_in_domain_defined_attributes() {
    built_in_domain_defined_attributes_field.~__shared20();
    bit_mask &= ~0x80000000;
}

ORAddress::extension_attributes *ORAddress::get_extension_attributes() {
    if (bit_mask & 0x40000000)
	return &extension_attributes_field;
    else
	return 0;
}

const ORAddress::extension_attributes *ORAddress::get_extension_attributes() const {
    if (bit_mask & 0x40000000)
	return &extension_attributes_field;
    else
	return 0;
}

void ORAddress::set_extension_attributes(const extension_attributes & extension_attributes_val) {
    bit_mask |= 0x40000000;
    extension_attributes_field = extension_attributes_val;
}

int ORAddress::extension_attributes_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void ORAddress::omit_extension_attributes() {
    extension_attributes_field.~ExtensionAttributes();
    bit_mask &= ~0x40000000;
}

void *__shared19::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared19::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared19::__shared19() {
    memset(this, 0, sizeof(__shared19));
}

__shared19::__shared19(const __shared19 & that) {
    OSSTRY {
	type_field = that.type_field;
	value_field = that.value_field;
    } OSSCLEAN(__shared19)
}

__shared19::__shared19(const type & type_val, const value & value_val) {
    OSSTRY {
	type_field = type_val;
	value_field = value_val;
    } OSSCLEAN(__shared19)
}

__shared19 & __shared19::operator = (const __shared19 & that) {
    if (this == &that)
	return *this;
    type_field = that.type_field;
    value_field = that.value_field;
    return *this;
}

int __shared19::operator == (const __shared19 & that) const {
    if (type_field != that.type_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __shared19::operator != (const __shared19 & that) const {
    return !(operator ==(that));
}

__shared19::type & __shared19::get_type() {
    return type_field;
}

const __shared19::type & __shared19::get_type() const {
    return type_field;
}

void __shared19::set_type(const type & type_val) {
    type_field = type_val;
}

__shared19::value & __shared19::get_value() {
    return value_field;
}

const __shared19::value & __shared19::get_value() const {
    return value_field;
}

void __shared19::set_value(const value & value_val) {
    value_field = value_val;
}

void *ExtensionAttribute::operator new(size_t size) {
    return ossNewFunc(size);
}

void ExtensionAttribute::operator delete(void *ptr) {
    asn1Free(ptr);
}

ExtensionAttribute::ExtensionAttribute() {
    memset(this, 0, sizeof(ExtensionAttribute));
}

ExtensionAttribute::ExtensionAttribute(const ExtensionAttribute & that) {
    OSSTRY {
	extension_attribute_type_field = that.extension_attribute_type_field;
	extension_attribute_value_field = that.extension_attribute_value_field;
    } OSSCLEAN(ExtensionAttribute)
}

ExtensionAttribute::ExtensionAttribute(extension_attribute_type extension_attribute_type_val, 
    const extension_attribute_value & extension_attribute_value_val) {
    OSSTRY {
	extension_attribute_type_field = extension_attribute_type_val;
	extension_attribute_value_field = extension_attribute_value_val;
    } OSSCLEAN(ExtensionAttribute)
}

ExtensionAttribute & ExtensionAttribute::operator = (const ExtensionAttribute & that) {
    if (this == &that)
	return *this;
    extension_attribute_type_field = that.extension_attribute_type_field;
    extension_attribute_value_field = that.extension_attribute_value_field;
    return *this;
}

int ExtensionAttribute::operator == (const ExtensionAttribute & that) const {
    if (extension_attribute_type_field != that.extension_attribute_type_field)
	return 0;
    if (extension_attribute_value_field != that.extension_attribute_value_field)
	return 0;
    return 1;
}

int ExtensionAttribute::operator != (const ExtensionAttribute & that) const {
    return !(operator ==(that));
}

ExtensionAttribute::extension_attribute_type & ExtensionAttribute::get_extension_attribute_type() {
    return extension_attribute_type_field;
}

ExtensionAttribute::extension_attribute_type ExtensionAttribute::get_extension_attribute_type() const {
    return extension_attribute_type_field;
}

void ExtensionAttribute::set_extension_attribute_type(extension_attribute_type extension_attribute_type_val) {
    extension_attribute_type_field = extension_attribute_type_val;
}

ExtensionAttribute::extension_attribute_value & ExtensionAttribute::get_extension_attribute_value() {
    return extension_attribute_value_field;
}

const ExtensionAttribute::extension_attribute_value & ExtensionAttribute::get_extension_attribute_value() const {
    return extension_attribute_value_field;
}

void ExtensionAttribute::set_extension_attribute_value(const extension_attribute_value & extension_attribute_value_val) {
    extension_attribute_value_field = extension_attribute_value_val;
}

PostalCode::PostalCode() {
    memset(this, 0, sizeof(PostalCode));
}

PostalCode::PostalCode(const PostalCode & that) {
    memset(this, 0, sizeof(PostalCode));
    operator =(that);
}

PostalCode::~PostalCode() {
    cleanup();
}

PostalCode & PostalCode::operator = (const PostalCode & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case numeric_code_chosen:
	    *(numeric_code *)&numeric_code_field = *(numeric_code *)&that.numeric_code_field;
	    break;
	case printable_code_chosen:
	    *(printable_code *)&printable_code_field = *(printable_code *)&that.printable_code_field;
	    break;
    }
    return *this;
}

int PostalCode::operator == (const PostalCode & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case numeric_code_chosen:
	    return *(numeric_code *)&numeric_code_field == *(numeric_code *)&that.numeric_code_field;
	case printable_code_chosen:
	    return *(printable_code *)&printable_code_field == *(printable_code *)&that.printable_code_field;
    }

    return 1;
}

int PostalCode::operator != (const PostalCode & that) const {
    return !(operator ==(that));
}

PostalCode::numeric_code *PostalCode::get_numeric_code() {
    if (_choice == numeric_code_chosen)
	return (numeric_code *)&numeric_code_field;
    else
	return 0;
}

const PostalCode::numeric_code *PostalCode::get_numeric_code() const {
    if (_choice == numeric_code_chosen)
	return (const numeric_code *)&numeric_code_field;
    else
	return 0;
}

void PostalCode::set_numeric_code(const numeric_code & numeric_code_val) {
    cleanup();
    *(numeric_code *)&numeric_code_field = numeric_code_val;
    _choice = numeric_code_chosen;
}

PostalCode::printable_code *PostalCode::get_printable_code() {
    if (_choice == printable_code_chosen)
	return (printable_code *)&printable_code_field;
    else
	return 0;
}

const PostalCode::printable_code *PostalCode::get_printable_code() const {
    if (_choice == printable_code_chosen)
	return (const printable_code *)&printable_code_field;
    else
	return 0;
}

void PostalCode::set_printable_code(const printable_code & printable_code_val) {
    cleanup();
    *(printable_code *)&printable_code_field = printable_code_val;
    _choice = printable_code_chosen;
}

void PostalCode::cleanup() {
    switch (_choice) {
	case numeric_code_chosen:
	    ((numeric_code *)&numeric_code_field)->~OssString();
	    break;
	case printable_code_chosen:
	    ((printable_code *)&printable_code_field)->~OssString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *__shared21::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared21::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared21::__shared21() {
    memset(this, 0, sizeof(__shared21));
}

__shared21::__shared21(const __shared21 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	printable_string_field = that.printable_string_field;
	teletex_string_field = that.teletex_string_field;
    } OSSCLEAN(__shared21)
}

__shared21::__shared21(const printable_string & printable_string_val, const teletex_string & teletex_string_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	printable_string_field = printable_string_val;
	teletex_string_field = teletex_string_val;
    } OSSCLEAN(__shared21)
}

__shared21 & __shared21::operator = (const __shared21 & that) {
    if (this == &that)
	return *this;
    this->~__shared21();
    bit_mask = that.bit_mask;
    printable_string_field = that.printable_string_field;
    teletex_string_field = that.teletex_string_field;
    return *this;
}

int __shared21::operator == (const __shared21 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (printable_string_field != that.printable_string_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (teletex_string_field != that.teletex_string_field)
	    return 0;
    }
    return 1;
}

int __shared21::operator != (const __shared21 & that) const {
    return !(operator ==(that));
}

__shared21::printable_string *__shared21::get_printable_string() {
    if (bit_mask & 0x80000000)
	return &printable_string_field;
    else
	return 0;
}

const __shared21::printable_string *__shared21::get_printable_string() const {
    if (bit_mask & 0x80000000)
	return &printable_string_field;
    else
	return 0;
}

void __shared21::set_printable_string(const printable_string & printable_string_val) {
    bit_mask |= 0x80000000;
    printable_string_field = printable_string_val;
}

int __shared21::printable_string_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared21::omit_printable_string() {
    printable_string_field.~OssString();
    bit_mask &= ~0x80000000;
}

__shared21::teletex_string *__shared21::get_teletex_string() {
    if (bit_mask & 0x40000000)
	return &teletex_string_field;
    else
	return 0;
}

const __shared21::teletex_string *__shared21::get_teletex_string() const {
    if (bit_mask & 0x40000000)
	return &teletex_string_field;
    else
	return 0;
}

void __shared21::set_teletex_string(const teletex_string & teletex_string_val) {
    bit_mask |= 0x40000000;
    teletex_string_field = teletex_string_val;
}

int __shared21::teletex_string_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __shared21::omit_teletex_string() {
    teletex_string_field.~OssString();
    bit_mask &= ~0x40000000;
}

void *UnformattedPostalAddress::operator new(size_t size) {
    return ossNewFunc(size);
}

void UnformattedPostalAddress::operator delete(void *ptr) {
    asn1Free(ptr);
}

UnformattedPostalAddress::UnformattedPostalAddress() {
    memset(this, 0, sizeof(UnformattedPostalAddress));
}

UnformattedPostalAddress::UnformattedPostalAddress(const UnformattedPostalAddress & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	printable_address_field = that.printable_address_field;
	teletex_string_field = that.teletex_string_field;
    } OSSCLEAN(UnformattedPostalAddress)
}

UnformattedPostalAddress::UnformattedPostalAddress(const printable_address & printable_address_val, 
    const teletex_string & teletex_string_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	printable_address_field = printable_address_val;
	teletex_string_field = teletex_string_val;
    } OSSCLEAN(UnformattedPostalAddress)
}

UnformattedPostalAddress & UnformattedPostalAddress::operator = (const UnformattedPostalAddress & that) {
    if (this == &that)
	return *this;
    this->~UnformattedPostalAddress();
    bit_mask = that.bit_mask;
    printable_address_field = that.printable_address_field;
    teletex_string_field = that.teletex_string_field;
    return *this;
}

int UnformattedPostalAddress::operator == (const UnformattedPostalAddress & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (printable_address_field != that.printable_address_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (teletex_string_field != that.teletex_string_field)
	    return 0;
    }
    return 1;
}

int UnformattedPostalAddress::operator != (const UnformattedPostalAddress & that) const {
    return !(operator ==(that));
}

UnformattedPostalAddress::printable_address *UnformattedPostalAddress::get_printable_address() {
    if (bit_mask & 0x80000000)
	return &printable_address_field;
    else
	return 0;
}

const UnformattedPostalAddress::printable_address *UnformattedPostalAddress::get_printable_address() const {
    if (bit_mask & 0x80000000)
	return &printable_address_field;
    else
	return 0;
}

void UnformattedPostalAddress::set_printable_address(const printable_address & printable_address_val) {
    bit_mask |= 0x80000000;
    printable_address_field = printable_address_val;
}

int UnformattedPostalAddress::printable_address_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void UnformattedPostalAddress::omit_printable_address() {
    printable_address_field.~__shared1();
    bit_mask &= ~0x80000000;
}

UnformattedPostalAddress::teletex_string *UnformattedPostalAddress::get_teletex_string() {
    if (bit_mask & 0x40000000)
	return &teletex_string_field;
    else
	return 0;
}

const UnformattedPostalAddress::teletex_string *UnformattedPostalAddress::get_teletex_string() const {
    if (bit_mask & 0x40000000)
	return &teletex_string_field;
    else
	return 0;
}

void UnformattedPostalAddress::set_teletex_string(const teletex_string & teletex_string_val) {
    bit_mask |= 0x40000000;
    teletex_string_field = teletex_string_val;
}

int UnformattedPostalAddress::teletex_string_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void UnformattedPostalAddress::omit_teletex_string() {
    teletex_string_field.~OssString();
    bit_mask &= ~0x40000000;
}

void *__seq5::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq5::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq5::__seq5() {
    memset(this, 0, sizeof(__seq5));
}

__seq5::__seq5(const __seq5 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	number_field = that.number_field;
	sub_address_field = that.sub_address_field;
    } OSSCLEAN(__seq5)
}

__seq5::__seq5(const number & number_val, const sub_address & sub_address_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	number_field = number_val;
	sub_address_field = sub_address_val;
    } OSSCLEAN(__seq5)
}

__seq5::__seq5(const number & number_val) {
    OSSTRY {
	bit_mask = 0;
	number_field = number_val;
    } OSSCLEAN(__seq5)
}

__seq5 & __seq5::operator = (const __seq5 & that) {
    if (this == &that)
	return *this;
    this->~__seq5();
    bit_mask = that.bit_mask;
    number_field = that.number_field;
    sub_address_field = that.sub_address_field;
    return *this;
}

int __seq5::operator == (const __seq5 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (number_field != that.number_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (sub_address_field != that.sub_address_field)
	    return 0;
    }
    return 1;
}

int __seq5::operator != (const __seq5 & that) const {
    return !(operator ==(that));
}

__seq5::number & __seq5::get_number() {
    return number_field;
}

const __seq5::number & __seq5::get_number() const {
    return number_field;
}

void __seq5::set_number(const number & number_val) {
    number_field = number_val;
}

__seq5::sub_address *__seq5::get_sub_address() {
    if (bit_mask & 0x80000000)
	return &sub_address_field;
    else
	return 0;
}

const __seq5::sub_address *__seq5::get_sub_address() const {
    if (bit_mask & 0x80000000)
	return &sub_address_field;
    else
	return 0;
}

void __seq5::set_sub_address(const sub_address & sub_address_val) {
    bit_mask |= 0x80000000;
    sub_address_field = sub_address_val;
}

int __seq5::sub_address_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq5::omit_sub_address() {
    sub_address_field.~OssString();
    bit_mask &= ~0x80000000;
}

void *PresentationAddress::operator new(size_t size) {
    return ossNewFunc(size);
}

void PresentationAddress::operator delete(void *ptr) {
    asn1Free(ptr);
}

PresentationAddress::PresentationAddress() {
    memset(this, 0, sizeof(PresentationAddress));
}

PresentationAddress::PresentationAddress(const PresentationAddress & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	pSelector_field = that.pSelector_field;
	sSelector_field = that.sSelector_field;
	tSelector_field = that.tSelector_field;
	nAddresses_field = that.nAddresses_field;
    } OSSCLEAN(PresentationAddress)
}

PresentationAddress::PresentationAddress(const pSelector & pSelector_val, const sSelector & sSelector_val, 
    const tSelector & tSelector_val, const nAddresses & nAddresses_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	pSelector_field = pSelector_val;
	sSelector_field = sSelector_val;
	tSelector_field = tSelector_val;
	nAddresses_field = nAddresses_val;
    } OSSCLEAN(PresentationAddress)
}

PresentationAddress::PresentationAddress(const nAddresses & nAddresses_val) {
    OSSTRY {
	bit_mask = 0;
	nAddresses_field = nAddresses_val;
    } OSSCLEAN(PresentationAddress)
}

PresentationAddress & PresentationAddress::operator = (const PresentationAddress & that) {
    if (this == &that)
	return *this;
    this->~PresentationAddress();
    bit_mask = that.bit_mask;
    pSelector_field = that.pSelector_field;
    sSelector_field = that.sSelector_field;
    tSelector_field = that.tSelector_field;
    nAddresses_field = that.nAddresses_field;
    return *this;
}

int PresentationAddress::operator == (const PresentationAddress & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (pSelector_field != that.pSelector_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (sSelector_field != that.sSelector_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (tSelector_field != that.tSelector_field)
	    return 0;
    }
    if (nAddresses_field != that.nAddresses_field)
	return 0;
    return 1;
}

int PresentationAddress::operator != (const PresentationAddress & that) const {
    return !(operator ==(that));
}

PresentationAddress::pSelector *PresentationAddress::get_pSelector() {
    if (bit_mask & 0x80000000)
	return &pSelector_field;
    else
	return 0;
}

const PresentationAddress::pSelector *PresentationAddress::get_pSelector() const {
    if (bit_mask & 0x80000000)
	return &pSelector_field;
    else
	return 0;
}

void PresentationAddress::set_pSelector(const pSelector & pSelector_val) {
    bit_mask |= 0x80000000;
    pSelector_field = pSelector_val;
}

int PresentationAddress::pSelector_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void PresentationAddress::omit_pSelector() {
    pSelector_field.~OssString();
    bit_mask &= ~0x80000000;
}

PresentationAddress::sSelector *PresentationAddress::get_sSelector() {
    if (bit_mask & 0x40000000)
	return &sSelector_field;
    else
	return 0;
}

const PresentationAddress::sSelector *PresentationAddress::get_sSelector() const {
    if (bit_mask & 0x40000000)
	return &sSelector_field;
    else
	return 0;
}

void PresentationAddress::set_sSelector(const sSelector & sSelector_val) {
    bit_mask |= 0x40000000;
    sSelector_field = sSelector_val;
}

int PresentationAddress::sSelector_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void PresentationAddress::omit_sSelector() {
    sSelector_field.~OssString();
    bit_mask &= ~0x40000000;
}

PresentationAddress::tSelector *PresentationAddress::get_tSelector() {
    if (bit_mask & 0x20000000)
	return &tSelector_field;
    else
	return 0;
}

const PresentationAddress::tSelector *PresentationAddress::get_tSelector() const {
    if (bit_mask & 0x20000000)
	return &tSelector_field;
    else
	return 0;
}

void PresentationAddress::set_tSelector(const tSelector & tSelector_val) {
    bit_mask |= 0x20000000;
    tSelector_field = tSelector_val;
}

int PresentationAddress::tSelector_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void PresentationAddress::omit_tSelector() {
    tSelector_field.~OssString();
    bit_mask &= ~0x20000000;
}

PresentationAddress::nAddresses & PresentationAddress::get_nAddresses() {
    return nAddresses_field;
}

const PresentationAddress::nAddresses & PresentationAddress::get_nAddresses() const {
    return nAddresses_field;
}

void PresentationAddress::set_nAddresses(const nAddresses & nAddresses_val) {
    nAddresses_field = nAddresses_val;
}

ExtendedNetworkAddress::ExtendedNetworkAddress() {
    memset(this, 0, sizeof(ExtendedNetworkAddress));
}

ExtendedNetworkAddress::ExtendedNetworkAddress(const ExtendedNetworkAddress & that) {
    memset(this, 0, sizeof(ExtendedNetworkAddress));
    operator =(that);
}

ExtendedNetworkAddress::~ExtendedNetworkAddress() {
    cleanup();
}

ExtendedNetworkAddress & ExtendedNetworkAddress::operator = (const ExtendedNetworkAddress & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case e163_4_address_chosen:
	    if (that.e163_4_address_field)
		e163_4_address_field = new e163_4_address(*that.e163_4_address_field);
	    break;
	case psap_address_chosen:
	    if (that.psap_address_field)
		psap_address_field = new psap_address(*that.psap_address_field);
	    break;
    }
    return *this;
}

int ExtendedNetworkAddress::operator == (const ExtendedNetworkAddress & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case e163_4_address_chosen:
	    if ((e163_4_address_field) && (that.e163_4_address_field))
		return (*e163_4_address_field == *(that.e163_4_address_field));
	    else if (!((!e163_4_address_field) && (!that.e163_4_address_field)))
		return 0;
	    break;
	case psap_address_chosen:
	    if ((psap_address_field) && (that.psap_address_field))
		return (*psap_address_field == *(that.psap_address_field));
	    else if (!((!psap_address_field) && (!that.psap_address_field)))
		return 0;
	    break;
    }

    return 1;
}

int ExtendedNetworkAddress::operator != (const ExtendedNetworkAddress & that) const {
    return !(operator ==(that));
}

ExtendedNetworkAddress::e163_4_address *ExtendedNetworkAddress::get_e163_4_address() {
    if (_choice == e163_4_address_chosen)
	return (e163_4_address *)e163_4_address_field;
    else
	return 0;
}

const ExtendedNetworkAddress::e163_4_address *ExtendedNetworkAddress::get_e163_4_address() const {
    if (_choice == e163_4_address_chosen)
	return (const e163_4_address *)e163_4_address_field;
    else
	return 0;
}

void ExtendedNetworkAddress::set_e163_4_address(const e163_4_address & e163_4_address_val) {
    cleanup();
    e163_4_address_field = new e163_4_address(e163_4_address_val);
    _choice = e163_4_address_chosen;
}

ExtendedNetworkAddress::psap_address *ExtendedNetworkAddress::get_psap_address() {
    if (_choice == psap_address_chosen)
	return (psap_address *)psap_address_field;
    else
	return 0;
}

const ExtendedNetworkAddress::psap_address *ExtendedNetworkAddress::get_psap_address() const {
    if (_choice == psap_address_chosen)
	return (const psap_address *)psap_address_field;
    else
	return 0;
}

void ExtendedNetworkAddress::set_psap_address(const psap_address & psap_address_val) {
    cleanup();
    psap_address_field = new psap_address(psap_address_val);
    _choice = psap_address_chosen;
}

void ExtendedNetworkAddress::cleanup() {
    switch (_choice) {
	case e163_4_address_chosen:
	    if (e163_4_address_field)
		delete e163_4_address_field;
	    break;
	case psap_address_chosen:
	    if (psap_address_field)
		delete psap_address_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *PKAuthenticator_OLD::operator new(size_t size) {
    return ossNewFunc(size);
}

void PKAuthenticator_OLD::operator delete(void *ptr) {
    asn1Free(ptr);
}

PKAuthenticator_OLD::PKAuthenticator_OLD() {
    memset(this, 0, sizeof(PKAuthenticator_OLD));
}

PKAuthenticator_OLD::PKAuthenticator_OLD(const PKAuthenticator_OLD & that) {
    OSSTRY {
	kdc_name_field = that.kdc_name_field;
	kdc_realm_field = that.kdc_realm_field;
	cusec_field = that.cusec_field;
	ctime_field = that.ctime_field;
	nonce_field = that.nonce_field;
    } OSSCLEAN(PKAuthenticator_OLD)
}

PKAuthenticator_OLD::PKAuthenticator_OLD(const kdc_name & kdc_name_val, const kdc_realm & kdc_realm_val, 
    cusec cusec_val, const ctime & ctime_val, nonce nonce_val) {
    OSSTRY {
	kdc_name_field = kdc_name_val;
	kdc_realm_field = kdc_realm_val;
	cusec_field = cusec_val;
	ctime_field = ctime_val;
	nonce_field = nonce_val;
    } OSSCLEAN(PKAuthenticator_OLD)
}

PKAuthenticator_OLD & PKAuthenticator_OLD::operator = (const PKAuthenticator_OLD & that) {
    if (this == &that)
	return *this;
    kdc_name_field = that.kdc_name_field;
    kdc_realm_field = that.kdc_realm_field;
    cusec_field = that.cusec_field;
    ctime_field = that.ctime_field;
    nonce_field = that.nonce_field;
    return *this;
}

int PKAuthenticator_OLD::operator == (const PKAuthenticator_OLD & that) const {
    if (kdc_name_field != that.kdc_name_field)
	return 0;
    if (kdc_realm_field != that.kdc_realm_field)
	return 0;
    if (cusec_field != that.cusec_field)
	return 0;
    if (ctime_field != that.ctime_field)
	return 0;
    if (nonce_field != that.nonce_field)
	return 0;
    return 1;
}

int PKAuthenticator_OLD::operator != (const PKAuthenticator_OLD & that) const {
    return !(operator ==(that));
}

PKAuthenticator_OLD::kdc_name & PKAuthenticator_OLD::get_kdc_name() {
    return kdc_name_field;
}

const PKAuthenticator_OLD::kdc_name & PKAuthenticator_OLD::get_kdc_name() const {
    return kdc_name_field;
}

void PKAuthenticator_OLD::set_kdc_name(const kdc_name & kdc_name_val) {
    kdc_name_field = kdc_name_val;
}

PKAuthenticator_OLD::kdc_realm & PKAuthenticator_OLD::get_kdc_realm() {
    return kdc_realm_field;
}

const PKAuthenticator_OLD::kdc_realm & PKAuthenticator_OLD::get_kdc_realm() const {
    return kdc_realm_field;
}

void PKAuthenticator_OLD::set_kdc_realm(const kdc_realm & kdc_realm_val) {
    kdc_realm_field = kdc_realm_val;
}

PKAuthenticator_OLD::cusec & PKAuthenticator_OLD::get_cusec() {
    return cusec_field;
}

PKAuthenticator_OLD::cusec PKAuthenticator_OLD::get_cusec() const {
    return cusec_field;
}

void PKAuthenticator_OLD::set_cusec(cusec cusec_val) {
    cusec_field = cusec_val;
}

PKAuthenticator_OLD::ctime & PKAuthenticator_OLD::get_ctime() {
    return ctime_field;
}

const PKAuthenticator_OLD::ctime & PKAuthenticator_OLD::get_ctime() const {
    return ctime_field;
}

void PKAuthenticator_OLD::set_ctime(const ctime & ctime_val) {
    ctime_field = ctime_val;
}

PKAuthenticator_OLD::nonce & PKAuthenticator_OLD::get_nonce() {
    return nonce_field;
}

PKAuthenticator_OLD::nonce PKAuthenticator_OLD::get_nonce() const {
    return nonce_field;
}

void PKAuthenticator_OLD::set_nonce(nonce nonce_val) {
    nonce_field = nonce_val;
}

void *AuthPack_OLD::operator new(size_t size) {
    return ossNewFunc(size);
}

void AuthPack_OLD::operator delete(void *ptr) {
    asn1Free(ptr);
}

AuthPack_OLD::AuthPack_OLD() {
    memset(this, 0, sizeof(AuthPack_OLD));
}

AuthPack_OLD::AuthPack_OLD(const AuthPack_OLD & that) {
    OSSTRY {
	pkAuthenticator_field = that.pkAuthenticator_field;
    } OSSCLEAN(AuthPack_OLD)
}

AuthPack_OLD::AuthPack_OLD(const pkAuthenticator & pkAuthenticator_val) {
    OSSTRY {
	pkAuthenticator_field = pkAuthenticator_val;
    } OSSCLEAN(AuthPack_OLD)
}

AuthPack_OLD & AuthPack_OLD::operator = (const AuthPack_OLD & that) {
    if (this == &that)
	return *this;
    pkAuthenticator_field = that.pkAuthenticator_field;
    return *this;
}

int AuthPack_OLD::operator == (const AuthPack_OLD & that) const {
    if (pkAuthenticator_field != that.pkAuthenticator_field)
	return 0;
    return 1;
}

int AuthPack_OLD::operator != (const AuthPack_OLD & that) const {
    return !(operator ==(that));
}

AuthPack_OLD::pkAuthenticator & AuthPack_OLD::get_pkAuthenticator() {
    return pkAuthenticator_field;
}

const AuthPack_OLD::pkAuthenticator & AuthPack_OLD::get_pkAuthenticator() const {
    return pkAuthenticator_field;
}

void AuthPack_OLD::set_pkAuthenticator(const pkAuthenticator & pkAuthenticator_val) {
    pkAuthenticator_field = pkAuthenticator_val;
}

void *KERB_REPLY_KEY_PACKAGE::operator new(size_t size) {
    return ossNewFunc(size);
}

void KERB_REPLY_KEY_PACKAGE::operator delete(void *ptr) {
    asn1Free(ptr);
}

KERB_REPLY_KEY_PACKAGE::KERB_REPLY_KEY_PACKAGE() {
    memset(this, 0, sizeof(KERB_REPLY_KEY_PACKAGE));
}

KERB_REPLY_KEY_PACKAGE::KERB_REPLY_KEY_PACKAGE(const KERB_REPLY_KEY_PACKAGE & that) {
    OSSTRY {
	replyKey_field = that.replyKey_field;
	nonce_field = that.nonce_field;
    } OSSCLEAN(KERB_REPLY_KEY_PACKAGE)
}

KERB_REPLY_KEY_PACKAGE::KERB_REPLY_KEY_PACKAGE(const replyKey & replyKey_val, nonce nonce_val) {
    OSSTRY {
	replyKey_field = replyKey_val;
	nonce_field = nonce_val;
    } OSSCLEAN(KERB_REPLY_KEY_PACKAGE)
}

KERB_REPLY_KEY_PACKAGE & KERB_REPLY_KEY_PACKAGE::operator = (const KERB_REPLY_KEY_PACKAGE & that) {
    if (this == &that)
	return *this;
    replyKey_field = that.replyKey_field;
    nonce_field = that.nonce_field;
    return *this;
}

int KERB_REPLY_KEY_PACKAGE::operator == (const KERB_REPLY_KEY_PACKAGE & that) const {
    if (replyKey_field != that.replyKey_field)
	return 0;
    if (nonce_field != that.nonce_field)
	return 0;
    return 1;
}

int KERB_REPLY_KEY_PACKAGE::operator != (const KERB_REPLY_KEY_PACKAGE & that) const {
    return !(operator ==(that));
}

KERB_REPLY_KEY_PACKAGE::replyKey & KERB_REPLY_KEY_PACKAGE::get_replyKey() {
    return replyKey_field;
}

const KERB_REPLY_KEY_PACKAGE::replyKey & KERB_REPLY_KEY_PACKAGE::get_replyKey() const {
    return replyKey_field;
}

void KERB_REPLY_KEY_PACKAGE::set_replyKey(const replyKey & replyKey_val) {
    replyKey_field = replyKey_val;
}

KERB_REPLY_KEY_PACKAGE::nonce & KERB_REPLY_KEY_PACKAGE::get_nonce() {
    return nonce_field;
}

KERB_REPLY_KEY_PACKAGE::nonce KERB_REPLY_KEY_PACKAGE::get_nonce() const {
    return nonce_field;
}

void KERB_REPLY_KEY_PACKAGE::set_nonce(nonce nonce_val) {
    nonce_field = nonce_val;
}

void *PA_FOR_USER_ENC::operator new(size_t size) {
    return ossNewFunc(size);
}

void PA_FOR_USER_ENC::operator delete(void *ptr) {
    asn1Free(ptr);
}

PA_FOR_USER_ENC::PA_FOR_USER_ENC() {
    memset(this, 0, sizeof(PA_FOR_USER_ENC));
}

PA_FOR_USER_ENC::PA_FOR_USER_ENC(const PA_FOR_USER_ENC & that) {
    OSSTRY {
	userName_field = that.userName_field;
	userRealm_field = that.userRealm_field;
	cksum_field = that.cksum_field;
	auth_package_field = that.auth_package_field;
    } OSSCLEAN(PA_FOR_USER_ENC)
}

PA_FOR_USER_ENC::PA_FOR_USER_ENC(const userName & userName_val, const userRealm & userRealm_val, 
    const cksum & cksum_val, const auth_package & auth_package_val) {
    OSSTRY {
	userName_field = userName_val;
	userRealm_field = userRealm_val;
	cksum_field = cksum_val;
	auth_package_field = auth_package_val;
    } OSSCLEAN(PA_FOR_USER_ENC)
}

PA_FOR_USER_ENC & PA_FOR_USER_ENC::operator = (const PA_FOR_USER_ENC & that) {
    if (this == &that)
	return *this;
    userName_field = that.userName_field;
    userRealm_field = that.userRealm_field;
    cksum_field = that.cksum_field;
    auth_package_field = that.auth_package_field;
    return *this;
}

int PA_FOR_USER_ENC::operator == (const PA_FOR_USER_ENC & that) const {
    if (userName_field != that.userName_field)
	return 0;
    if (userRealm_field != that.userRealm_field)
	return 0;
    if (cksum_field != that.cksum_field)
	return 0;
    if (auth_package_field != that.auth_package_field)
	return 0;
    return 1;
}

int PA_FOR_USER_ENC::operator != (const PA_FOR_USER_ENC & that) const {
    return !(operator ==(that));
}

PA_FOR_USER_ENC::userName & PA_FOR_USER_ENC::get_userName() {
    return userName_field;
}

const PA_FOR_USER_ENC::userName & PA_FOR_USER_ENC::get_userName() const {
    return userName_field;
}

void PA_FOR_USER_ENC::set_userName(const userName & userName_val) {
    userName_field = userName_val;
}

PA_FOR_USER_ENC::userRealm & PA_FOR_USER_ENC::get_userRealm() {
    return userRealm_field;
}

const PA_FOR_USER_ENC::userRealm & PA_FOR_USER_ENC::get_userRealm() const {
    return userRealm_field;
}

void PA_FOR_USER_ENC::set_userRealm(const userRealm & userRealm_val) {
    userRealm_field = userRealm_val;
}

PA_FOR_USER_ENC::cksum & PA_FOR_USER_ENC::get_cksum() {
    return cksum_field;
}

const PA_FOR_USER_ENC::cksum & PA_FOR_USER_ENC::get_cksum() const {
    return cksum_field;
}

void PA_FOR_USER_ENC::set_cksum(const cksum & cksum_val) {
    cksum_field = cksum_val;
}

PA_FOR_USER_ENC::auth_package & PA_FOR_USER_ENC::get_auth_package() {
    return auth_package_field;
}

const PA_FOR_USER_ENC::auth_package & PA_FOR_USER_ENC::get_auth_package() const {
    return auth_package_field;
}

void PA_FOR_USER_ENC::set_auth_package(const auth_package & auth_package_val) {
    auth_package_field = auth_package_val;
}

void *S4UUserID::operator new(size_t size) {
    return ossNewFunc(size);
}

void S4UUserID::operator delete(void *ptr) {
    asn1Free(ptr);
}

S4UUserID::S4UUserID() {
    memset(this, 0, sizeof(S4UUserID));
}

S4UUserID::S4UUserID(const S4UUserID & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	nonce_field = that.nonce_field;
	cname_field = that.cname_field;
	crealm_field = that.crealm_field;
	subject_certificate_field = that.subject_certificate_field;
	options_field = that.options_field;
    } OSSCLEAN(S4UUserID)
}

S4UUserID::S4UUserID(nonce nonce_val, const cname & cname_val, const crealm & crealm_val, 
    const subject_certificate & subject_certificate_val, const options & options_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	nonce_field = nonce_val;
	cname_field = cname_val;
	crealm_field = crealm_val;
	subject_certificate_field = subject_certificate_val;
	options_field = options_val;
    } OSSCLEAN(S4UUserID)
}

S4UUserID::S4UUserID(nonce nonce_val, const crealm & crealm_val) {
    OSSTRY {
	bit_mask = 0;
	nonce_field = nonce_val;
	crealm_field = crealm_val;
    } OSSCLEAN(S4UUserID)
}

S4UUserID & S4UUserID::operator = (const S4UUserID & that) {
    if (this == &that)
	return *this;
    this->~S4UUserID();
    bit_mask = that.bit_mask;
    nonce_field = that.nonce_field;
    cname_field = that.cname_field;
    crealm_field = that.crealm_field;
    subject_certificate_field = that.subject_certificate_field;
    options_field = that.options_field;
    return *this;
}

int S4UUserID::operator == (const S4UUserID & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (nonce_field != that.nonce_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (cname_field != that.cname_field)
	    return 0;
    }
    if (crealm_field != that.crealm_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (subject_certificate_field != that.subject_certificate_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (options_field != that.options_field)
	    return 0;
    }
    return 1;
}

int S4UUserID::operator != (const S4UUserID & that) const {
    return !(operator ==(that));
}

S4UUserID::nonce & S4UUserID::get_nonce() {
    return nonce_field;
}

S4UUserID::nonce S4UUserID::get_nonce() const {
    return nonce_field;
}

void S4UUserID::set_nonce(nonce nonce_val) {
    nonce_field = nonce_val;
}

S4UUserID::cname *S4UUserID::get_cname() {
    if (bit_mask & 0x80000000)
	return &cname_field;
    else
	return 0;
}

const S4UUserID::cname *S4UUserID::get_cname() const {
    if (bit_mask & 0x80000000)
	return &cname_field;
    else
	return 0;
}

void S4UUserID::set_cname(const cname & cname_val) {
    bit_mask |= 0x80000000;
    cname_field = cname_val;
}

int S4UUserID::cname_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void S4UUserID::omit_cname() {
    cname_field.~PrincipalName();
    bit_mask &= ~0x80000000;
}

S4UUserID::crealm & S4UUserID::get_crealm() {
    return crealm_field;
}

const S4UUserID::crealm & S4UUserID::get_crealm() const {
    return crealm_field;
}

void S4UUserID::set_crealm(const crealm & crealm_val) {
    crealm_field = crealm_val;
}

S4UUserID::subject_certificate *S4UUserID::get_subject_certificate() {
    if (bit_mask & 0x40000000)
	return &subject_certificate_field;
    else
	return 0;
}

const S4UUserID::subject_certificate *S4UUserID::get_subject_certificate() const {
    if (bit_mask & 0x40000000)
	return &subject_certificate_field;
    else
	return 0;
}

void S4UUserID::set_subject_certificate(const subject_certificate & subject_certificate_val) {
    bit_mask |= 0x40000000;
    subject_certificate_field = subject_certificate_val;
}

int S4UUserID::subject_certificate_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void S4UUserID::omit_subject_certificate() {
    subject_certificate_field.~OssString();
    bit_mask &= ~0x40000000;
}

S4UUserID::options *S4UUserID::get_options() {
    if (bit_mask & 0x20000000)
	return &options_field;
    else
	return 0;
}

const S4UUserID::options *S4UUserID::get_options() const {
    if (bit_mask & 0x20000000)
	return &options_field;
    else
	return 0;
}

void S4UUserID::set_options(const options & options_val) {
    bit_mask |= 0x20000000;
    options_field = options_val;
}

int S4UUserID::options_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void S4UUserID::omit_options() {
    options_field.~OssBitString();
    bit_mask &= ~0x20000000;
}

void *PA_S4U_X509_USER::operator new(size_t size) {
    return ossNewFunc(size);
}

void PA_S4U_X509_USER::operator delete(void *ptr) {
    asn1Free(ptr);
}

PA_S4U_X509_USER::PA_S4U_X509_USER() {
    memset(this, 0, sizeof(PA_S4U_X509_USER));
}

PA_S4U_X509_USER::PA_S4U_X509_USER(const PA_S4U_X509_USER & that) {
    OSSTRY {
	user_id_field = that.user_id_field;
	checksum_field = that.checksum_field;
    } OSSCLEAN(PA_S4U_X509_USER)
}

PA_S4U_X509_USER::PA_S4U_X509_USER(const user_id & user_id_val, const checksum & checksum_val) {
    OSSTRY {
	user_id_field = user_id_val;
	checksum_field = checksum_val;
    } OSSCLEAN(PA_S4U_X509_USER)
}

PA_S4U_X509_USER & PA_S4U_X509_USER::operator = (const PA_S4U_X509_USER & that) {
    if (this == &that)
	return *this;
    user_id_field = that.user_id_field;
    checksum_field = that.checksum_field;
    return *this;
}

int PA_S4U_X509_USER::operator == (const PA_S4U_X509_USER & that) const {
    if (user_id_field != that.user_id_field)
	return 0;
    if (checksum_field != that.checksum_field)
	return 0;
    return 1;
}

int PA_S4U_X509_USER::operator != (const PA_S4U_X509_USER & that) const {
    return !(operator ==(that));
}

PA_S4U_X509_USER::user_id & PA_S4U_X509_USER::get_user_id() {
    return user_id_field;
}

const PA_S4U_X509_USER::user_id & PA_S4U_X509_USER::get_user_id() const {
    return user_id_field;
}

void PA_S4U_X509_USER::set_user_id(const user_id & user_id_val) {
    user_id_field = user_id_val;
}

PA_S4U_X509_USER::checksum & PA_S4U_X509_USER::get_checksum() {
    return checksum_field;
}

const PA_S4U_X509_USER::checksum & PA_S4U_X509_USER::get_checksum() const {
    return checksum_field;
}

void PA_S4U_X509_USER::set_checksum(const checksum & checksum_val) {
    checksum_field = checksum_val;
}

void *PA_PAC_OPTIONS::operator new(size_t size) {
    return ossNewFunc(size);
}

void PA_PAC_OPTIONS::operator delete(void *ptr) {
    asn1Free(ptr);
}

PA_PAC_OPTIONS::PA_PAC_OPTIONS() {
    memset(this, 0, sizeof(PA_PAC_OPTIONS));
}

PA_PAC_OPTIONS::PA_PAC_OPTIONS(const PA_PAC_OPTIONS & that) {
    OSSTRY {
	kerberosFlags_field = that.kerberosFlags_field;
    } OSSCLEAN(PA_PAC_OPTIONS)
}

PA_PAC_OPTIONS::PA_PAC_OPTIONS(const kerberosFlags & kerberosFlags_val) {
    OSSTRY {
	kerberosFlags_field = kerberosFlags_val;
    } OSSCLEAN(PA_PAC_OPTIONS)
}

PA_PAC_OPTIONS & PA_PAC_OPTIONS::operator = (const PA_PAC_OPTIONS & that) {
    if (this == &that)
	return *this;
    kerberosFlags_field = that.kerberosFlags_field;
    return *this;
}

int PA_PAC_OPTIONS::operator == (const PA_PAC_OPTIONS & that) const {
    if (kerberosFlags_field != that.kerberosFlags_field)
	return 0;
    return 1;
}

int PA_PAC_OPTIONS::operator != (const PA_PAC_OPTIONS & that) const {
    return !(operator ==(that));
}

PA_PAC_OPTIONS::kerberosFlags & PA_PAC_OPTIONS::get_kerberosFlags() {
    return kerberosFlags_field;
}

const PA_PAC_OPTIONS::kerberosFlags & PA_PAC_OPTIONS::get_kerberosFlags() const {
    return kerberosFlags_field;
}

void PA_PAC_OPTIONS::set_kerberosFlags(const kerberosFlags & kerberosFlags_val) {
    kerberosFlags_field = kerberosFlags_val;
}

void *KERB_PA_PAC_REQUEST::operator new(size_t size) {
    return ossNewFunc(size);
}

void KERB_PA_PAC_REQUEST::operator delete(void *ptr) {
    asn1Free(ptr);
}

KERB_PA_PAC_REQUEST::KERB_PA_PAC_REQUEST() {
    memset(this, 0, sizeof(KERB_PA_PAC_REQUEST));
}

KERB_PA_PAC_REQUEST::KERB_PA_PAC_REQUEST(const KERB_PA_PAC_REQUEST & that) {
    OSSTRY {
	include_pac_field = that.include_pac_field;
    } OSSCLEAN(KERB_PA_PAC_REQUEST)
}

KERB_PA_PAC_REQUEST::KERB_PA_PAC_REQUEST(include_pac include_pac_val) {
    OSSTRY {
	include_pac_field = include_pac_val;
    } OSSCLEAN(KERB_PA_PAC_REQUEST)
}

KERB_PA_PAC_REQUEST & KERB_PA_PAC_REQUEST::operator = (const KERB_PA_PAC_REQUEST & that) {
    if (this == &that)
	return *this;
    include_pac_field = that.include_pac_field;
    return *this;
}

int KERB_PA_PAC_REQUEST::operator == (const KERB_PA_PAC_REQUEST & that) const {
    if (include_pac_field != that.include_pac_field)
	return 0;
    return 1;
}

int KERB_PA_PAC_REQUEST::operator != (const KERB_PA_PAC_REQUEST & that) const {
    return !(operator ==(that));
}

KERB_PA_PAC_REQUEST::include_pac & KERB_PA_PAC_REQUEST::get_include_pac() {
    return include_pac_field;
}

KERB_PA_PAC_REQUEST::include_pac KERB_PA_PAC_REQUEST::get_include_pac() const {
    return include_pac_field;
}

void KERB_PA_PAC_REQUEST::set_include_pac(include_pac include_pac_val) {
    include_pac_field = include_pac_val;
}

void *KERB_AD_RESTRICTION_ENTRY::operator new(size_t size) {
    return ossNewFunc(size);
}

void KERB_AD_RESTRICTION_ENTRY::operator delete(void *ptr) {
    asn1Free(ptr);
}

KERB_AD_RESTRICTION_ENTRY::KERB_AD_RESTRICTION_ENTRY() {
    memset(this, 0, sizeof(KERB_AD_RESTRICTION_ENTRY));
}

KERB_AD_RESTRICTION_ENTRY::KERB_AD_RESTRICTION_ENTRY(const KERB_AD_RESTRICTION_ENTRY & that) {
    OSSTRY {
	restriction_type_field = that.restriction_type_field;
	restriction_field = that.restriction_field;
    } OSSCLEAN(KERB_AD_RESTRICTION_ENTRY)
}

KERB_AD_RESTRICTION_ENTRY::KERB_AD_RESTRICTION_ENTRY(restriction_type restriction_type_val, 
    const restriction & restriction_val) {
    OSSTRY {
	restriction_type_field = restriction_type_val;
	restriction_field = restriction_val;
    } OSSCLEAN(KERB_AD_RESTRICTION_ENTRY)
}

KERB_AD_RESTRICTION_ENTRY & KERB_AD_RESTRICTION_ENTRY::operator = (const KERB_AD_RESTRICTION_ENTRY & that) {
    if (this == &that)
	return *this;
    restriction_type_field = that.restriction_type_field;
    restriction_field = that.restriction_field;
    return *this;
}

int KERB_AD_RESTRICTION_ENTRY::operator == (const KERB_AD_RESTRICTION_ENTRY & that) const {
    if (restriction_type_field != that.restriction_type_field)
	return 0;
    if (restriction_field != that.restriction_field)
	return 0;
    return 1;
}

int KERB_AD_RESTRICTION_ENTRY::operator != (const KERB_AD_RESTRICTION_ENTRY & that) const {
    return !(operator ==(that));
}

KERB_AD_RESTRICTION_ENTRY::restriction_type & KERB_AD_RESTRICTION_ENTRY::get_restriction_type() {
    return restriction_type_field;
}

KERB_AD_RESTRICTION_ENTRY::restriction_type KERB_AD_RESTRICTION_ENTRY::get_restriction_type() const {
    return restriction_type_field;
}

void KERB_AD_RESTRICTION_ENTRY::set_restriction_type(restriction_type restriction_type_val) {
    restriction_type_field = restriction_type_val;
}

KERB_AD_RESTRICTION_ENTRY::restriction & KERB_AD_RESTRICTION_ENTRY::get_restriction() {
    return restriction_field;
}

const KERB_AD_RESTRICTION_ENTRY::restriction & KERB_AD_RESTRICTION_ENTRY::get_restriction() const {
    return restriction_field;
}

void KERB_AD_RESTRICTION_ENTRY::set_restriction(const restriction & restriction_val) {
    restriction_field = restriction_val;
}

/* Universal PDU class */

cbd_asn1_PDU::cbd_asn1_PDU() {
}

void cbd_asn1_PDU::set_Ticket(Ticket & d) {
    index = 1;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Ticket *cbd_asn1_PDU::get_Ticket() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 1 && !constant)
#else
    if (index == 1)
#endif
	return (Ticket *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_EncTicketPart(EncTicketPart & d) {
    index = 2;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncTicketPart *cbd_asn1_PDU::get_EncTicketPart() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 2 && !constant)
#else
    if (index == 2)
#endif
	return (EncTicketPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AS_REQ(AS_REQ & d) {
    index = 3;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AS_REQ *cbd_asn1_PDU::get_AS_REQ() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 3 && !constant)
#else
    if (index == 3)
#endif
	return (AS_REQ *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TGS_REQ(TGS_REQ & d) {
    index = 4;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TGS_REQ *cbd_asn1_PDU::get_TGS_REQ() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 4 && !constant)
#else
    if (index == 4)
#endif
	return (TGS_REQ *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KDC_REQ_BODY(KDC_REQ_BODY & d) {
    index = 5;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KDC_REQ_BODY *cbd_asn1_PDU::get_KDC_REQ_BODY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 5 && !constant)
#else
    if (index == 5)
#endif
	return (KDC_REQ_BODY *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AS_REP(AS_REP & d) {
    index = 6;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AS_REP *cbd_asn1_PDU::get_AS_REP() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 6 && !constant)
#else
    if (index == 6)
#endif
	return (AS_REP *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TGS_REP(TGS_REP & d) {
    index = 7;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TGS_REP *cbd_asn1_PDU::get_TGS_REP() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 7 && !constant)
#else
    if (index == 7)
#endif
	return (TGS_REP *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_EncASRepPart(EncASRepPart & d) {
    index = 8;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncASRepPart *cbd_asn1_PDU::get_EncASRepPart() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 8 && !constant)
#else
    if (index == 8)
#endif
	return (EncASRepPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_EncTGSRepPart(EncTGSRepPart & d) {
    index = 9;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncTGSRepPart *cbd_asn1_PDU::get_EncTGSRepPart() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 9 && !constant)
#else
    if (index == 9)
#endif
	return (EncTGSRepPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AP_REQ(AP_REQ & d) {
    index = 10;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AP_REQ *cbd_asn1_PDU::get_AP_REQ() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 10 && !constant)
#else
    if (index == 10)
#endif
	return (AP_REQ *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_Authenticator(Authenticator & d) {
    index = 11;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Authenticator *cbd_asn1_PDU::get_Authenticator() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 11 && !constant)
#else
    if (index == 11)
#endif
	return (Authenticator *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AP_REP(AP_REP & d) {
    index = 12;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AP_REP *cbd_asn1_PDU::get_AP_REP() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 12 && !constant)
#else
    if (index == 12)
#endif
	return (AP_REP *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_EncAPRepPart(EncAPRepPart & d) {
    index = 13;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncAPRepPart *cbd_asn1_PDU::get_EncAPRepPart() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 13 && !constant)
#else
    if (index == 13)
#endif
	return (EncAPRepPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KRB_SAFE(KRB_SAFE & d) {
    index = 14;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KRB_SAFE *cbd_asn1_PDU::get_KRB_SAFE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 14 && !constant)
#else
    if (index == 14)
#endif
	return (KRB_SAFE *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KRB_PRIV(KRB_PRIV & d) {
    index = 15;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KRB_PRIV *cbd_asn1_PDU::get_KRB_PRIV() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 15 && !constant)
#else
    if (index == 15)
#endif
	return (KRB_PRIV *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_EncKrbPrivPart(EncKrbPrivPart & d) {
    index = 16;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncKrbPrivPart *cbd_asn1_PDU::get_EncKrbPrivPart() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 16 && !constant)
#else
    if (index == 16)
#endif
	return (EncKrbPrivPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KRB_CRED(KRB_CRED & d) {
    index = 17;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KRB_CRED *cbd_asn1_PDU::get_KRB_CRED() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 17 && !constant)
#else
    if (index == 17)
#endif
	return (KRB_CRED *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_EncKrbCredPart(EncKrbCredPart & d) {
    index = 18;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncKrbCredPart *cbd_asn1_PDU::get_EncKrbCredPart() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 18 && !constant)
#else
    if (index == 18)
#endif
	return (EncKrbCredPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KRB_ERROR(KRB_ERROR & d) {
    index = 19;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KRB_ERROR *cbd_asn1_PDU::get_KRB_ERROR() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 19 && !constant)
#else
    if (index == 19)
#endif
	return (KRB_ERROR *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_METHOD_DATA(METHOD_DATA & d) {
    index = 20;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

METHOD_DATA *cbd_asn1_PDU::get_METHOD_DATA() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 20 && !constant)
#else
    if (index == 20)
#endif
	return (METHOD_DATA *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TYPED_DATA(TYPED_DATA & d) {
    index = 21;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TYPED_DATA *cbd_asn1_PDU::get_TYPED_DATA() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 21 && !constant)
#else
    if (index == 21)
#endif
	return (TYPED_DATA *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PA_ENC_TIMESTAMP(PA_ENC_TIMESTAMP & d) {
    index = 22;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_ENC_TIMESTAMP *cbd_asn1_PDU::get_PA_ENC_TIMESTAMP() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 22 && !constant)
#else
    if (index == 22)
#endif
	return (PA_ENC_TIMESTAMP *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PA_ENC_TS_ENC(PA_ENC_TS_ENC & d) {
    index = 23;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_ENC_TS_ENC *cbd_asn1_PDU::get_PA_ENC_TS_ENC() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 23 && !constant)
#else
    if (index == 23)
#endif
	return (PA_ENC_TS_ENC *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_ETYPE_INFO(ETYPE_INFO & d) {
    index = 24;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ETYPE_INFO *cbd_asn1_PDU::get_ETYPE_INFO() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 24 && !constant)
#else
    if (index == 24)
#endif
	return (ETYPE_INFO *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_ETYPE_INFO2(ETYPE_INFO2 & d) {
    index = 25;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ETYPE_INFO2 *cbd_asn1_PDU::get_ETYPE_INFO2() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 25 && !constant)
#else
    if (index == 25)
#endif
	return (ETYPE_INFO2 *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AD_IF_RELEVANT(AD_IF_RELEVANT & d) {
    index = 26;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AD_IF_RELEVANT *cbd_asn1_PDU::get_AD_IF_RELEVANT() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 26 && !constant)
#else
    if (index == 26)
#endif
	return (AD_IF_RELEVANT *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AD_KDCIssued(AD_KDCIssued & d) {
    index = 27;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AD_KDCIssued *cbd_asn1_PDU::get_AD_KDCIssued() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 27 && !constant)
#else
    if (index == 27)
#endif
	return (AD_KDCIssued *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AD_AND_OR(AD_AND_OR & d) {
    index = 28;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AD_AND_OR *cbd_asn1_PDU::get_AD_AND_OR() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 28 && !constant)
#else
    if (index == 28)
#endif
	return (AD_AND_OR *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AD_MANDATORY_FOR_KDC(AD_MANDATORY_FOR_KDC & d) {
    index = 29;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AD_MANDATORY_FOR_KDC *cbd_asn1_PDU::get_AD_MANDATORY_FOR_KDC() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 29 && !constant)
#else
    if (index == 29)
#endif
	return (AD_MANDATORY_FOR_KDC *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_ChangePasswdData(ChangePasswdData & d) {
    index = 30;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ChangePasswdData *cbd_asn1_PDU::get_ChangePasswdData() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 30 && !constant)
#else
    if (index == 30)
#endif
	return (ChangePasswdData *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PA_PK_AS_REQ(PA_PK_AS_REQ & d) {
    index = 31;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_PK_AS_REQ *cbd_asn1_PDU::get_PA_PK_AS_REQ() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 31 && !constant)
#else
    if (index == 31)
#endif
	return (PA_PK_AS_REQ *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AuthPack(AuthPack & d) {
    index = 32;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AuthPack *cbd_asn1_PDU::get_AuthPack() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 32 && !constant)
#else
    if (index == 32)
#endif
	return (AuthPack *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TD_TRUSTED_CERTIFIERS(TD_TRUSTED_CERTIFIERS & d) {
    index = 33;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TD_TRUSTED_CERTIFIERS *cbd_asn1_PDU::get_TD_TRUSTED_CERTIFIERS() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 33 && !constant)
#else
    if (index == 33)
#endif
	return (TD_TRUSTED_CERTIFIERS *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TD_INVALID_CERTIFICATES(TD_INVALID_CERTIFICATES & d) {
    index = 34;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TD_INVALID_CERTIFICATES *cbd_asn1_PDU::get_TD_INVALID_CERTIFICATES() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 34 && !constant)
#else
    if (index == 34)
#endif
	return (TD_INVALID_CERTIFICATES *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KRB5PrincipalName(KRB5PrincipalName & d) {
    index = 35;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KRB5PrincipalName *cbd_asn1_PDU::get_KRB5PrincipalName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 35 && !constant)
#else
    if (index == 35)
#endif
	return (KRB5PrincipalName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AD_INITIAL_VERIFIED_CAS(AD_INITIAL_VERIFIED_CAS & d) {
    index = 36;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AD_INITIAL_VERIFIED_CAS *cbd_asn1_PDU::get_AD_INITIAL_VERIFIED_CAS() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 36 && !constant)
#else
    if (index == 36)
#endif
	return (AD_INITIAL_VERIFIED_CAS *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PA_PK_AS_REP(PA_PK_AS_REP & d) {
    index = 37;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_PK_AS_REP *cbd_asn1_PDU::get_PA_PK_AS_REP() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 37 && !constant)
#else
    if (index == 37)
#endif
	return (PA_PK_AS_REP *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KDCDHKeyInfo(KDCDHKeyInfo & d) {
    index = 38;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KDCDHKeyInfo *cbd_asn1_PDU::get_KDCDHKeyInfo() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 38 && !constant)
#else
    if (index == 38)
#endif
	return (KDCDHKeyInfo *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_ReplyKeyPack(ReplyKeyPack & d) {
    index = 39;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ReplyKeyPack *cbd_asn1_PDU::get_ReplyKeyPack() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 39 && !constant)
#else
    if (index == 39)
#endif
	return (ReplyKeyPack *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TD_DH_PARAMETERS(TD_DH_PARAMETERS & d) {
    index = 40;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TD_DH_PARAMETERS *cbd_asn1_PDU::get_TD_DH_PARAMETERS() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 40 && !constant)
#else
    if (index == 40)
#endif
	return (TD_DH_PARAMETERS *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_Attribute(Attribute & d) {
    index = 41;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Attribute *cbd_asn1_PDU::get_Attribute() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 41 && !constant)
#else
    if (index == 41)
#endif
	return (Attribute *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520name(X520name & d) {
    index = 42;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520name *cbd_asn1_PDU::get_X520name() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 42 && !constant)
#else
    if (index == 42)
#endif
	return (X520name *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520CommonName(X520CommonName & d) {
    index = 43;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520CommonName *cbd_asn1_PDU::get_X520CommonName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 43 && !constant)
#else
    if (index == 43)
#endif
	return (X520CommonName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520LocalityName(X520LocalityName & d) {
    index = 44;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520LocalityName *cbd_asn1_PDU::get_X520LocalityName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 44 && !constant)
#else
    if (index == 44)
#endif
	return (X520LocalityName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520StateOrProvinceName(X520StateOrProvinceName & d) {
    index = 45;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520StateOrProvinceName *cbd_asn1_PDU::get_X520StateOrProvinceName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 45 && !constant)
#else
    if (index == 45)
#endif
	return (X520StateOrProvinceName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520OrganizationName(X520OrganizationName & d) {
    index = 46;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520OrganizationName *cbd_asn1_PDU::get_X520OrganizationName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 46 && !constant)
#else
    if (index == 46)
#endif
	return (X520OrganizationName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520OrganizationalUnitName(X520OrganizationalUnitName & d) {
    index = 47;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520OrganizationalUnitName *cbd_asn1_PDU::get_X520OrganizationalUnitName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 47 && !constant)
#else
    if (index == 47)
#endif
	return (X520OrganizationalUnitName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520Title(X520Title & d) {
    index = 48;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520Title *cbd_asn1_PDU::get_X520Title() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 48 && !constant)
#else
    if (index == 48)
#endif
	return (X520Title *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520dnQualifier(X520dnQualifier & d) {
    index = 49;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520dnQualifier *cbd_asn1_PDU::get_X520dnQualifier() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 49 && !constant)
#else
    if (index == 49)
#endif
	return (X520dnQualifier *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520countryName(X520countryName & d) {
    index = 50;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520countryName *cbd_asn1_PDU::get_X520countryName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 50 && !constant)
#else
    if (index == 50)
#endif
	return (X520countryName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520SerialNumber(X520SerialNumber & d) {
    index = 51;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520SerialNumber *cbd_asn1_PDU::get_X520SerialNumber() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 51 && !constant)
#else
    if (index == 51)
#endif
	return (X520SerialNumber *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_X520Pseudonym(X520Pseudonym & d) {
    index = 52;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520Pseudonym *cbd_asn1_PDU::get_X520Pseudonym() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 52 && !constant)
#else
    if (index == 52)
#endif
	return (X520Pseudonym *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_DomainComponent(DomainComponent & d) {
    index = 53;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DomainComponent *cbd_asn1_PDU::get_DomainComponent() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 53 && !constant)
#else
    if (index == 53)
#endif
	return (DomainComponent *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_EmailAddress(EmailAddress & d) {
    index = 54;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EmailAddress *cbd_asn1_PDU::get_EmailAddress() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 54 && !constant)
#else
    if (index == 54)
#endif
	return (EmailAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_DistinguishedName(DistinguishedName & d) {
    index = 55;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DistinguishedName *cbd_asn1_PDU::get_DistinguishedName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 55 && !constant)
#else
    if (index == 55)
#endif
	return (DistinguishedName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_DirectoryString(DirectoryString & d) {
    index = 56;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DirectoryString *cbd_asn1_PDU::get_DirectoryString() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 56 && !constant)
#else
    if (index == 56)
#endif
	return (DirectoryString *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_Certificate(Certificate & d) {
    index = 57;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Certificate *cbd_asn1_PDU::get_Certificate() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 57 && !constant)
#else
    if (index == 57)
#endif
	return (Certificate *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_CertificateList(CertificateList & d) {
    index = 58;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CertificateList *cbd_asn1_PDU::get_CertificateList() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 58 && !constant)
#else
    if (index == 58)
#endif
	return (CertificateList *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_ORAddress(ORAddress & d) {
    index = 59;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ORAddress *cbd_asn1_PDU::get_ORAddress() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 59 && !constant)
#else
    if (index == 59)
#endif
	return (ORAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_CommonName(CommonName & d) {
    index = 60;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CommonName *cbd_asn1_PDU::get_CommonName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 60 && !constant)
#else
    if (index == 60)
#endif
	return (CommonName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TeletexCommonName(TeletexCommonName & d) {
    index = 61;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TeletexCommonName *cbd_asn1_PDU::get_TeletexCommonName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 61 && !constant)
#else
    if (index == 61)
#endif
	return (TeletexCommonName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TeletexOrganizationName(TeletexOrganizationName & d) {
    index = 62;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TeletexOrganizationName *cbd_asn1_PDU::get_TeletexOrganizationName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 62 && !constant)
#else
    if (index == 62)
#endif
	return (TeletexOrganizationName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TeletexPersonalName(TeletexPersonalName & d) {
    index = 63;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TeletexPersonalName *cbd_asn1_PDU::get_TeletexPersonalName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 63 && !constant)
#else
    if (index == 63)
#endif
	return (TeletexPersonalName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TeletexOrganizationalUnitNames(TeletexOrganizationalUnitNames & d) {
    index = 64;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TeletexOrganizationalUnitNames *cbd_asn1_PDU::get_TeletexOrganizationalUnitNames() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 64 && !constant)
#else
    if (index == 64)
#endif
	return (TeletexOrganizationalUnitNames *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PDSName(PDSName & d) {
    index = 65;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PDSName *cbd_asn1_PDU::get_PDSName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 65 && !constant)
#else
    if (index == 65)
#endif
	return (PDSName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PhysicalDeliveryCountryName(PhysicalDeliveryCountryName & d) {
    index = 66;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PhysicalDeliveryCountryName *cbd_asn1_PDU::get_PhysicalDeliveryCountryName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 66 && !constant)
#else
    if (index == 66)
#endif
	return (PhysicalDeliveryCountryName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PostalCode(PostalCode & d) {
    index = 67;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PostalCode *cbd_asn1_PDU::get_PostalCode() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 67 && !constant)
#else
    if (index == 67)
#endif
	return (PostalCode *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PhysicalDeliveryOfficeName(PhysicalDeliveryOfficeName & d) {
    index = 68;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PhysicalDeliveryOfficeName *cbd_asn1_PDU::get_PhysicalDeliveryOfficeName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 68 && !constant)
#else
    if (index == 68)
#endif
	return (PhysicalDeliveryOfficeName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PhysicalDeliveryOfficeNumber(PhysicalDeliveryOfficeNumber & d) {
    index = 69;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PhysicalDeliveryOfficeNumber *cbd_asn1_PDU::get_PhysicalDeliveryOfficeNumber() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 69 && !constant)
#else
    if (index == 69)
#endif
	return (PhysicalDeliveryOfficeNumber *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_ExtensionORAddressComponents(ExtensionORAddressComponents & d) {
    index = 70;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ExtensionORAddressComponents *cbd_asn1_PDU::get_ExtensionORAddressComponents() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 70 && !constant)
#else
    if (index == 70)
#endif
	return (ExtensionORAddressComponents *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PhysicalDeliveryPersonalName(PhysicalDeliveryPersonalName & d) {
    index = 71;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PhysicalDeliveryPersonalName *cbd_asn1_PDU::get_PhysicalDeliveryPersonalName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 71 && !constant)
#else
    if (index == 71)
#endif
	return (PhysicalDeliveryPersonalName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PhysicalDeliveryOrganizationName(PhysicalDeliveryOrganizationName & d) {
    index = 72;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PhysicalDeliveryOrganizationName *cbd_asn1_PDU::get_PhysicalDeliveryOrganizationName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 72 && !constant)
#else
    if (index == 72)
#endif
	return (PhysicalDeliveryOrganizationName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_ExtensionPhysicalDeliveryAddressComponents(ExtensionPhysicalDeliveryAddressComponents & d) {
    index = 73;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ExtensionPhysicalDeliveryAddressComponents *cbd_asn1_PDU::get_ExtensionPhysicalDeliveryAddressComponents() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 73 && !constant)
#else
    if (index == 73)
#endif
	return (ExtensionPhysicalDeliveryAddressComponents *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_UnformattedPostalAddress(UnformattedPostalAddress & d) {
    index = 74;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UnformattedPostalAddress *cbd_asn1_PDU::get_UnformattedPostalAddress() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 74 && !constant)
#else
    if (index == 74)
#endif
	return (UnformattedPostalAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_StreetAddress(StreetAddress & d) {
    index = 75;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

StreetAddress *cbd_asn1_PDU::get_StreetAddress() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 75 && !constant)
#else
    if (index == 75)
#endif
	return (StreetAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PostOfficeBoxAddress(PostOfficeBoxAddress & d) {
    index = 76;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PostOfficeBoxAddress *cbd_asn1_PDU::get_PostOfficeBoxAddress() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 76 && !constant)
#else
    if (index == 76)
#endif
	return (PostOfficeBoxAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PosteRestanteAddress(PosteRestanteAddress & d) {
    index = 77;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PosteRestanteAddress *cbd_asn1_PDU::get_PosteRestanteAddress() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 77 && !constant)
#else
    if (index == 77)
#endif
	return (PosteRestanteAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_UniquePostalName(UniquePostalName & d) {
    index = 78;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UniquePostalName *cbd_asn1_PDU::get_UniquePostalName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 78 && !constant)
#else
    if (index == 78)
#endif
	return (UniquePostalName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_LocalPostalAttributes(LocalPostalAttributes & d) {
    index = 79;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocalPostalAttributes *cbd_asn1_PDU::get_LocalPostalAttributes() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 79 && !constant)
#else
    if (index == 79)
#endif
	return (LocalPostalAttributes *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_ExtendedNetworkAddress(ExtendedNetworkAddress & d) {
    index = 80;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ExtendedNetworkAddress *cbd_asn1_PDU::get_ExtendedNetworkAddress() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 80 && !constant)
#else
    if (index == 80)
#endif
	return (ExtendedNetworkAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TerminalType(TerminalType & d) {
    index = 81;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TerminalType *cbd_asn1_PDU::get_TerminalType() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 81 && !constant)
#else
    if (index == 81)
#endif
	return (TerminalType *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_TeletexDomainDefinedAttributes(TeletexDomainDefinedAttributes & d) {
    index = 82;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TeletexDomainDefinedAttributes *cbd_asn1_PDU::get_TeletexDomainDefinedAttributes() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 82 && !constant)
#else
    if (index == 82)
#endif
	return (TeletexDomainDefinedAttributes *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_AuthPack_OLD(AuthPack_OLD & d) {
    index = 83;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AuthPack_OLD *cbd_asn1_PDU::get_AuthPack_OLD() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 83 && !constant)
#else
    if (index == 83)
#endif
	return (AuthPack_OLD *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE & d) {
    index = 84;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KERB_REPLY_KEY_PACKAGE *cbd_asn1_PDU::get_KERB_REPLY_KEY_PACKAGE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 84 && !constant)
#else
    if (index == 84)
#endif
	return (KERB_REPLY_KEY_PACKAGE *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PA_FOR_USER_ENC(PA_FOR_USER_ENC & d) {
    index = 85;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_FOR_USER_ENC *cbd_asn1_PDU::get_PA_FOR_USER_ENC() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 85 && !constant)
#else
    if (index == 85)
#endif
	return (PA_FOR_USER_ENC *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PA_S4U_X509_USER(PA_S4U_X509_USER & d) {
    index = 86;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_S4U_X509_USER *cbd_asn1_PDU::get_PA_S4U_X509_USER() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 86 && !constant)
#else
    if (index == 86)
#endif
	return (PA_S4U_X509_USER *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PA_PAC_OPTIONS(PA_PAC_OPTIONS & d) {
    index = 87;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_PAC_OPTIONS *cbd_asn1_PDU::get_PA_PAC_OPTIONS() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 87 && !constant)
#else
    if (index == 87)
#endif
	return (PA_PAC_OPTIONS *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KERB_PA_PAC_REQUEST(KERB_PA_PAC_REQUEST & d) {
    index = 88;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KERB_PA_PAC_REQUEST *cbd_asn1_PDU::get_KERB_PA_PAC_REQUEST() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 88 && !constant)
#else
    if (index == 88)
#endif
	return (KERB_PA_PAC_REQUEST *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KERB_LOCAL(KERB_LOCAL & d) {
    index = 89;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KERB_LOCAL *cbd_asn1_PDU::get_KERB_LOCAL() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 89 && !constant)
#else
    if (index == 89)
#endif
	return (KERB_LOCAL *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_KERB_AD_RESTRICTION_ENTRY(KERB_AD_RESTRICTION_ENTRY & d) {
    index = 90;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KERB_AD_RESTRICTION_ENTRY *cbd_asn1_PDU::get_KERB_AD_RESTRICTION_ENTRY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 90 && !constant)
#else
    if (index == 90)
#endif
	return (KERB_AD_RESTRICTION_ENTRY *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_PA_SUPPORTED_ENCTYPES(PA_SUPPORTED_ENCTYPES & d) {
    index = 91;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_SUPPORTED_ENCTYPES *cbd_asn1_PDU::get_PA_SUPPORTED_ENCTYPES() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 91 && !constant)
#else
    if (index == 91)
#endif
	return (PA_SUPPORTED_ENCTYPES *)data;
    else
	return 0;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
void cbd_asn1_PDU::set_const_Ticket(const Ticket & d) {
    index = 1;
    data = (void *)&d;
    constant = 1;
}

const Ticket *cbd_asn1_PDU::get_const_Ticket() const {
    if (index == 1)
	return (const Ticket *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_EncTicketPart(const EncTicketPart & d) {
    index = 2;
    data = (void *)&d;
    constant = 1;
}

const EncTicketPart *cbd_asn1_PDU::get_const_EncTicketPart() const {
    if (index == 2)
	return (const EncTicketPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AS_REQ(const AS_REQ & d) {
    index = 3;
    data = (void *)&d;
    constant = 1;
}

const AS_REQ *cbd_asn1_PDU::get_const_AS_REQ() const {
    if (index == 3)
	return (const AS_REQ *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TGS_REQ(const TGS_REQ & d) {
    index = 4;
    data = (void *)&d;
    constant = 1;
}

const TGS_REQ *cbd_asn1_PDU::get_const_TGS_REQ() const {
    if (index == 4)
	return (const TGS_REQ *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KDC_REQ_BODY(const KDC_REQ_BODY & d) {
    index = 5;
    data = (void *)&d;
    constant = 1;
}

const KDC_REQ_BODY *cbd_asn1_PDU::get_const_KDC_REQ_BODY() const {
    if (index == 5)
	return (const KDC_REQ_BODY *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AS_REP(const AS_REP & d) {
    index = 6;
    data = (void *)&d;
    constant = 1;
}

const AS_REP *cbd_asn1_PDU::get_const_AS_REP() const {
    if (index == 6)
	return (const AS_REP *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TGS_REP(const TGS_REP & d) {
    index = 7;
    data = (void *)&d;
    constant = 1;
}

const TGS_REP *cbd_asn1_PDU::get_const_TGS_REP() const {
    if (index == 7)
	return (const TGS_REP *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_EncASRepPart(const EncASRepPart & d) {
    index = 8;
    data = (void *)&d;
    constant = 1;
}

const EncASRepPart *cbd_asn1_PDU::get_const_EncASRepPart() const {
    if (index == 8)
	return (const EncASRepPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_EncTGSRepPart(const EncTGSRepPart & d) {
    index = 9;
    data = (void *)&d;
    constant = 1;
}

const EncTGSRepPart *cbd_asn1_PDU::get_const_EncTGSRepPart() const {
    if (index == 9)
	return (const EncTGSRepPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AP_REQ(const AP_REQ & d) {
    index = 10;
    data = (void *)&d;
    constant = 1;
}

const AP_REQ *cbd_asn1_PDU::get_const_AP_REQ() const {
    if (index == 10)
	return (const AP_REQ *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_Authenticator(const Authenticator & d) {
    index = 11;
    data = (void *)&d;
    constant = 1;
}

const Authenticator *cbd_asn1_PDU::get_const_Authenticator() const {
    if (index == 11)
	return (const Authenticator *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AP_REP(const AP_REP & d) {
    index = 12;
    data = (void *)&d;
    constant = 1;
}

const AP_REP *cbd_asn1_PDU::get_const_AP_REP() const {
    if (index == 12)
	return (const AP_REP *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_EncAPRepPart(const EncAPRepPart & d) {
    index = 13;
    data = (void *)&d;
    constant = 1;
}

const EncAPRepPart *cbd_asn1_PDU::get_const_EncAPRepPart() const {
    if (index == 13)
	return (const EncAPRepPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KRB_SAFE(const KRB_SAFE & d) {
    index = 14;
    data = (void *)&d;
    constant = 1;
}

const KRB_SAFE *cbd_asn1_PDU::get_const_KRB_SAFE() const {
    if (index == 14)
	return (const KRB_SAFE *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KRB_PRIV(const KRB_PRIV & d) {
    index = 15;
    data = (void *)&d;
    constant = 1;
}

const KRB_PRIV *cbd_asn1_PDU::get_const_KRB_PRIV() const {
    if (index == 15)
	return (const KRB_PRIV *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_EncKrbPrivPart(const EncKrbPrivPart & d) {
    index = 16;
    data = (void *)&d;
    constant = 1;
}

const EncKrbPrivPart *cbd_asn1_PDU::get_const_EncKrbPrivPart() const {
    if (index == 16)
	return (const EncKrbPrivPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KRB_CRED(const KRB_CRED & d) {
    index = 17;
    data = (void *)&d;
    constant = 1;
}

const KRB_CRED *cbd_asn1_PDU::get_const_KRB_CRED() const {
    if (index == 17)
	return (const KRB_CRED *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_EncKrbCredPart(const EncKrbCredPart & d) {
    index = 18;
    data = (void *)&d;
    constant = 1;
}

const EncKrbCredPart *cbd_asn1_PDU::get_const_EncKrbCredPart() const {
    if (index == 18)
	return (const EncKrbCredPart *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KRB_ERROR(const KRB_ERROR & d) {
    index = 19;
    data = (void *)&d;
    constant = 1;
}

const KRB_ERROR *cbd_asn1_PDU::get_const_KRB_ERROR() const {
    if (index == 19)
	return (const KRB_ERROR *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_METHOD_DATA(const METHOD_DATA & d) {
    index = 20;
    data = (void *)&d;
    constant = 1;
}

const METHOD_DATA *cbd_asn1_PDU::get_const_METHOD_DATA() const {
    if (index == 20)
	return (const METHOD_DATA *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TYPED_DATA(const TYPED_DATA & d) {
    index = 21;
    data = (void *)&d;
    constant = 1;
}

const TYPED_DATA *cbd_asn1_PDU::get_const_TYPED_DATA() const {
    if (index == 21)
	return (const TYPED_DATA *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PA_ENC_TIMESTAMP(const PA_ENC_TIMESTAMP & d) {
    index = 22;
    data = (void *)&d;
    constant = 1;
}

const PA_ENC_TIMESTAMP *cbd_asn1_PDU::get_const_PA_ENC_TIMESTAMP() const {
    if (index == 22)
	return (const PA_ENC_TIMESTAMP *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PA_ENC_TS_ENC(const PA_ENC_TS_ENC & d) {
    index = 23;
    data = (void *)&d;
    constant = 1;
}

const PA_ENC_TS_ENC *cbd_asn1_PDU::get_const_PA_ENC_TS_ENC() const {
    if (index == 23)
	return (const PA_ENC_TS_ENC *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_ETYPE_INFO(const ETYPE_INFO & d) {
    index = 24;
    data = (void *)&d;
    constant = 1;
}

const ETYPE_INFO *cbd_asn1_PDU::get_const_ETYPE_INFO() const {
    if (index == 24)
	return (const ETYPE_INFO *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_ETYPE_INFO2(const ETYPE_INFO2 & d) {
    index = 25;
    data = (void *)&d;
    constant = 1;
}

const ETYPE_INFO2 *cbd_asn1_PDU::get_const_ETYPE_INFO2() const {
    if (index == 25)
	return (const ETYPE_INFO2 *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AD_IF_RELEVANT(const AD_IF_RELEVANT & d) {
    index = 26;
    data = (void *)&d;
    constant = 1;
}

const AD_IF_RELEVANT *cbd_asn1_PDU::get_const_AD_IF_RELEVANT() const {
    if (index == 26)
	return (const AD_IF_RELEVANT *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AD_KDCIssued(const AD_KDCIssued & d) {
    index = 27;
    data = (void *)&d;
    constant = 1;
}

const AD_KDCIssued *cbd_asn1_PDU::get_const_AD_KDCIssued() const {
    if (index == 27)
	return (const AD_KDCIssued *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AD_AND_OR(const AD_AND_OR & d) {
    index = 28;
    data = (void *)&d;
    constant = 1;
}

const AD_AND_OR *cbd_asn1_PDU::get_const_AD_AND_OR() const {
    if (index == 28)
	return (const AD_AND_OR *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AD_MANDATORY_FOR_KDC(const AD_MANDATORY_FOR_KDC & d) {
    index = 29;
    data = (void *)&d;
    constant = 1;
}

const AD_MANDATORY_FOR_KDC *cbd_asn1_PDU::get_const_AD_MANDATORY_FOR_KDC() const {
    if (index == 29)
	return (const AD_MANDATORY_FOR_KDC *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_ChangePasswdData(const ChangePasswdData & d) {
    index = 30;
    data = (void *)&d;
    constant = 1;
}

const ChangePasswdData *cbd_asn1_PDU::get_const_ChangePasswdData() const {
    if (index == 30)
	return (const ChangePasswdData *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PA_PK_AS_REQ(const PA_PK_AS_REQ & d) {
    index = 31;
    data = (void *)&d;
    constant = 1;
}

const PA_PK_AS_REQ *cbd_asn1_PDU::get_const_PA_PK_AS_REQ() const {
    if (index == 31)
	return (const PA_PK_AS_REQ *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AuthPack(const AuthPack & d) {
    index = 32;
    data = (void *)&d;
    constant = 1;
}

const AuthPack *cbd_asn1_PDU::get_const_AuthPack() const {
    if (index == 32)
	return (const AuthPack *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TD_TRUSTED_CERTIFIERS(const TD_TRUSTED_CERTIFIERS & d) {
    index = 33;
    data = (void *)&d;
    constant = 1;
}

const TD_TRUSTED_CERTIFIERS *cbd_asn1_PDU::get_const_TD_TRUSTED_CERTIFIERS() const {
    if (index == 33)
	return (const TD_TRUSTED_CERTIFIERS *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TD_INVALID_CERTIFICATES(const TD_INVALID_CERTIFICATES & d) {
    index = 34;
    data = (void *)&d;
    constant = 1;
}

const TD_INVALID_CERTIFICATES *cbd_asn1_PDU::get_const_TD_INVALID_CERTIFICATES() const {
    if (index == 34)
	return (const TD_INVALID_CERTIFICATES *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KRB5PrincipalName(const KRB5PrincipalName & d) {
    index = 35;
    data = (void *)&d;
    constant = 1;
}

const KRB5PrincipalName *cbd_asn1_PDU::get_const_KRB5PrincipalName() const {
    if (index == 35)
	return (const KRB5PrincipalName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AD_INITIAL_VERIFIED_CAS(const AD_INITIAL_VERIFIED_CAS & d) {
    index = 36;
    data = (void *)&d;
    constant = 1;
}

const AD_INITIAL_VERIFIED_CAS *cbd_asn1_PDU::get_const_AD_INITIAL_VERIFIED_CAS() const {
    if (index == 36)
	return (const AD_INITIAL_VERIFIED_CAS *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PA_PK_AS_REP(const PA_PK_AS_REP & d) {
    index = 37;
    data = (void *)&d;
    constant = 1;
}

const PA_PK_AS_REP *cbd_asn1_PDU::get_const_PA_PK_AS_REP() const {
    if (index == 37)
	return (const PA_PK_AS_REP *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KDCDHKeyInfo(const KDCDHKeyInfo & d) {
    index = 38;
    data = (void *)&d;
    constant = 1;
}

const KDCDHKeyInfo *cbd_asn1_PDU::get_const_KDCDHKeyInfo() const {
    if (index == 38)
	return (const KDCDHKeyInfo *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_ReplyKeyPack(const ReplyKeyPack & d) {
    index = 39;
    data = (void *)&d;
    constant = 1;
}

const ReplyKeyPack *cbd_asn1_PDU::get_const_ReplyKeyPack() const {
    if (index == 39)
	return (const ReplyKeyPack *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TD_DH_PARAMETERS(const TD_DH_PARAMETERS & d) {
    index = 40;
    data = (void *)&d;
    constant = 1;
}

const TD_DH_PARAMETERS *cbd_asn1_PDU::get_const_TD_DH_PARAMETERS() const {
    if (index == 40)
	return (const TD_DH_PARAMETERS *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_Attribute(const Attribute & d) {
    index = 41;
    data = (void *)&d;
    constant = 1;
}

const Attribute *cbd_asn1_PDU::get_const_Attribute() const {
    if (index == 41)
	return (const Attribute *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520name(const X520name & d) {
    index = 42;
    data = (void *)&d;
    constant = 1;
}

const X520name *cbd_asn1_PDU::get_const_X520name() const {
    if (index == 42)
	return (const X520name *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520CommonName(const X520CommonName & d) {
    index = 43;
    data = (void *)&d;
    constant = 1;
}

const X520CommonName *cbd_asn1_PDU::get_const_X520CommonName() const {
    if (index == 43)
	return (const X520CommonName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520LocalityName(const X520LocalityName & d) {
    index = 44;
    data = (void *)&d;
    constant = 1;
}

const X520LocalityName *cbd_asn1_PDU::get_const_X520LocalityName() const {
    if (index == 44)
	return (const X520LocalityName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520StateOrProvinceName(const X520StateOrProvinceName & d) {
    index = 45;
    data = (void *)&d;
    constant = 1;
}

const X520StateOrProvinceName *cbd_asn1_PDU::get_const_X520StateOrProvinceName() const {
    if (index == 45)
	return (const X520StateOrProvinceName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520OrganizationName(const X520OrganizationName & d) {
    index = 46;
    data = (void *)&d;
    constant = 1;
}

const X520OrganizationName *cbd_asn1_PDU::get_const_X520OrganizationName() const {
    if (index == 46)
	return (const X520OrganizationName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520OrganizationalUnitName(const X520OrganizationalUnitName & d) {
    index = 47;
    data = (void *)&d;
    constant = 1;
}

const X520OrganizationalUnitName *cbd_asn1_PDU::get_const_X520OrganizationalUnitName() const {
    if (index == 47)
	return (const X520OrganizationalUnitName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520Title(const X520Title & d) {
    index = 48;
    data = (void *)&d;
    constant = 1;
}

const X520Title *cbd_asn1_PDU::get_const_X520Title() const {
    if (index == 48)
	return (const X520Title *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520dnQualifier(const X520dnQualifier & d) {
    index = 49;
    data = (void *)&d;
    constant = 1;
}

const X520dnQualifier *cbd_asn1_PDU::get_const_X520dnQualifier() const {
    if (index == 49)
	return (const X520dnQualifier *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520countryName(const X520countryName & d) {
    index = 50;
    data = (void *)&d;
    constant = 1;
}

const X520countryName *cbd_asn1_PDU::get_const_X520countryName() const {
    if (index == 50)
	return (const X520countryName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520SerialNumber(const X520SerialNumber & d) {
    index = 51;
    data = (void *)&d;
    constant = 1;
}

const X520SerialNumber *cbd_asn1_PDU::get_const_X520SerialNumber() const {
    if (index == 51)
	return (const X520SerialNumber *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_X520Pseudonym(const X520Pseudonym & d) {
    index = 52;
    data = (void *)&d;
    constant = 1;
}

const X520Pseudonym *cbd_asn1_PDU::get_const_X520Pseudonym() const {
    if (index == 52)
	return (const X520Pseudonym *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_DomainComponent(const DomainComponent & d) {
    index = 53;
    data = (void *)&d;
    constant = 1;
}

const DomainComponent *cbd_asn1_PDU::get_const_DomainComponent() const {
    if (index == 53)
	return (const DomainComponent *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_EmailAddress(const EmailAddress & d) {
    index = 54;
    data = (void *)&d;
    constant = 1;
}

const EmailAddress *cbd_asn1_PDU::get_const_EmailAddress() const {
    if (index == 54)
	return (const EmailAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_DistinguishedName(const DistinguishedName & d) {
    index = 55;
    data = (void *)&d;
    constant = 1;
}

const DistinguishedName *cbd_asn1_PDU::get_const_DistinguishedName() const {
    if (index == 55)
	return (const DistinguishedName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_DirectoryString(const DirectoryString & d) {
    index = 56;
    data = (void *)&d;
    constant = 1;
}

const DirectoryString *cbd_asn1_PDU::get_const_DirectoryString() const {
    if (index == 56)
	return (const DirectoryString *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_Certificate(const Certificate & d) {
    index = 57;
    data = (void *)&d;
    constant = 1;
}

const Certificate *cbd_asn1_PDU::get_const_Certificate() const {
    if (index == 57)
	return (const Certificate *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_CertificateList(const CertificateList & d) {
    index = 58;
    data = (void *)&d;
    constant = 1;
}

const CertificateList *cbd_asn1_PDU::get_const_CertificateList() const {
    if (index == 58)
	return (const CertificateList *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_ORAddress(const ORAddress & d) {
    index = 59;
    data = (void *)&d;
    constant = 1;
}

const ORAddress *cbd_asn1_PDU::get_const_ORAddress() const {
    if (index == 59)
	return (const ORAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_CommonName(const CommonName & d) {
    index = 60;
    data = (void *)&d;
    constant = 1;
}

const CommonName *cbd_asn1_PDU::get_const_CommonName() const {
    if (index == 60)
	return (const CommonName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TeletexCommonName(const TeletexCommonName & d) {
    index = 61;
    data = (void *)&d;
    constant = 1;
}

const TeletexCommonName *cbd_asn1_PDU::get_const_TeletexCommonName() const {
    if (index == 61)
	return (const TeletexCommonName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TeletexOrganizationName(const TeletexOrganizationName & d) {
    index = 62;
    data = (void *)&d;
    constant = 1;
}

const TeletexOrganizationName *cbd_asn1_PDU::get_const_TeletexOrganizationName() const {
    if (index == 62)
	return (const TeletexOrganizationName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TeletexPersonalName(const TeletexPersonalName & d) {
    index = 63;
    data = (void *)&d;
    constant = 1;
}

const TeletexPersonalName *cbd_asn1_PDU::get_const_TeletexPersonalName() const {
    if (index == 63)
	return (const TeletexPersonalName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TeletexOrganizationalUnitNames(const TeletexOrganizationalUnitNames & d) {
    index = 64;
    data = (void *)&d;
    constant = 1;
}

const TeletexOrganizationalUnitNames *cbd_asn1_PDU::get_const_TeletexOrganizationalUnitNames() const {
    if (index == 64)
	return (const TeletexOrganizationalUnitNames *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PDSName(const PDSName & d) {
    index = 65;
    data = (void *)&d;
    constant = 1;
}

const PDSName *cbd_asn1_PDU::get_const_PDSName() const {
    if (index == 65)
	return (const PDSName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PhysicalDeliveryCountryName(const PhysicalDeliveryCountryName & d) {
    index = 66;
    data = (void *)&d;
    constant = 1;
}

const PhysicalDeliveryCountryName *cbd_asn1_PDU::get_const_PhysicalDeliveryCountryName() const {
    if (index == 66)
	return (const PhysicalDeliveryCountryName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PostalCode(const PostalCode & d) {
    index = 67;
    data = (void *)&d;
    constant = 1;
}

const PostalCode *cbd_asn1_PDU::get_const_PostalCode() const {
    if (index == 67)
	return (const PostalCode *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PhysicalDeliveryOfficeName(const PhysicalDeliveryOfficeName & d) {
    index = 68;
    data = (void *)&d;
    constant = 1;
}

const PhysicalDeliveryOfficeName *cbd_asn1_PDU::get_const_PhysicalDeliveryOfficeName() const {
    if (index == 68)
	return (const PhysicalDeliveryOfficeName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PhysicalDeliveryOfficeNumber(const PhysicalDeliveryOfficeNumber & d) {
    index = 69;
    data = (void *)&d;
    constant = 1;
}

const PhysicalDeliveryOfficeNumber *cbd_asn1_PDU::get_const_PhysicalDeliveryOfficeNumber() const {
    if (index == 69)
	return (const PhysicalDeliveryOfficeNumber *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_ExtensionORAddressComponents(const ExtensionORAddressComponents & d) {
    index = 70;
    data = (void *)&d;
    constant = 1;
}

const ExtensionORAddressComponents *cbd_asn1_PDU::get_const_ExtensionORAddressComponents() const {
    if (index == 70)
	return (const ExtensionORAddressComponents *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PhysicalDeliveryPersonalName(const PhysicalDeliveryPersonalName & d) {
    index = 71;
    data = (void *)&d;
    constant = 1;
}

const PhysicalDeliveryPersonalName *cbd_asn1_PDU::get_const_PhysicalDeliveryPersonalName() const {
    if (index == 71)
	return (const PhysicalDeliveryPersonalName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PhysicalDeliveryOrganizationName(const PhysicalDeliveryOrganizationName & d) {
    index = 72;
    data = (void *)&d;
    constant = 1;
}

const PhysicalDeliveryOrganizationName *cbd_asn1_PDU::get_const_PhysicalDeliveryOrganizationName() const {
    if (index == 72)
	return (const PhysicalDeliveryOrganizationName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_ExtensionPhysicalDeliveryAddressComponents(const ExtensionPhysicalDeliveryAddressComponents & d) {
    index = 73;
    data = (void *)&d;
    constant = 1;
}

const ExtensionPhysicalDeliveryAddressComponents *cbd_asn1_PDU::get_const_ExtensionPhysicalDeliveryAddressComponents() const {
    if (index == 73)
	return (const ExtensionPhysicalDeliveryAddressComponents *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_UnformattedPostalAddress(const UnformattedPostalAddress & d) {
    index = 74;
    data = (void *)&d;
    constant = 1;
}

const UnformattedPostalAddress *cbd_asn1_PDU::get_const_UnformattedPostalAddress() const {
    if (index == 74)
	return (const UnformattedPostalAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_StreetAddress(const StreetAddress & d) {
    index = 75;
    data = (void *)&d;
    constant = 1;
}

const StreetAddress *cbd_asn1_PDU::get_const_StreetAddress() const {
    if (index == 75)
	return (const StreetAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PostOfficeBoxAddress(const PostOfficeBoxAddress & d) {
    index = 76;
    data = (void *)&d;
    constant = 1;
}

const PostOfficeBoxAddress *cbd_asn1_PDU::get_const_PostOfficeBoxAddress() const {
    if (index == 76)
	return (const PostOfficeBoxAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PosteRestanteAddress(const PosteRestanteAddress & d) {
    index = 77;
    data = (void *)&d;
    constant = 1;
}

const PosteRestanteAddress *cbd_asn1_PDU::get_const_PosteRestanteAddress() const {
    if (index == 77)
	return (const PosteRestanteAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_UniquePostalName(const UniquePostalName & d) {
    index = 78;
    data = (void *)&d;
    constant = 1;
}

const UniquePostalName *cbd_asn1_PDU::get_const_UniquePostalName() const {
    if (index == 78)
	return (const UniquePostalName *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_LocalPostalAttributes(const LocalPostalAttributes & d) {
    index = 79;
    data = (void *)&d;
    constant = 1;
}

const LocalPostalAttributes *cbd_asn1_PDU::get_const_LocalPostalAttributes() const {
    if (index == 79)
	return (const LocalPostalAttributes *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_ExtendedNetworkAddress(const ExtendedNetworkAddress & d) {
    index = 80;
    data = (void *)&d;
    constant = 1;
}

const ExtendedNetworkAddress *cbd_asn1_PDU::get_const_ExtendedNetworkAddress() const {
    if (index == 80)
	return (const ExtendedNetworkAddress *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TerminalType(const TerminalType & d) {
    index = 81;
    data = (void *)&d;
    constant = 1;
}

const TerminalType *cbd_asn1_PDU::get_const_TerminalType() const {
    if (index == 81)
	return (const TerminalType *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_TeletexDomainDefinedAttributes(const TeletexDomainDefinedAttributes & d) {
    index = 82;
    data = (void *)&d;
    constant = 1;
}

const TeletexDomainDefinedAttributes *cbd_asn1_PDU::get_const_TeletexDomainDefinedAttributes() const {
    if (index == 82)
	return (const TeletexDomainDefinedAttributes *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_AuthPack_OLD(const AuthPack_OLD & d) {
    index = 83;
    data = (void *)&d;
    constant = 1;
}

const AuthPack_OLD *cbd_asn1_PDU::get_const_AuthPack_OLD() const {
    if (index == 83)
	return (const AuthPack_OLD *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KERB_REPLY_KEY_PACKAGE(const KERB_REPLY_KEY_PACKAGE & d) {
    index = 84;
    data = (void *)&d;
    constant = 1;
}

const KERB_REPLY_KEY_PACKAGE *cbd_asn1_PDU::get_const_KERB_REPLY_KEY_PACKAGE() const {
    if (index == 84)
	return (const KERB_REPLY_KEY_PACKAGE *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PA_FOR_USER_ENC(const PA_FOR_USER_ENC & d) {
    index = 85;
    data = (void *)&d;
    constant = 1;
}

const PA_FOR_USER_ENC *cbd_asn1_PDU::get_const_PA_FOR_USER_ENC() const {
    if (index == 85)
	return (const PA_FOR_USER_ENC *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PA_S4U_X509_USER(const PA_S4U_X509_USER & d) {
    index = 86;
    data = (void *)&d;
    constant = 1;
}

const PA_S4U_X509_USER *cbd_asn1_PDU::get_const_PA_S4U_X509_USER() const {
    if (index == 86)
	return (const PA_S4U_X509_USER *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PA_PAC_OPTIONS(const PA_PAC_OPTIONS & d) {
    index = 87;
    data = (void *)&d;
    constant = 1;
}

const PA_PAC_OPTIONS *cbd_asn1_PDU::get_const_PA_PAC_OPTIONS() const {
    if (index == 87)
	return (const PA_PAC_OPTIONS *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KERB_PA_PAC_REQUEST(const KERB_PA_PAC_REQUEST & d) {
    index = 88;
    data = (void *)&d;
    constant = 1;
}

const KERB_PA_PAC_REQUEST *cbd_asn1_PDU::get_const_KERB_PA_PAC_REQUEST() const {
    if (index == 88)
	return (const KERB_PA_PAC_REQUEST *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KERB_LOCAL(const KERB_LOCAL & d) {
    index = 89;
    data = (void *)&d;
    constant = 1;
}

const KERB_LOCAL *cbd_asn1_PDU::get_const_KERB_LOCAL() const {
    if (index == 89)
	return (const KERB_LOCAL *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_KERB_AD_RESTRICTION_ENTRY(const KERB_AD_RESTRICTION_ENTRY & d) {
    index = 90;
    data = (void *)&d;
    constant = 1;
}

const KERB_AD_RESTRICTION_ENTRY *cbd_asn1_PDU::get_const_KERB_AD_RESTRICTION_ENTRY() const {
    if (index == 90)
	return (const KERB_AD_RESTRICTION_ENTRY *)data;
    else
	return 0;
}

void cbd_asn1_PDU::set_const_PA_SUPPORTED_ENCTYPES(const PA_SUPPORTED_ENCTYPES & d) {
    index = 91;
    data = (void *)&d;
    constant = 1;
}

const PA_SUPPORTED_ENCTYPES *cbd_asn1_PDU::get_const_PA_SUPPORTED_ENCTYPES() const {
    if (index == 91)
	return (const PA_SUPPORTED_ENCTYPES *)data;
    else
	return 0;
}

#endif
/* Specific PDU classes */

Ticket_PDU::Ticket_PDU() {
}

void Ticket_PDU::set_data(Ticket & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Ticket *Ticket_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Ticket *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Ticket_PDU::set_const_data(const Ticket & d) {
    data = (void *)&d;
    constant = 1;
}

const Ticket *Ticket_PDU::get_const_data() const {
    return (const Ticket *)data;
}

#endif

OssTypeIndex Ticket_PDU::get_index() const {
    return 1;
}

EncTicketPart_PDU::EncTicketPart_PDU() {
}

void EncTicketPart_PDU::set_data(EncTicketPart & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncTicketPart *EncTicketPart_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EncTicketPart *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EncTicketPart_PDU::set_const_data(const EncTicketPart & d) {
    data = (void *)&d;
    constant = 1;
}

const EncTicketPart *EncTicketPart_PDU::get_const_data() const {
    return (const EncTicketPart *)data;
}

#endif

OssTypeIndex EncTicketPart_PDU::get_index() const {
    return 2;
}

AS_REQ_PDU::AS_REQ_PDU() {
}

void AS_REQ_PDU::set_data(AS_REQ & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AS_REQ *AS_REQ_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AS_REQ *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AS_REQ_PDU::set_const_data(const AS_REQ & d) {
    data = (void *)&d;
    constant = 1;
}

const AS_REQ *AS_REQ_PDU::get_const_data() const {
    return (const AS_REQ *)data;
}

#endif

OssTypeIndex AS_REQ_PDU::get_index() const {
    return 3;
}

TGS_REQ_PDU::TGS_REQ_PDU() {
}

void TGS_REQ_PDU::set_data(TGS_REQ & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TGS_REQ *TGS_REQ_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TGS_REQ *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TGS_REQ_PDU::set_const_data(const TGS_REQ & d) {
    data = (void *)&d;
    constant = 1;
}

const TGS_REQ *TGS_REQ_PDU::get_const_data() const {
    return (const TGS_REQ *)data;
}

#endif

OssTypeIndex TGS_REQ_PDU::get_index() const {
    return 4;
}

KDC_REQ_BODY_PDU::KDC_REQ_BODY_PDU() {
}

void KDC_REQ_BODY_PDU::set_data(KDC_REQ_BODY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KDC_REQ_BODY *KDC_REQ_BODY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KDC_REQ_BODY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KDC_REQ_BODY_PDU::set_const_data(const KDC_REQ_BODY & d) {
    data = (void *)&d;
    constant = 1;
}

const KDC_REQ_BODY *KDC_REQ_BODY_PDU::get_const_data() const {
    return (const KDC_REQ_BODY *)data;
}

#endif

OssTypeIndex KDC_REQ_BODY_PDU::get_index() const {
    return 5;
}

AS_REP_PDU::AS_REP_PDU() {
}

void AS_REP_PDU::set_data(AS_REP & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AS_REP *AS_REP_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AS_REP *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AS_REP_PDU::set_const_data(const AS_REP & d) {
    data = (void *)&d;
    constant = 1;
}

const AS_REP *AS_REP_PDU::get_const_data() const {
    return (const AS_REP *)data;
}

#endif

OssTypeIndex AS_REP_PDU::get_index() const {
    return 6;
}

TGS_REP_PDU::TGS_REP_PDU() {
}

void TGS_REP_PDU::set_data(TGS_REP & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TGS_REP *TGS_REP_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TGS_REP *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TGS_REP_PDU::set_const_data(const TGS_REP & d) {
    data = (void *)&d;
    constant = 1;
}

const TGS_REP *TGS_REP_PDU::get_const_data() const {
    return (const TGS_REP *)data;
}

#endif

OssTypeIndex TGS_REP_PDU::get_index() const {
    return 7;
}

EncASRepPart_PDU::EncASRepPart_PDU() {
}

void EncASRepPart_PDU::set_data(EncASRepPart & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncASRepPart *EncASRepPart_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EncASRepPart *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EncASRepPart_PDU::set_const_data(const EncASRepPart & d) {
    data = (void *)&d;
    constant = 1;
}

const EncASRepPart *EncASRepPart_PDU::get_const_data() const {
    return (const EncASRepPart *)data;
}

#endif

OssTypeIndex EncASRepPart_PDU::get_index() const {
    return 8;
}

EncTGSRepPart_PDU::EncTGSRepPart_PDU() {
}

void EncTGSRepPart_PDU::set_data(EncTGSRepPart & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncTGSRepPart *EncTGSRepPart_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EncTGSRepPart *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EncTGSRepPart_PDU::set_const_data(const EncTGSRepPart & d) {
    data = (void *)&d;
    constant = 1;
}

const EncTGSRepPart *EncTGSRepPart_PDU::get_const_data() const {
    return (const EncTGSRepPart *)data;
}

#endif

OssTypeIndex EncTGSRepPart_PDU::get_index() const {
    return 9;
}

AP_REQ_PDU::AP_REQ_PDU() {
}

void AP_REQ_PDU::set_data(AP_REQ & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AP_REQ *AP_REQ_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AP_REQ *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AP_REQ_PDU::set_const_data(const AP_REQ & d) {
    data = (void *)&d;
    constant = 1;
}

const AP_REQ *AP_REQ_PDU::get_const_data() const {
    return (const AP_REQ *)data;
}

#endif

OssTypeIndex AP_REQ_PDU::get_index() const {
    return 10;
}

Authenticator_PDU::Authenticator_PDU() {
}

void Authenticator_PDU::set_data(Authenticator & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Authenticator *Authenticator_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Authenticator *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Authenticator_PDU::set_const_data(const Authenticator & d) {
    data = (void *)&d;
    constant = 1;
}

const Authenticator *Authenticator_PDU::get_const_data() const {
    return (const Authenticator *)data;
}

#endif

OssTypeIndex Authenticator_PDU::get_index() const {
    return 11;
}

AP_REP_PDU::AP_REP_PDU() {
}

void AP_REP_PDU::set_data(AP_REP & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AP_REP *AP_REP_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AP_REP *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AP_REP_PDU::set_const_data(const AP_REP & d) {
    data = (void *)&d;
    constant = 1;
}

const AP_REP *AP_REP_PDU::get_const_data() const {
    return (const AP_REP *)data;
}

#endif

OssTypeIndex AP_REP_PDU::get_index() const {
    return 12;
}

EncAPRepPart_PDU::EncAPRepPart_PDU() {
}

void EncAPRepPart_PDU::set_data(EncAPRepPart & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncAPRepPart *EncAPRepPart_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EncAPRepPart *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EncAPRepPart_PDU::set_const_data(const EncAPRepPart & d) {
    data = (void *)&d;
    constant = 1;
}

const EncAPRepPart *EncAPRepPart_PDU::get_const_data() const {
    return (const EncAPRepPart *)data;
}

#endif

OssTypeIndex EncAPRepPart_PDU::get_index() const {
    return 13;
}

KRB_SAFE_PDU::KRB_SAFE_PDU() {
}

void KRB_SAFE_PDU::set_data(KRB_SAFE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KRB_SAFE *KRB_SAFE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KRB_SAFE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KRB_SAFE_PDU::set_const_data(const KRB_SAFE & d) {
    data = (void *)&d;
    constant = 1;
}

const KRB_SAFE *KRB_SAFE_PDU::get_const_data() const {
    return (const KRB_SAFE *)data;
}

#endif

OssTypeIndex KRB_SAFE_PDU::get_index() const {
    return 14;
}

KRB_PRIV_PDU::KRB_PRIV_PDU() {
}

void KRB_PRIV_PDU::set_data(KRB_PRIV & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KRB_PRIV *KRB_PRIV_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KRB_PRIV *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KRB_PRIV_PDU::set_const_data(const KRB_PRIV & d) {
    data = (void *)&d;
    constant = 1;
}

const KRB_PRIV *KRB_PRIV_PDU::get_const_data() const {
    return (const KRB_PRIV *)data;
}

#endif

OssTypeIndex KRB_PRIV_PDU::get_index() const {
    return 15;
}

EncKrbPrivPart_PDU::EncKrbPrivPart_PDU() {
}

void EncKrbPrivPart_PDU::set_data(EncKrbPrivPart & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncKrbPrivPart *EncKrbPrivPart_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EncKrbPrivPart *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EncKrbPrivPart_PDU::set_const_data(const EncKrbPrivPart & d) {
    data = (void *)&d;
    constant = 1;
}

const EncKrbPrivPart *EncKrbPrivPart_PDU::get_const_data() const {
    return (const EncKrbPrivPart *)data;
}

#endif

OssTypeIndex EncKrbPrivPart_PDU::get_index() const {
    return 16;
}

KRB_CRED_PDU::KRB_CRED_PDU() {
}

void KRB_CRED_PDU::set_data(KRB_CRED & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KRB_CRED *KRB_CRED_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KRB_CRED *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KRB_CRED_PDU::set_const_data(const KRB_CRED & d) {
    data = (void *)&d;
    constant = 1;
}

const KRB_CRED *KRB_CRED_PDU::get_const_data() const {
    return (const KRB_CRED *)data;
}

#endif

OssTypeIndex KRB_CRED_PDU::get_index() const {
    return 17;
}

EncKrbCredPart_PDU::EncKrbCredPart_PDU() {
}

void EncKrbCredPart_PDU::set_data(EncKrbCredPart & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EncKrbCredPart *EncKrbCredPart_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EncKrbCredPart *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EncKrbCredPart_PDU::set_const_data(const EncKrbCredPart & d) {
    data = (void *)&d;
    constant = 1;
}

const EncKrbCredPart *EncKrbCredPart_PDU::get_const_data() const {
    return (const EncKrbCredPart *)data;
}

#endif

OssTypeIndex EncKrbCredPart_PDU::get_index() const {
    return 18;
}

KRB_ERROR_PDU::KRB_ERROR_PDU() {
}

void KRB_ERROR_PDU::set_data(KRB_ERROR & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KRB_ERROR *KRB_ERROR_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KRB_ERROR *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KRB_ERROR_PDU::set_const_data(const KRB_ERROR & d) {
    data = (void *)&d;
    constant = 1;
}

const KRB_ERROR *KRB_ERROR_PDU::get_const_data() const {
    return (const KRB_ERROR *)data;
}

#endif

OssTypeIndex KRB_ERROR_PDU::get_index() const {
    return 19;
}

METHOD_DATA_PDU::METHOD_DATA_PDU() {
}

void METHOD_DATA_PDU::set_data(METHOD_DATA & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

METHOD_DATA *METHOD_DATA_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (METHOD_DATA *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void METHOD_DATA_PDU::set_const_data(const METHOD_DATA & d) {
    data = (void *)&d;
    constant = 1;
}

const METHOD_DATA *METHOD_DATA_PDU::get_const_data() const {
    return (const METHOD_DATA *)data;
}

#endif

OssTypeIndex METHOD_DATA_PDU::get_index() const {
    return 20;
}

TYPED_DATA_PDU::TYPED_DATA_PDU() {
}

void TYPED_DATA_PDU::set_data(TYPED_DATA & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TYPED_DATA *TYPED_DATA_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TYPED_DATA *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TYPED_DATA_PDU::set_const_data(const TYPED_DATA & d) {
    data = (void *)&d;
    constant = 1;
}

const TYPED_DATA *TYPED_DATA_PDU::get_const_data() const {
    return (const TYPED_DATA *)data;
}

#endif

OssTypeIndex TYPED_DATA_PDU::get_index() const {
    return 21;
}

PA_ENC_TIMESTAMP_PDU::PA_ENC_TIMESTAMP_PDU() {
}

void PA_ENC_TIMESTAMP_PDU::set_data(PA_ENC_TIMESTAMP & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_ENC_TIMESTAMP *PA_ENC_TIMESTAMP_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PA_ENC_TIMESTAMP *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PA_ENC_TIMESTAMP_PDU::set_const_data(const PA_ENC_TIMESTAMP & d) {
    data = (void *)&d;
    constant = 1;
}

const PA_ENC_TIMESTAMP *PA_ENC_TIMESTAMP_PDU::get_const_data() const {
    return (const PA_ENC_TIMESTAMP *)data;
}

#endif

OssTypeIndex PA_ENC_TIMESTAMP_PDU::get_index() const {
    return 22;
}

PA_ENC_TS_ENC_PDU::PA_ENC_TS_ENC_PDU() {
}

void PA_ENC_TS_ENC_PDU::set_data(PA_ENC_TS_ENC & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_ENC_TS_ENC *PA_ENC_TS_ENC_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PA_ENC_TS_ENC *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PA_ENC_TS_ENC_PDU::set_const_data(const PA_ENC_TS_ENC & d) {
    data = (void *)&d;
    constant = 1;
}

const PA_ENC_TS_ENC *PA_ENC_TS_ENC_PDU::get_const_data() const {
    return (const PA_ENC_TS_ENC *)data;
}

#endif

OssTypeIndex PA_ENC_TS_ENC_PDU::get_index() const {
    return 23;
}

ETYPE_INFO_PDU::ETYPE_INFO_PDU() {
}

void ETYPE_INFO_PDU::set_data(ETYPE_INFO & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ETYPE_INFO *ETYPE_INFO_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ETYPE_INFO *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ETYPE_INFO_PDU::set_const_data(const ETYPE_INFO & d) {
    data = (void *)&d;
    constant = 1;
}

const ETYPE_INFO *ETYPE_INFO_PDU::get_const_data() const {
    return (const ETYPE_INFO *)data;
}

#endif

OssTypeIndex ETYPE_INFO_PDU::get_index() const {
    return 24;
}

ETYPE_INFO2_PDU::ETYPE_INFO2_PDU() {
}

void ETYPE_INFO2_PDU::set_data(ETYPE_INFO2 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ETYPE_INFO2 *ETYPE_INFO2_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ETYPE_INFO2 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ETYPE_INFO2_PDU::set_const_data(const ETYPE_INFO2 & d) {
    data = (void *)&d;
    constant = 1;
}

const ETYPE_INFO2 *ETYPE_INFO2_PDU::get_const_data() const {
    return (const ETYPE_INFO2 *)data;
}

#endif

OssTypeIndex ETYPE_INFO2_PDU::get_index() const {
    return 25;
}

AD_IF_RELEVANT_PDU::AD_IF_RELEVANT_PDU() {
}

void AD_IF_RELEVANT_PDU::set_data(AD_IF_RELEVANT & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AD_IF_RELEVANT *AD_IF_RELEVANT_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AD_IF_RELEVANT *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AD_IF_RELEVANT_PDU::set_const_data(const AD_IF_RELEVANT & d) {
    data = (void *)&d;
    constant = 1;
}

const AD_IF_RELEVANT *AD_IF_RELEVANT_PDU::get_const_data() const {
    return (const AD_IF_RELEVANT *)data;
}

#endif

OssTypeIndex AD_IF_RELEVANT_PDU::get_index() const {
    return 26;
}

AD_KDCIssued_PDU::AD_KDCIssued_PDU() {
}

void AD_KDCIssued_PDU::set_data(AD_KDCIssued & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AD_KDCIssued *AD_KDCIssued_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AD_KDCIssued *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AD_KDCIssued_PDU::set_const_data(const AD_KDCIssued & d) {
    data = (void *)&d;
    constant = 1;
}

const AD_KDCIssued *AD_KDCIssued_PDU::get_const_data() const {
    return (const AD_KDCIssued *)data;
}

#endif

OssTypeIndex AD_KDCIssued_PDU::get_index() const {
    return 27;
}

AD_AND_OR_PDU::AD_AND_OR_PDU() {
}

void AD_AND_OR_PDU::set_data(AD_AND_OR & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AD_AND_OR *AD_AND_OR_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AD_AND_OR *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AD_AND_OR_PDU::set_const_data(const AD_AND_OR & d) {
    data = (void *)&d;
    constant = 1;
}

const AD_AND_OR *AD_AND_OR_PDU::get_const_data() const {
    return (const AD_AND_OR *)data;
}

#endif

OssTypeIndex AD_AND_OR_PDU::get_index() const {
    return 28;
}

AD_MANDATORY_FOR_KDC_PDU::AD_MANDATORY_FOR_KDC_PDU() {
}

void AD_MANDATORY_FOR_KDC_PDU::set_data(AD_MANDATORY_FOR_KDC & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AD_MANDATORY_FOR_KDC *AD_MANDATORY_FOR_KDC_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AD_MANDATORY_FOR_KDC *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AD_MANDATORY_FOR_KDC_PDU::set_const_data(const AD_MANDATORY_FOR_KDC & d) {
    data = (void *)&d;
    constant = 1;
}

const AD_MANDATORY_FOR_KDC *AD_MANDATORY_FOR_KDC_PDU::get_const_data() const {
    return (const AD_MANDATORY_FOR_KDC *)data;
}

#endif

OssTypeIndex AD_MANDATORY_FOR_KDC_PDU::get_index() const {
    return 29;
}

ChangePasswdData_PDU::ChangePasswdData_PDU() {
}

void ChangePasswdData_PDU::set_data(ChangePasswdData & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ChangePasswdData *ChangePasswdData_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ChangePasswdData *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ChangePasswdData_PDU::set_const_data(const ChangePasswdData & d) {
    data = (void *)&d;
    constant = 1;
}

const ChangePasswdData *ChangePasswdData_PDU::get_const_data() const {
    return (const ChangePasswdData *)data;
}

#endif

OssTypeIndex ChangePasswdData_PDU::get_index() const {
    return 30;
}

PA_PK_AS_REQ_PDU::PA_PK_AS_REQ_PDU() {
}

void PA_PK_AS_REQ_PDU::set_data(PA_PK_AS_REQ & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_PK_AS_REQ *PA_PK_AS_REQ_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PA_PK_AS_REQ *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PA_PK_AS_REQ_PDU::set_const_data(const PA_PK_AS_REQ & d) {
    data = (void *)&d;
    constant = 1;
}

const PA_PK_AS_REQ *PA_PK_AS_REQ_PDU::get_const_data() const {
    return (const PA_PK_AS_REQ *)data;
}

#endif

OssTypeIndex PA_PK_AS_REQ_PDU::get_index() const {
    return 31;
}

AuthPack_PDU::AuthPack_PDU() {
}

void AuthPack_PDU::set_data(AuthPack & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AuthPack *AuthPack_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AuthPack *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AuthPack_PDU::set_const_data(const AuthPack & d) {
    data = (void *)&d;
    constant = 1;
}

const AuthPack *AuthPack_PDU::get_const_data() const {
    return (const AuthPack *)data;
}

#endif

OssTypeIndex AuthPack_PDU::get_index() const {
    return 32;
}

TD_TRUSTED_CERTIFIERS_PDU::TD_TRUSTED_CERTIFIERS_PDU() {
}

void TD_TRUSTED_CERTIFIERS_PDU::set_data(TD_TRUSTED_CERTIFIERS & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TD_TRUSTED_CERTIFIERS *TD_TRUSTED_CERTIFIERS_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TD_TRUSTED_CERTIFIERS *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TD_TRUSTED_CERTIFIERS_PDU::set_const_data(const TD_TRUSTED_CERTIFIERS & d) {
    data = (void *)&d;
    constant = 1;
}

const TD_TRUSTED_CERTIFIERS *TD_TRUSTED_CERTIFIERS_PDU::get_const_data() const {
    return (const TD_TRUSTED_CERTIFIERS *)data;
}

#endif

OssTypeIndex TD_TRUSTED_CERTIFIERS_PDU::get_index() const {
    return 33;
}

TD_INVALID_CERTIFICATES_PDU::TD_INVALID_CERTIFICATES_PDU() {
}

void TD_INVALID_CERTIFICATES_PDU::set_data(TD_INVALID_CERTIFICATES & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TD_INVALID_CERTIFICATES *TD_INVALID_CERTIFICATES_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TD_INVALID_CERTIFICATES *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TD_INVALID_CERTIFICATES_PDU::set_const_data(const TD_INVALID_CERTIFICATES & d) {
    data = (void *)&d;
    constant = 1;
}

const TD_INVALID_CERTIFICATES *TD_INVALID_CERTIFICATES_PDU::get_const_data() const {
    return (const TD_INVALID_CERTIFICATES *)data;
}

#endif

OssTypeIndex TD_INVALID_CERTIFICATES_PDU::get_index() const {
    return 34;
}

KRB5PrincipalName_PDU::KRB5PrincipalName_PDU() {
}

void KRB5PrincipalName_PDU::set_data(KRB5PrincipalName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KRB5PrincipalName *KRB5PrincipalName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KRB5PrincipalName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KRB5PrincipalName_PDU::set_const_data(const KRB5PrincipalName & d) {
    data = (void *)&d;
    constant = 1;
}

const KRB5PrincipalName *KRB5PrincipalName_PDU::get_const_data() const {
    return (const KRB5PrincipalName *)data;
}

#endif

OssTypeIndex KRB5PrincipalName_PDU::get_index() const {
    return 35;
}

AD_INITIAL_VERIFIED_CAS_PDU::AD_INITIAL_VERIFIED_CAS_PDU() {
}

void AD_INITIAL_VERIFIED_CAS_PDU::set_data(AD_INITIAL_VERIFIED_CAS & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AD_INITIAL_VERIFIED_CAS *AD_INITIAL_VERIFIED_CAS_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AD_INITIAL_VERIFIED_CAS *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AD_INITIAL_VERIFIED_CAS_PDU::set_const_data(const AD_INITIAL_VERIFIED_CAS & d) {
    data = (void *)&d;
    constant = 1;
}

const AD_INITIAL_VERIFIED_CAS *AD_INITIAL_VERIFIED_CAS_PDU::get_const_data() const {
    return (const AD_INITIAL_VERIFIED_CAS *)data;
}

#endif

OssTypeIndex AD_INITIAL_VERIFIED_CAS_PDU::get_index() const {
    return 36;
}

PA_PK_AS_REP_PDU::PA_PK_AS_REP_PDU() {
}

void PA_PK_AS_REP_PDU::set_data(PA_PK_AS_REP & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_PK_AS_REP *PA_PK_AS_REP_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PA_PK_AS_REP *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PA_PK_AS_REP_PDU::set_const_data(const PA_PK_AS_REP & d) {
    data = (void *)&d;
    constant = 1;
}

const PA_PK_AS_REP *PA_PK_AS_REP_PDU::get_const_data() const {
    return (const PA_PK_AS_REP *)data;
}

#endif

OssTypeIndex PA_PK_AS_REP_PDU::get_index() const {
    return 37;
}

KDCDHKeyInfo_PDU::KDCDHKeyInfo_PDU() {
}

void KDCDHKeyInfo_PDU::set_data(KDCDHKeyInfo & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KDCDHKeyInfo *KDCDHKeyInfo_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KDCDHKeyInfo *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KDCDHKeyInfo_PDU::set_const_data(const KDCDHKeyInfo & d) {
    data = (void *)&d;
    constant = 1;
}

const KDCDHKeyInfo *KDCDHKeyInfo_PDU::get_const_data() const {
    return (const KDCDHKeyInfo *)data;
}

#endif

OssTypeIndex KDCDHKeyInfo_PDU::get_index() const {
    return 38;
}

ReplyKeyPack_PDU::ReplyKeyPack_PDU() {
}

void ReplyKeyPack_PDU::set_data(ReplyKeyPack & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ReplyKeyPack *ReplyKeyPack_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ReplyKeyPack *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ReplyKeyPack_PDU::set_const_data(const ReplyKeyPack & d) {
    data = (void *)&d;
    constant = 1;
}

const ReplyKeyPack *ReplyKeyPack_PDU::get_const_data() const {
    return (const ReplyKeyPack *)data;
}

#endif

OssTypeIndex ReplyKeyPack_PDU::get_index() const {
    return 39;
}

TD_DH_PARAMETERS_PDU::TD_DH_PARAMETERS_PDU() {
}

void TD_DH_PARAMETERS_PDU::set_data(TD_DH_PARAMETERS & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TD_DH_PARAMETERS *TD_DH_PARAMETERS_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TD_DH_PARAMETERS *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TD_DH_PARAMETERS_PDU::set_const_data(const TD_DH_PARAMETERS & d) {
    data = (void *)&d;
    constant = 1;
}

const TD_DH_PARAMETERS *TD_DH_PARAMETERS_PDU::get_const_data() const {
    return (const TD_DH_PARAMETERS *)data;
}

#endif

OssTypeIndex TD_DH_PARAMETERS_PDU::get_index() const {
    return 40;
}

Attribute_PDU::Attribute_PDU() {
}

void Attribute_PDU::set_data(Attribute & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Attribute *Attribute_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Attribute *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Attribute_PDU::set_const_data(const Attribute & d) {
    data = (void *)&d;
    constant = 1;
}

const Attribute *Attribute_PDU::get_const_data() const {
    return (const Attribute *)data;
}

#endif

OssTypeIndex Attribute_PDU::get_index() const {
    return 41;
}

X520name_PDU::X520name_PDU() {
}

void X520name_PDU::set_data(X520name & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520name *X520name_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520name *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520name_PDU::set_const_data(const X520name & d) {
    data = (void *)&d;
    constant = 1;
}

const X520name *X520name_PDU::get_const_data() const {
    return (const X520name *)data;
}

#endif

OssTypeIndex X520name_PDU::get_index() const {
    return 42;
}

X520CommonName_PDU::X520CommonName_PDU() {
}

void X520CommonName_PDU::set_data(X520CommonName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520CommonName *X520CommonName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520CommonName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520CommonName_PDU::set_const_data(const X520CommonName & d) {
    data = (void *)&d;
    constant = 1;
}

const X520CommonName *X520CommonName_PDU::get_const_data() const {
    return (const X520CommonName *)data;
}

#endif

OssTypeIndex X520CommonName_PDU::get_index() const {
    return 43;
}

X520LocalityName_PDU::X520LocalityName_PDU() {
}

void X520LocalityName_PDU::set_data(X520LocalityName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520LocalityName *X520LocalityName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520LocalityName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520LocalityName_PDU::set_const_data(const X520LocalityName & d) {
    data = (void *)&d;
    constant = 1;
}

const X520LocalityName *X520LocalityName_PDU::get_const_data() const {
    return (const X520LocalityName *)data;
}

#endif

OssTypeIndex X520LocalityName_PDU::get_index() const {
    return 44;
}

X520StateOrProvinceName_PDU::X520StateOrProvinceName_PDU() {
}

void X520StateOrProvinceName_PDU::set_data(X520StateOrProvinceName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520StateOrProvinceName *X520StateOrProvinceName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520StateOrProvinceName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520StateOrProvinceName_PDU::set_const_data(const X520StateOrProvinceName & d) {
    data = (void *)&d;
    constant = 1;
}

const X520StateOrProvinceName *X520StateOrProvinceName_PDU::get_const_data() const {
    return (const X520StateOrProvinceName *)data;
}

#endif

OssTypeIndex X520StateOrProvinceName_PDU::get_index() const {
    return 45;
}

X520OrganizationName_PDU::X520OrganizationName_PDU() {
}

void X520OrganizationName_PDU::set_data(X520OrganizationName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520OrganizationName *X520OrganizationName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520OrganizationName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520OrganizationName_PDU::set_const_data(const X520OrganizationName & d) {
    data = (void *)&d;
    constant = 1;
}

const X520OrganizationName *X520OrganizationName_PDU::get_const_data() const {
    return (const X520OrganizationName *)data;
}

#endif

OssTypeIndex X520OrganizationName_PDU::get_index() const {
    return 46;
}

X520OrganizationalUnitName_PDU::X520OrganizationalUnitName_PDU() {
}

void X520OrganizationalUnitName_PDU::set_data(X520OrganizationalUnitName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520OrganizationalUnitName *X520OrganizationalUnitName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520OrganizationalUnitName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520OrganizationalUnitName_PDU::set_const_data(const X520OrganizationalUnitName & d) {
    data = (void *)&d;
    constant = 1;
}

const X520OrganizationalUnitName *X520OrganizationalUnitName_PDU::get_const_data() const {
    return (const X520OrganizationalUnitName *)data;
}

#endif

OssTypeIndex X520OrganizationalUnitName_PDU::get_index() const {
    return 47;
}

X520Title_PDU::X520Title_PDU() {
}

void X520Title_PDU::set_data(X520Title & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520Title *X520Title_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520Title *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520Title_PDU::set_const_data(const X520Title & d) {
    data = (void *)&d;
    constant = 1;
}

const X520Title *X520Title_PDU::get_const_data() const {
    return (const X520Title *)data;
}

#endif

OssTypeIndex X520Title_PDU::get_index() const {
    return 48;
}

X520dnQualifier_PDU::X520dnQualifier_PDU() {
}

void X520dnQualifier_PDU::set_data(X520dnQualifier & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520dnQualifier *X520dnQualifier_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520dnQualifier *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520dnQualifier_PDU::set_const_data(const X520dnQualifier & d) {
    data = (void *)&d;
    constant = 1;
}

const X520dnQualifier *X520dnQualifier_PDU::get_const_data() const {
    return (const X520dnQualifier *)data;
}

#endif

OssTypeIndex X520dnQualifier_PDU::get_index() const {
    return 49;
}

X520countryName_PDU::X520countryName_PDU() {
}

void X520countryName_PDU::set_data(X520countryName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520countryName *X520countryName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520countryName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520countryName_PDU::set_const_data(const X520countryName & d) {
    data = (void *)&d;
    constant = 1;
}

const X520countryName *X520countryName_PDU::get_const_data() const {
    return (const X520countryName *)data;
}

#endif

OssTypeIndex X520countryName_PDU::get_index() const {
    return 50;
}

X520SerialNumber_PDU::X520SerialNumber_PDU() {
}

void X520SerialNumber_PDU::set_data(X520SerialNumber & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520SerialNumber *X520SerialNumber_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520SerialNumber *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520SerialNumber_PDU::set_const_data(const X520SerialNumber & d) {
    data = (void *)&d;
    constant = 1;
}

const X520SerialNumber *X520SerialNumber_PDU::get_const_data() const {
    return (const X520SerialNumber *)data;
}

#endif

OssTypeIndex X520SerialNumber_PDU::get_index() const {
    return 51;
}

X520Pseudonym_PDU::X520Pseudonym_PDU() {
}

void X520Pseudonym_PDU::set_data(X520Pseudonym & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X520Pseudonym *X520Pseudonym_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X520Pseudonym *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X520Pseudonym_PDU::set_const_data(const X520Pseudonym & d) {
    data = (void *)&d;
    constant = 1;
}

const X520Pseudonym *X520Pseudonym_PDU::get_const_data() const {
    return (const X520Pseudonym *)data;
}

#endif

OssTypeIndex X520Pseudonym_PDU::get_index() const {
    return 52;
}

DomainComponent_PDU::DomainComponent_PDU() {
}

void DomainComponent_PDU::set_data(DomainComponent & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DomainComponent *DomainComponent_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DomainComponent *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DomainComponent_PDU::set_const_data(const DomainComponent & d) {
    data = (void *)&d;
    constant = 1;
}

const DomainComponent *DomainComponent_PDU::get_const_data() const {
    return (const DomainComponent *)data;
}

#endif

OssTypeIndex DomainComponent_PDU::get_index() const {
    return 53;
}

EmailAddress_PDU::EmailAddress_PDU() {
}

void EmailAddress_PDU::set_data(EmailAddress & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EmailAddress *EmailAddress_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EmailAddress *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EmailAddress_PDU::set_const_data(const EmailAddress & d) {
    data = (void *)&d;
    constant = 1;
}

const EmailAddress *EmailAddress_PDU::get_const_data() const {
    return (const EmailAddress *)data;
}

#endif

OssTypeIndex EmailAddress_PDU::get_index() const {
    return 54;
}

DistinguishedName_PDU::DistinguishedName_PDU() {
}

void DistinguishedName_PDU::set_data(DistinguishedName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DistinguishedName *DistinguishedName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DistinguishedName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DistinguishedName_PDU::set_const_data(const DistinguishedName & d) {
    data = (void *)&d;
    constant = 1;
}

const DistinguishedName *DistinguishedName_PDU::get_const_data() const {
    return (const DistinguishedName *)data;
}

#endif

OssTypeIndex DistinguishedName_PDU::get_index() const {
    return 55;
}

DirectoryString_PDU::DirectoryString_PDU() {
}

void DirectoryString_PDU::set_data(DirectoryString & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DirectoryString *DirectoryString_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DirectoryString *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DirectoryString_PDU::set_const_data(const DirectoryString & d) {
    data = (void *)&d;
    constant = 1;
}

const DirectoryString *DirectoryString_PDU::get_const_data() const {
    return (const DirectoryString *)data;
}

#endif

OssTypeIndex DirectoryString_PDU::get_index() const {
    return 56;
}

Certificate_PDU::Certificate_PDU() {
}

void Certificate_PDU::set_data(Certificate & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Certificate *Certificate_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Certificate *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Certificate_PDU::set_const_data(const Certificate & d) {
    data = (void *)&d;
    constant = 1;
}

const Certificate *Certificate_PDU::get_const_data() const {
    return (const Certificate *)data;
}

#endif

OssTypeIndex Certificate_PDU::get_index() const {
    return 57;
}

CertificateList_PDU::CertificateList_PDU() {
}

void CertificateList_PDU::set_data(CertificateList & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CertificateList *CertificateList_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CertificateList *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CertificateList_PDU::set_const_data(const CertificateList & d) {
    data = (void *)&d;
    constant = 1;
}

const CertificateList *CertificateList_PDU::get_const_data() const {
    return (const CertificateList *)data;
}

#endif

OssTypeIndex CertificateList_PDU::get_index() const {
    return 58;
}

ORAddress_PDU::ORAddress_PDU() {
}

void ORAddress_PDU::set_data(ORAddress & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ORAddress *ORAddress_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ORAddress *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ORAddress_PDU::set_const_data(const ORAddress & d) {
    data = (void *)&d;
    constant = 1;
}

const ORAddress *ORAddress_PDU::get_const_data() const {
    return (const ORAddress *)data;
}

#endif

OssTypeIndex ORAddress_PDU::get_index() const {
    return 59;
}

CommonName_PDU::CommonName_PDU() {
}

void CommonName_PDU::set_data(CommonName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CommonName *CommonName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CommonName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CommonName_PDU::set_const_data(const CommonName & d) {
    data = (void *)&d;
    constant = 1;
}

const CommonName *CommonName_PDU::get_const_data() const {
    return (const CommonName *)data;
}

#endif

OssTypeIndex CommonName_PDU::get_index() const {
    return 60;
}

TeletexCommonName_PDU::TeletexCommonName_PDU() {
}

void TeletexCommonName_PDU::set_data(TeletexCommonName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TeletexCommonName *TeletexCommonName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TeletexCommonName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TeletexCommonName_PDU::set_const_data(const TeletexCommonName & d) {
    data = (void *)&d;
    constant = 1;
}

const TeletexCommonName *TeletexCommonName_PDU::get_const_data() const {
    return (const TeletexCommonName *)data;
}

#endif

OssTypeIndex TeletexCommonName_PDU::get_index() const {
    return 61;
}

TeletexOrganizationName_PDU::TeletexOrganizationName_PDU() {
}

void TeletexOrganizationName_PDU::set_data(TeletexOrganizationName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TeletexOrganizationName *TeletexOrganizationName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TeletexOrganizationName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TeletexOrganizationName_PDU::set_const_data(const TeletexOrganizationName & d) {
    data = (void *)&d;
    constant = 1;
}

const TeletexOrganizationName *TeletexOrganizationName_PDU::get_const_data() const {
    return (const TeletexOrganizationName *)data;
}

#endif

OssTypeIndex TeletexOrganizationName_PDU::get_index() const {
    return 62;
}

TeletexPersonalName_PDU::TeletexPersonalName_PDU() {
}

void TeletexPersonalName_PDU::set_data(TeletexPersonalName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TeletexPersonalName *TeletexPersonalName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TeletexPersonalName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TeletexPersonalName_PDU::set_const_data(const TeletexPersonalName & d) {
    data = (void *)&d;
    constant = 1;
}

const TeletexPersonalName *TeletexPersonalName_PDU::get_const_data() const {
    return (const TeletexPersonalName *)data;
}

#endif

OssTypeIndex TeletexPersonalName_PDU::get_index() const {
    return 63;
}

TeletexOrganizationalUnitNames_PDU::TeletexOrganizationalUnitNames_PDU() {
}

void TeletexOrganizationalUnitNames_PDU::set_data(TeletexOrganizationalUnitNames & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TeletexOrganizationalUnitNames *TeletexOrganizationalUnitNames_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TeletexOrganizationalUnitNames *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TeletexOrganizationalUnitNames_PDU::set_const_data(const TeletexOrganizationalUnitNames & d) {
    data = (void *)&d;
    constant = 1;
}

const TeletexOrganizationalUnitNames *TeletexOrganizationalUnitNames_PDU::get_const_data() const {
    return (const TeletexOrganizationalUnitNames *)data;
}

#endif

OssTypeIndex TeletexOrganizationalUnitNames_PDU::get_index() const {
    return 64;
}

PDSName_PDU::PDSName_PDU() {
}

void PDSName_PDU::set_data(PDSName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PDSName *PDSName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PDSName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PDSName_PDU::set_const_data(const PDSName & d) {
    data = (void *)&d;
    constant = 1;
}

const PDSName *PDSName_PDU::get_const_data() const {
    return (const PDSName *)data;
}

#endif

OssTypeIndex PDSName_PDU::get_index() const {
    return 65;
}

PhysicalDeliveryCountryName_PDU::PhysicalDeliveryCountryName_PDU() {
}

void PhysicalDeliveryCountryName_PDU::set_data(PhysicalDeliveryCountryName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PhysicalDeliveryCountryName *PhysicalDeliveryCountryName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PhysicalDeliveryCountryName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PhysicalDeliveryCountryName_PDU::set_const_data(const PhysicalDeliveryCountryName & d) {
    data = (void *)&d;
    constant = 1;
}

const PhysicalDeliveryCountryName *PhysicalDeliveryCountryName_PDU::get_const_data() const {
    return (const PhysicalDeliveryCountryName *)data;
}

#endif

OssTypeIndex PhysicalDeliveryCountryName_PDU::get_index() const {
    return 66;
}

PostalCode_PDU::PostalCode_PDU() {
}

void PostalCode_PDU::set_data(PostalCode & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PostalCode *PostalCode_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PostalCode *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PostalCode_PDU::set_const_data(const PostalCode & d) {
    data = (void *)&d;
    constant = 1;
}

const PostalCode *PostalCode_PDU::get_const_data() const {
    return (const PostalCode *)data;
}

#endif

OssTypeIndex PostalCode_PDU::get_index() const {
    return 67;
}

PhysicalDeliveryOfficeName_PDU::PhysicalDeliveryOfficeName_PDU() {
}

void PhysicalDeliveryOfficeName_PDU::set_data(PhysicalDeliveryOfficeName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PhysicalDeliveryOfficeName *PhysicalDeliveryOfficeName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PhysicalDeliveryOfficeName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PhysicalDeliveryOfficeName_PDU::set_const_data(const PhysicalDeliveryOfficeName & d) {
    data = (void *)&d;
    constant = 1;
}

const PhysicalDeliveryOfficeName *PhysicalDeliveryOfficeName_PDU::get_const_data() const {
    return (const PhysicalDeliveryOfficeName *)data;
}

#endif

OssTypeIndex PhysicalDeliveryOfficeName_PDU::get_index() const {
    return 68;
}

PhysicalDeliveryOfficeNumber_PDU::PhysicalDeliveryOfficeNumber_PDU() {
}

void PhysicalDeliveryOfficeNumber_PDU::set_data(PhysicalDeliveryOfficeNumber & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PhysicalDeliveryOfficeNumber *PhysicalDeliveryOfficeNumber_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PhysicalDeliveryOfficeNumber *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PhysicalDeliveryOfficeNumber_PDU::set_const_data(const PhysicalDeliveryOfficeNumber & d) {
    data = (void *)&d;
    constant = 1;
}

const PhysicalDeliveryOfficeNumber *PhysicalDeliveryOfficeNumber_PDU::get_const_data() const {
    return (const PhysicalDeliveryOfficeNumber *)data;
}

#endif

OssTypeIndex PhysicalDeliveryOfficeNumber_PDU::get_index() const {
    return 69;
}

ExtensionORAddressComponents_PDU::ExtensionORAddressComponents_PDU() {
}

void ExtensionORAddressComponents_PDU::set_data(ExtensionORAddressComponents & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ExtensionORAddressComponents *ExtensionORAddressComponents_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ExtensionORAddressComponents *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ExtensionORAddressComponents_PDU::set_const_data(const ExtensionORAddressComponents & d) {
    data = (void *)&d;
    constant = 1;
}

const ExtensionORAddressComponents *ExtensionORAddressComponents_PDU::get_const_data() const {
    return (const ExtensionORAddressComponents *)data;
}

#endif

OssTypeIndex ExtensionORAddressComponents_PDU::get_index() const {
    return 70;
}

PhysicalDeliveryPersonalName_PDU::PhysicalDeliveryPersonalName_PDU() {
}

void PhysicalDeliveryPersonalName_PDU::set_data(PhysicalDeliveryPersonalName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PhysicalDeliveryPersonalName *PhysicalDeliveryPersonalName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PhysicalDeliveryPersonalName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PhysicalDeliveryPersonalName_PDU::set_const_data(const PhysicalDeliveryPersonalName & d) {
    data = (void *)&d;
    constant = 1;
}

const PhysicalDeliveryPersonalName *PhysicalDeliveryPersonalName_PDU::get_const_data() const {
    return (const PhysicalDeliveryPersonalName *)data;
}

#endif

OssTypeIndex PhysicalDeliveryPersonalName_PDU::get_index() const {
    return 71;
}

PhysicalDeliveryOrganizationName_PDU::PhysicalDeliveryOrganizationName_PDU() {
}

void PhysicalDeliveryOrganizationName_PDU::set_data(PhysicalDeliveryOrganizationName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PhysicalDeliveryOrganizationName *PhysicalDeliveryOrganizationName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PhysicalDeliveryOrganizationName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PhysicalDeliveryOrganizationName_PDU::set_const_data(const PhysicalDeliveryOrganizationName & d) {
    data = (void *)&d;
    constant = 1;
}

const PhysicalDeliveryOrganizationName *PhysicalDeliveryOrganizationName_PDU::get_const_data() const {
    return (const PhysicalDeliveryOrganizationName *)data;
}

#endif

OssTypeIndex PhysicalDeliveryOrganizationName_PDU::get_index() const {
    return 72;
}

ExtensionPhysicalDeliveryAddressComponents_PDU::ExtensionPhysicalDeliveryAddressComponents_PDU() {
}

void ExtensionPhysicalDeliveryAddressComponents_PDU::set_data(ExtensionPhysicalDeliveryAddressComponents & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ExtensionPhysicalDeliveryAddressComponents *ExtensionPhysicalDeliveryAddressComponents_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ExtensionPhysicalDeliveryAddressComponents *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ExtensionPhysicalDeliveryAddressComponents_PDU::set_const_data(const ExtensionPhysicalDeliveryAddressComponents & d) {
    data = (void *)&d;
    constant = 1;
}

const ExtensionPhysicalDeliveryAddressComponents *ExtensionPhysicalDeliveryAddressComponents_PDU::get_const_data() const {
    return (const ExtensionPhysicalDeliveryAddressComponents *)data;
}

#endif

OssTypeIndex ExtensionPhysicalDeliveryAddressComponents_PDU::get_index() const {
    return 73;
}

UnformattedPostalAddress_PDU::UnformattedPostalAddress_PDU() {
}

void UnformattedPostalAddress_PDU::set_data(UnformattedPostalAddress & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UnformattedPostalAddress *UnformattedPostalAddress_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (UnformattedPostalAddress *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void UnformattedPostalAddress_PDU::set_const_data(const UnformattedPostalAddress & d) {
    data = (void *)&d;
    constant = 1;
}

const UnformattedPostalAddress *UnformattedPostalAddress_PDU::get_const_data() const {
    return (const UnformattedPostalAddress *)data;
}

#endif

OssTypeIndex UnformattedPostalAddress_PDU::get_index() const {
    return 74;
}

StreetAddress_PDU::StreetAddress_PDU() {
}

void StreetAddress_PDU::set_data(StreetAddress & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

StreetAddress *StreetAddress_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (StreetAddress *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void StreetAddress_PDU::set_const_data(const StreetAddress & d) {
    data = (void *)&d;
    constant = 1;
}

const StreetAddress *StreetAddress_PDU::get_const_data() const {
    return (const StreetAddress *)data;
}

#endif

OssTypeIndex StreetAddress_PDU::get_index() const {
    return 75;
}

PostOfficeBoxAddress_PDU::PostOfficeBoxAddress_PDU() {
}

void PostOfficeBoxAddress_PDU::set_data(PostOfficeBoxAddress & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PostOfficeBoxAddress *PostOfficeBoxAddress_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PostOfficeBoxAddress *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PostOfficeBoxAddress_PDU::set_const_data(const PostOfficeBoxAddress & d) {
    data = (void *)&d;
    constant = 1;
}

const PostOfficeBoxAddress *PostOfficeBoxAddress_PDU::get_const_data() const {
    return (const PostOfficeBoxAddress *)data;
}

#endif

OssTypeIndex PostOfficeBoxAddress_PDU::get_index() const {
    return 76;
}

PosteRestanteAddress_PDU::PosteRestanteAddress_PDU() {
}

void PosteRestanteAddress_PDU::set_data(PosteRestanteAddress & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PosteRestanteAddress *PosteRestanteAddress_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PosteRestanteAddress *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PosteRestanteAddress_PDU::set_const_data(const PosteRestanteAddress & d) {
    data = (void *)&d;
    constant = 1;
}

const PosteRestanteAddress *PosteRestanteAddress_PDU::get_const_data() const {
    return (const PosteRestanteAddress *)data;
}

#endif

OssTypeIndex PosteRestanteAddress_PDU::get_index() const {
    return 77;
}

UniquePostalName_PDU::UniquePostalName_PDU() {
}

void UniquePostalName_PDU::set_data(UniquePostalName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UniquePostalName *UniquePostalName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (UniquePostalName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void UniquePostalName_PDU::set_const_data(const UniquePostalName & d) {
    data = (void *)&d;
    constant = 1;
}

const UniquePostalName *UniquePostalName_PDU::get_const_data() const {
    return (const UniquePostalName *)data;
}

#endif

OssTypeIndex UniquePostalName_PDU::get_index() const {
    return 78;
}

LocalPostalAttributes_PDU::LocalPostalAttributes_PDU() {
}

void LocalPostalAttributes_PDU::set_data(LocalPostalAttributes & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocalPostalAttributes *LocalPostalAttributes_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (LocalPostalAttributes *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void LocalPostalAttributes_PDU::set_const_data(const LocalPostalAttributes & d) {
    data = (void *)&d;
    constant = 1;
}

const LocalPostalAttributes *LocalPostalAttributes_PDU::get_const_data() const {
    return (const LocalPostalAttributes *)data;
}

#endif

OssTypeIndex LocalPostalAttributes_PDU::get_index() const {
    return 79;
}

ExtendedNetworkAddress_PDU::ExtendedNetworkAddress_PDU() {
}

void ExtendedNetworkAddress_PDU::set_data(ExtendedNetworkAddress & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ExtendedNetworkAddress *ExtendedNetworkAddress_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ExtendedNetworkAddress *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ExtendedNetworkAddress_PDU::set_const_data(const ExtendedNetworkAddress & d) {
    data = (void *)&d;
    constant = 1;
}

const ExtendedNetworkAddress *ExtendedNetworkAddress_PDU::get_const_data() const {
    return (const ExtendedNetworkAddress *)data;
}

#endif

OssTypeIndex ExtendedNetworkAddress_PDU::get_index() const {
    return 80;
}

TerminalType_PDU::TerminalType_PDU() {
}

void TerminalType_PDU::set_data(TerminalType & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TerminalType *TerminalType_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TerminalType *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TerminalType_PDU::set_const_data(const TerminalType & d) {
    data = (void *)&d;
    constant = 1;
}

const TerminalType *TerminalType_PDU::get_const_data() const {
    return (const TerminalType *)data;
}

#endif

OssTypeIndex TerminalType_PDU::get_index() const {
    return 81;
}

TeletexDomainDefinedAttributes_PDU::TeletexDomainDefinedAttributes_PDU() {
}

void TeletexDomainDefinedAttributes_PDU::set_data(TeletexDomainDefinedAttributes & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TeletexDomainDefinedAttributes *TeletexDomainDefinedAttributes_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TeletexDomainDefinedAttributes *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TeletexDomainDefinedAttributes_PDU::set_const_data(const TeletexDomainDefinedAttributes & d) {
    data = (void *)&d;
    constant = 1;
}

const TeletexDomainDefinedAttributes *TeletexDomainDefinedAttributes_PDU::get_const_data() const {
    return (const TeletexDomainDefinedAttributes *)data;
}

#endif

OssTypeIndex TeletexDomainDefinedAttributes_PDU::get_index() const {
    return 82;
}

AuthPack_OLD_PDU::AuthPack_OLD_PDU() {
}

void AuthPack_OLD_PDU::set_data(AuthPack_OLD & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AuthPack_OLD *AuthPack_OLD_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AuthPack_OLD *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AuthPack_OLD_PDU::set_const_data(const AuthPack_OLD & d) {
    data = (void *)&d;
    constant = 1;
}

const AuthPack_OLD *AuthPack_OLD_PDU::get_const_data() const {
    return (const AuthPack_OLD *)data;
}

#endif

OssTypeIndex AuthPack_OLD_PDU::get_index() const {
    return 83;
}

KERB_REPLY_KEY_PACKAGE_PDU::KERB_REPLY_KEY_PACKAGE_PDU() {
}

void KERB_REPLY_KEY_PACKAGE_PDU::set_data(KERB_REPLY_KEY_PACKAGE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KERB_REPLY_KEY_PACKAGE *KERB_REPLY_KEY_PACKAGE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KERB_REPLY_KEY_PACKAGE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KERB_REPLY_KEY_PACKAGE_PDU::set_const_data(const KERB_REPLY_KEY_PACKAGE & d) {
    data = (void *)&d;
    constant = 1;
}

const KERB_REPLY_KEY_PACKAGE *KERB_REPLY_KEY_PACKAGE_PDU::get_const_data() const {
    return (const KERB_REPLY_KEY_PACKAGE *)data;
}

#endif

OssTypeIndex KERB_REPLY_KEY_PACKAGE_PDU::get_index() const {
    return 84;
}

PA_FOR_USER_ENC_PDU::PA_FOR_USER_ENC_PDU() {
}

void PA_FOR_USER_ENC_PDU::set_data(PA_FOR_USER_ENC & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_FOR_USER_ENC *PA_FOR_USER_ENC_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PA_FOR_USER_ENC *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PA_FOR_USER_ENC_PDU::set_const_data(const PA_FOR_USER_ENC & d) {
    data = (void *)&d;
    constant = 1;
}

const PA_FOR_USER_ENC *PA_FOR_USER_ENC_PDU::get_const_data() const {
    return (const PA_FOR_USER_ENC *)data;
}

#endif

OssTypeIndex PA_FOR_USER_ENC_PDU::get_index() const {
    return 85;
}

PA_S4U_X509_USER_PDU::PA_S4U_X509_USER_PDU() {
}

void PA_S4U_X509_USER_PDU::set_data(PA_S4U_X509_USER & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_S4U_X509_USER *PA_S4U_X509_USER_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PA_S4U_X509_USER *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PA_S4U_X509_USER_PDU::set_const_data(const PA_S4U_X509_USER & d) {
    data = (void *)&d;
    constant = 1;
}

const PA_S4U_X509_USER *PA_S4U_X509_USER_PDU::get_const_data() const {
    return (const PA_S4U_X509_USER *)data;
}

#endif

OssTypeIndex PA_S4U_X509_USER_PDU::get_index() const {
    return 86;
}

PA_PAC_OPTIONS_PDU::PA_PAC_OPTIONS_PDU() {
}

void PA_PAC_OPTIONS_PDU::set_data(PA_PAC_OPTIONS & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_PAC_OPTIONS *PA_PAC_OPTIONS_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PA_PAC_OPTIONS *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PA_PAC_OPTIONS_PDU::set_const_data(const PA_PAC_OPTIONS & d) {
    data = (void *)&d;
    constant = 1;
}

const PA_PAC_OPTIONS *PA_PAC_OPTIONS_PDU::get_const_data() const {
    return (const PA_PAC_OPTIONS *)data;
}

#endif

OssTypeIndex PA_PAC_OPTIONS_PDU::get_index() const {
    return 87;
}

KERB_PA_PAC_REQUEST_PDU::KERB_PA_PAC_REQUEST_PDU() {
}

void KERB_PA_PAC_REQUEST_PDU::set_data(KERB_PA_PAC_REQUEST & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KERB_PA_PAC_REQUEST *KERB_PA_PAC_REQUEST_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KERB_PA_PAC_REQUEST *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KERB_PA_PAC_REQUEST_PDU::set_const_data(const KERB_PA_PAC_REQUEST & d) {
    data = (void *)&d;
    constant = 1;
}

const KERB_PA_PAC_REQUEST *KERB_PA_PAC_REQUEST_PDU::get_const_data() const {
    return (const KERB_PA_PAC_REQUEST *)data;
}

#endif

OssTypeIndex KERB_PA_PAC_REQUEST_PDU::get_index() const {
    return 88;
}

KERB_LOCAL_PDU::KERB_LOCAL_PDU() {
}

void KERB_LOCAL_PDU::set_data(KERB_LOCAL & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KERB_LOCAL *KERB_LOCAL_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KERB_LOCAL *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KERB_LOCAL_PDU::set_const_data(const KERB_LOCAL & d) {
    data = (void *)&d;
    constant = 1;
}

const KERB_LOCAL *KERB_LOCAL_PDU::get_const_data() const {
    return (const KERB_LOCAL *)data;
}

#endif

OssTypeIndex KERB_LOCAL_PDU::get_index() const {
    return 89;
}

KERB_AD_RESTRICTION_ENTRY_PDU::KERB_AD_RESTRICTION_ENTRY_PDU() {
}

void KERB_AD_RESTRICTION_ENTRY_PDU::set_data(KERB_AD_RESTRICTION_ENTRY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KERB_AD_RESTRICTION_ENTRY *KERB_AD_RESTRICTION_ENTRY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KERB_AD_RESTRICTION_ENTRY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KERB_AD_RESTRICTION_ENTRY_PDU::set_const_data(const KERB_AD_RESTRICTION_ENTRY & d) {
    data = (void *)&d;
    constant = 1;
}

const KERB_AD_RESTRICTION_ENTRY *KERB_AD_RESTRICTION_ENTRY_PDU::get_const_data() const {
    return (const KERB_AD_RESTRICTION_ENTRY *)data;
}

#endif

OssTypeIndex KERB_AD_RESTRICTION_ENTRY_PDU::get_index() const {
    return 90;
}

PA_SUPPORTED_ENCTYPES_PDU::PA_SUPPORTED_ENCTYPES_PDU() {
}

void PA_SUPPORTED_ENCTYPES_PDU::set_data(PA_SUPPORTED_ENCTYPES & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PA_SUPPORTED_ENCTYPES *PA_SUPPORTED_ENCTYPES_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PA_SUPPORTED_ENCTYPES *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PA_SUPPORTED_ENCTYPES_PDU::set_const_data(const PA_SUPPORTED_ENCTYPES & d) {
    data = (void *)&d;
    constant = 1;
}

const PA_SUPPORTED_ENCTYPES *PA_SUPPORTED_ENCTYPES_PDU::get_const_data() const {
    return (const PA_SUPPORTED_ENCTYPES *)data;
}

#endif

OssTypeIndex PA_SUPPORTED_ENCTYPES_PDU::get_index() const {
    return 91;
}

/* Control object class */

cbd_asn1_Control::cbd_asn1_Control() : OssControl(&cbd_asn1_Table, cbd_asn1_TableType::internal) {
}

cbd_asn1_Control::cbd_asn1_Control(const cbd_asn1_Control & that) : OssControl(that) {
}

#if OSS_TOED_API_LEVEL < 40
#define OSS_MEMCPY(w, dest, dmax, src, slen)        memcpy(dest, src, (size_t)(slen))
#define OSS_MEMMOVE(w, dest, dmax, src, slen)       memmove(dest, src, (size_t)(slen))
#define OSS_MEMCMP(w, dest, dmax, src, slen, diff)  memcmp(dest, src, (size_t)(slen))
#define OSS_MEMSET(w, dest, dmax, value, n)         memset(dest, value, (size_t)(n))
#define OSS_STRCPY(w, dest, dmax, src)              strcpy(dest, src)
#define OSS_STRCMP(w, dest, dmax, src, ind)         strcmp(dest, src)
#define OSS_STRNCPY(w, dest, dmax, src, slen)       strncpy(dest, src, (size_t)(slen))
#define OSS_STRNLEN(dest, dmax)                     strlen(dest)
#define OSS_SPRINTF(w, s, n, format, ...)           sprintf(s, format, __VA_ARGS__)
#endif

/* ASN.1 data initialization */
static unsigned char _v1[] = { 0x2B, 0x06, 0x01, 0x05, 0x02 };
static OSSC::COssEncOID _v0 = {
    5,
    _v1
};

const OssEncOID& id_krb5 = (const OssEncOID&)_v0;

static unsigned char _v3[] = { 0x2B, 0x06, 0x01, 0x05, 0x02, 0x03 };
static OSSC::COssEncOID _v2 = {
    6,
    _v3
};

const OssEncOID& id_pkinit = (const OssEncOID&)_v2;

static unsigned char _v5[] = { 0x2B, 0x06, 0x01, 0x05, 0x02, 0x03, 0x01 };
static OSSC::COssEncOID _v4 = {
    7,
    _v5
};

const OssEncOID& id_pkinit_authData = (const OssEncOID&)_v4;

static unsigned char _v7[] = { 0x2B, 0x06, 0x01, 0x05, 0x02, 0x03, 0x02 };
static OSSC::COssEncOID _v6 = {
    7,
    _v7
};

const OssEncOID& id_pkinit_DHKeyData = (const OssEncOID&)_v6;

static unsigned char _v9[] = { 0x2B, 0x06, 0x01, 0x05, 0x02, 0x03, 0x03 };
static OSSC::COssEncOID _v8 = {
    7,
    _v9
};

const OssEncOID& id_pkinit_rkeyData = (const OssEncOID&)_v8;

static unsigned char _v11[] = { 0x2B, 0x06, 0x01, 0x05, 0x02, 0x03, 0x04 };
static OSSC::COssEncOID _v10 = {
    7,
    _v11
};

const OssEncOID& id_pkinit_KPClientAuth = (const OssEncOID&)_v10;

static unsigned char _v13[] = { 0x2B, 0x06, 0x01, 0x05, 0x02, 0x03, 0x05 };
static OSSC::COssEncOID _v12 = {
    7,
    _v13
};

const OssEncOID& id_pkinit_KPKdc = (const OssEncOID&)_v12;

static unsigned char _v15[] = { 0x2B, 0x06, 0x01, 0x05, 0x02, 0x02 };
static OSSC::COssEncOID _v14 = {
    6,
    _v15
};

const OssEncOID& id_pkinit_san = (const OssEncOID&)_v14;

static unsigned char _v17[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07 };
static OSSC::COssEncOID _v16 = {
    6,
    _v17
};

const OssEncOID& id_pkix = (const OssEncOID&)_v16;

static unsigned char _v19[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01 };
static OSSC::COssEncOID _v18 = {
    7,
    _v19
};

const OssEncOID& id_pe = (const OssEncOID&)_v18;

static unsigned char _v21[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02 };
static OSSC::COssEncOID _v20 = {
    7,
    _v21
};

const OssEncOID& id_qt = (const OssEncOID&)_v20;

static unsigned char _v23[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03 };
static OSSC::COssEncOID _v22 = {
    7,
    _v23
};

const OssEncOID& id_kp = (const OssEncOID&)_v22;

static unsigned char _v25[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30 };
static OSSC::COssEncOID _v24 = {
    7,
    _v25
};

const OssEncOID& id_ad = (const OssEncOID&)_v24;

static unsigned char _v27[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01 };
static OSSC::COssEncOID _v26 = {
    8,
    _v27
};

const OssEncOID& id_qt_cps = (const OssEncOID&)_v26;

static unsigned char _v29[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02 };
static OSSC::COssEncOID _v28 = {
    8,
    _v29
};

const OssEncOID& id_qt_unotice = (const OssEncOID&)_v28;

static unsigned char _v31[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01 };
static OSSC::COssEncOID _v30 = {
    8,
    _v31
};

const OssEncOID& id_ad_ocsp = (const OssEncOID&)_v30;

static unsigned char _v33[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02 };
static OSSC::COssEncOID _v32 = {
    8,
    _v33
};

const OssEncOID& id_ad_caIssuers = (const OssEncOID&)_v32;

static unsigned char _v35[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x03 };
static OSSC::COssEncOID _v34 = {
    8,
    _v35
};

const OssEncOID& id_ad_timeStamping = (const OssEncOID&)_v34;

static unsigned char _v37[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x05 };
static OSSC::COssEncOID _v36 = {
    8,
    _v37
};

const OssEncOID& id_ad_caRepository = (const OssEncOID&)_v36;

static unsigned char _v39[] = { 0x55, 0x04 };
static OSSC::COssEncOID _v38 = {
    2,
    _v39
};

const OssEncOID& id_at = (const OssEncOID&)_v38;

static unsigned char _v41[] = { 0x55, 0x04, 0x29 };
static OSSC::COssEncOID _v40 = {
    3,
    _v41
};

const OssEncOID& id_at_name = (const OssEncOID&)_v40;

static unsigned char _v43[] = { 0x55, 0x04, 0x04 };
static OSSC::COssEncOID _v42 = {
    3,
    _v43
};

const OssEncOID& id_at_surname = (const OssEncOID&)_v42;

static unsigned char _v45[] = { 0x55, 0x04, 0x2A };
static OSSC::COssEncOID _v44 = {
    3,
    _v45
};

const OssEncOID& id_at_givenName = (const OssEncOID&)_v44;

static unsigned char _v47[] = { 0x55, 0x04, 0x2B };
static OSSC::COssEncOID _v46 = {
    3,
    _v47
};

const OssEncOID& id_at_initials = (const OssEncOID&)_v46;

static unsigned char _v49[] = { 0x55, 0x04, 0x2C };
static OSSC::COssEncOID _v48 = {
    3,
    _v49
};

const OssEncOID& id_at_generationQualifier = (const OssEncOID&)_v48;

static unsigned char _v51[] = { 0x55, 0x04, 0x03 };
static OSSC::COssEncOID _v50 = {
    3,
    _v51
};

const OssEncOID& id_at_commonName = (const OssEncOID&)_v50;

static unsigned char _v53[] = { 0x55, 0x04, 0x07 };
static OSSC::COssEncOID _v52 = {
    3,
    _v53
};

const OssEncOID& id_at_localityName = (const OssEncOID&)_v52;

static unsigned char _v55[] = { 0x55, 0x04, 0x08 };
static OSSC::COssEncOID _v54 = {
    3,
    _v55
};

const OssEncOID& id_at_stateOrProvinceName = (const OssEncOID&)_v54;

static unsigned char _v57[] = { 0x55, 0x04, 0x0A };
static OSSC::COssEncOID _v56 = {
    3,
    _v57
};

const OssEncOID& id_at_organizationName = (const OssEncOID&)_v56;

static unsigned char _v59[] = { 0x55, 0x04, 0x0B };
static OSSC::COssEncOID _v58 = {
    3,
    _v59
};

const OssEncOID& id_at_organizationalUnitName = (const OssEncOID&)_v58;

static unsigned char _v61[] = { 0x55, 0x04, 0x0C };
static OSSC::COssEncOID _v60 = {
    3,
    _v61
};

const OssEncOID& id_at_title = (const OssEncOID&)_v60;

static unsigned char _v63[] = { 0x55, 0x04, 0x2E };
static OSSC::COssEncOID _v62 = {
    3,
    _v63
};

const OssEncOID& id_at_dnQualifier = (const OssEncOID&)_v62;

static unsigned char _v65[] = { 0x55, 0x04, 0x06 };
static OSSC::COssEncOID _v64 = {
    3,
    _v65
};

const OssEncOID& id_at_countryName = (const OssEncOID&)_v64;

static unsigned char _v67[] = { 0x55, 0x04, 0x05 };
static OSSC::COssEncOID _v66 = {
    3,
    _v67
};

const OssEncOID& id_at_serialNumber = (const OssEncOID&)_v66;

static unsigned char _v69[] = { 0x55, 0x04, 0x41 };
static OSSC::COssEncOID _v68 = {
    3,
    _v69
};

const OssEncOID& id_at_pseudonym = (const OssEncOID&)_v68;

static unsigned char _v71[] = { 0x09, 0x92, 0x26, 0x89, 0x93, 0xF2, 0x2C, 0x64, 0x01, 0x19 };
static OSSC::COssEncOID _v70 = {
    10,
    _v71
};

const OssEncOID& id_domainComponent = (const OssEncOID&)_v70;

static unsigned char _v73[] = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09 };
static OSSC::COssEncOID _v72 = {
    8,
    _v73
};

const OssEncOID& pkcs_9 = (const OssEncOID&)_v72;

static unsigned char _v75[] = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x01 };
static OSSC::COssEncOID _v74 = {
    9,
    _v75
};

const OssEncOID& id_emailAddress = (const OssEncOID&)_v74;

const ossBoolean Extension::default_critical = FALSE;

const OSS_INT32 TBSCertificate::default_version = 0;

/* Local control table initialization */

extern "C" void DLL_ENTRY _oss_run_TOED_on_AMD64_WINDOWS_X64(void);

extern "C" {
static void _oss_post_init(struct ossGlobal *world);

/* TOED internal function declarations */

#ifdef OSS_COPY_VALUE
int DLL_ENTRY _CPMS_SFU_KILE(struct ossGlobal * _g, int pduNum, void * src, void ** pdst);
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
int DLL_ENTRY _CMMS_SFU_KILE(struct ossGlobal * _g, int _pduNum, void * _odata, void * _cdata);
#endif /* OSS_COMPARE_VALUE */

#ifdef OSS_NO_DETAIL_MM_ERROR_CODES
void DLL_ENTRY _oeMS_SFU_KILE(OssGlobal * _g, int _pdunum, void * _inbuf);
void * DLL_ENTRY _odMS_SFU_KILE(OssGlobal * _g, int _pdunum);
#endif
#if OSS_TOED_API_LEVEL >= 34
void DLL_ENTRY _jeMS_SFU_KILE(OssGlobal * _g, int _pdunum, void * _inbuf);
void * DLL_ENTRY _jdMS_SFU_KILE(OssGlobal * _g, int _pdunum);
#endif
#if OSS_TOED_API_LEVEL >= 41
void DLL_ENTRY _veMS_SFU_KILE(OssGlobal * _g, int _pdunum, void * _inbuf);
void * DLL_ENTRY _vdMS_SFU_KILE(OssGlobal * _g, int _pdunum);
#endif
static const _oss_xapi_entries_struct _oss_xapi_entries = {
     OSS_COMPILER_API_LEVEL
#ifdef OSS_COPY_VALUE
    ,_CPMS_SFU_KILE
#else
    ,NULL
#endif
#ifdef OSS_COMPARE_VALUE
    ,_CMMS_SFU_KILE
#else
    ,NULL
#endif
    ,NULL
    ,NULL
    ,102
    ,NULL
    ,NULL
#if OSS_TOED_API_LEVEL >= 24
    ,NULL
    ,NULL
    ,100
#endif
#ifdef OSS_NO_DETAIL_MM_ERROR_CODES
    ,100
    ,_oeMS_SFU_KILE
    ,_odMS_SFU_KILE
#endif
#if OSS_TOED_API_LEVEL >= 34
    ,100
    ,_jeMS_SFU_KILE
    ,_jdMS_SFU_KILE
#endif
#if OSS_TOED_API_LEVEL >= 41
    ,100
    ,_veMS_SFU_KILE
    ,_vdMS_SFU_KILE
#endif
};

/* Local control table initialization */

static unsigned char _privateFlags[] = {0x09,0x00,0x00};
void DLL_ENTRY_FDEF _ossinit_cbd_asn1(struct ossGlobal *world) {
    _EncDecGlobals *_oss_c;

    _oss_run_TOED_on_AMD64_WINDOWS_X64();
    ossPrivateSetMoreFlags(world, 18, _privateFlags);
    ossLinkBer(world);
    if (world) {
        _oss_c = (_EncDecGlobals *)world->encDecVar;
        _oss_c->der = 1;
    }
    ossSetEncodingRules(world, OSS_DER);
    ossInitXAPIentries(world, &_oss_xapi_entries);
    _oss_post_init(world);
}

/* TOED internal function declarations */


struct _seqof1 {
    struct _seqof1 * next;
    OSSC::COssString  value;
};

struct _PrincipalName {
    OSS_INT32  name_type;
    _seqof1 * name_string;
};

struct _EncryptedData {
    OSS_UINT32 bit_mask;
    OSS_INT32  etype;
    OSS_UINT32  kvno;
    OSSC::COssString  cipher;
};

struct _Ticket {
    OSS_UINT32  tkt_vno;
    OSSC::COssString  realm;
    _PrincipalName  sname;
    _EncryptedData  enc_part;
};
static long _edTicket(OssGlobal * _g, char ** _out_pos, long * _max_len, _Ticket * _in_data);
static void _d_Ticket(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Ticket * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Ticket(OssGlobal * _g, _Ticket * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Ticket(OssGlobal * _g, _Ticket * _data_ptr);
#endif

struct _EncryptionKey {
    OSS_INT32  keytype;
    OSSC::COssString  keyvalue;
};

struct _TransitedEncoding {
    OSS_INT32  tr_type;
    OSSC::COssString  contents;
};

struct _HostAddress {
    OSS_INT32  addr_type;
    OSSC::COssString  address;
};

struct _HostAddresses {
    struct _HostAddresses * next;
    _HostAddress  value;
};

struct _seq1 {
    OSS_INT32  ad_type;
    OSSC::COssString  ad_data;
};

struct _AuthorizationData {
    struct _AuthorizationData * next;
    _seq1  value;
};

struct _EncTicketPart {
    OSS_UINT32 bit_mask;
    OSSC::COssBitString  flags;
    _EncryptionKey  key;
    OSSC::COssString  crealm;
    _PrincipalName  cname;
    _TransitedEncoding  transited;
    char *  authtime;
    char *  starttime;
    char *  endtime;
    char *  renew_till;
    _HostAddresses * caddr;
    _AuthorizationData * authorization_data;
};

struct _PA_DATA {
    OSS_INT32  padata_type;
    OSSC::COssString  padata_value;
};

struct _seqof4 {
    struct _seqof4 * next;
    _PA_DATA  value;
};

struct _seqof2 {
    struct _seqof2 * next;
    OSS_INT32  value;
};

struct _seqof3 {
    struct _seqof3 * next;
    _Ticket  value;
};

struct _KDC_REQ_BODY {
    OSS_UINT32 bit_mask;
    OSSC::COssBitString  kdc_options;
    _PrincipalName  cname;
    OSSC::COssString  realm;
    _PrincipalName  sname;
    char *  from;
    char *  till;
    char *  rtime;
    OSS_UINT32  nonce;
    _seqof2 * etype;
    _HostAddresses * addresses;
    _EncryptedData  enc_authorization_data;
    _seqof3 * additional_tickets;
};

struct _KDC_REQ {
    OSS_UINT32 bit_mask;
    OSS_UINT32  pvno;
    OSS_UINT32  msg_type;
    _seqof4 * padata;
    _KDC_REQ_BODY  req_body;
};
static long _edKDC_REQ_BODY(OssGlobal * _g, char ** _out_pos, long * _max_len, _KDC_REQ_BODY * _in_data);
static void _d_KDC_REQ_BODY(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _KDC_REQ_BODY * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_KDC_REQ_BODY(OssGlobal * _g, _KDC_REQ_BODY * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_KDC_REQ_BODY(OssGlobal * _g, _KDC_REQ_BODY * _data_ptr);
#endif

struct _KDC_REP {
    OSS_UINT32 bit_mask;
    OSS_UINT32  pvno;
    OSS_UINT32  msg_type;
    _seqof4 * padata;
    OSSC::COssString  crealm;
    _PrincipalName  cname;
    _Ticket  ticket;
    _EncryptedData  enc_part;
};

struct _seq2 {
    OSS_INT32  lr_type;
    char *  lr_value;
};

struct _LastReq {
    struct _LastReq * next;
    _seq2  value;
};

struct _EncKDCRepPart {
    OSS_UINT32 bit_mask;
    _EncryptionKey  key;
    _LastReq * last_req;
    OSS_UINT32  nonce;
    char *  key_expiration;
    OSSC::COssBitString  flags;
    char *  authtime;
    char *  starttime;
    char *  endtime;
    char *  renew_till;
    OSSC::COssString  srealm;
    _PrincipalName  sname;
    _HostAddresses * caddr;
    _seqof4 * encrypted_pa_data;
};

struct _AP_REQ {
    OSS_UINT32  pvno;
    OSS_UINT32  msg_type;
    OSSC::COssBitString  ap_options;
    _Ticket  ticket;
    _EncryptedData  authenticator;
};

struct _Checksum {
    OSS_INT32  cksumtype;
    OSSC::COssString  checksum;
};

struct _Authenticator {
    OSS_UINT32 bit_mask;
    OSS_UINT32  authenticator_vno;
    OSSC::COssString  crealm;
    _PrincipalName  cname;
    _Checksum  cksum;
    OSS_UINT32  cusec;
    char *  ctime;
    _EncryptionKey  subkey;
    OSS_UINT32  seq_number;
    _AuthorizationData * authorization_data;
};

struct _AP_REP {
    OSS_UINT32  pvno;
    OSS_UINT32  msg_type;
    _EncryptedData  enc_part;
};

struct _EncAPRepPart {
    OSS_UINT32 bit_mask;
    char *  ctime;
    OSS_UINT32  cusec;
    _EncryptionKey  subkey;
    OSS_UINT32  seq_number;
};

struct _KRB_SAFE_BODY {
    OSS_UINT32 bit_mask;
    OSSC::COssString  user_data;
    char *  timestamp;
    OSS_UINT32  usec;
    OSS_UINT32  seq_number;
    _HostAddress  s_address;
    _HostAddress  r_address;
};

struct _KRB_SAFE {
    OSS_UINT32  pvno;
    OSS_UINT32  msg_type;
    _KRB_SAFE_BODY  safe_body;
    _Checksum  cksum;
};

struct _KRB_CRED {
    OSS_UINT32  pvno;
    OSS_UINT32  msg_type;
    _seqof3 * tickets;
    _EncryptedData  enc_part;
};

struct _KrbCredInfo {
    OSS_UINT32 bit_mask;
    _EncryptionKey  key;
    OSSC::COssString  prealm;
    _PrincipalName  pname;
    OSSC::COssBitString  flags;
    char *  authtime;
    char *  starttime;
    char *  endtime;
    char *  renew_till;
    OSSC::COssString  srealm;
    _PrincipalName  sname;
    _HostAddresses * caddr;
};

struct _seqof8 {
    struct _seqof8 * next;
    _KrbCredInfo  value;
};

struct _EncKrbCredPart {
    OSS_UINT32 bit_mask;
    _seqof8 * ticket_info;
    OSS_UINT32  nonce;
    char *  timestamp;
    OSS_UINT32  usec;
    _HostAddress  s_address;
    _HostAddress  r_address;
};

struct _KRB_ERROR {
    OSS_UINT32 bit_mask;
    OSS_UINT32  pvno;
    OSS_UINT32  msg_type;
    char *  ctime;
    OSS_UINT32  cusec;
    char *  stime;
    OSS_UINT32  susec;
    OSS_INT32  error_code;
    OSSC::COssString  crealm;
    _PrincipalName  cname;
    OSSC::COssString  realm;
    _PrincipalName  sname;
    OSSC::COssString  e_text;
    OSSC::COssString  e_data;
};

struct _seq3 {
    OSS_UINT32 bit_mask;
    OSS_INT32  data_type;
    OSSC::COssString  data_value;
};

struct _TYPED_DATA {
    struct _TYPED_DATA * next;
    _seq3  value;
};

struct _PA_ENC_TS_ENC {
    OSS_UINT32 bit_mask;
    char *  patimestamp;
    OSS_UINT32  pausec;
};

struct _ETYPE_INFO_ENTRY {
    OSS_UINT32 bit_mask;
    OSS_INT32  etype;
    OSSC::COssString  salt;
};

struct _ETYPE_INFO {
    struct _ETYPE_INFO * next;
    _ETYPE_INFO_ENTRY  value;
};

struct _ETYPE_INFO2_ENTRY {
    OSS_UINT32 bit_mask;
    OSS_INT32  etype;
    OSSC::COssString  salt;
    OSSC::COssString  s2kparams;
};

struct _ETYPE_INFO2 {
    struct _ETYPE_INFO2 * next;
    _ETYPE_INFO2_ENTRY  value;
};

struct _AD_KDCIssued {
    OSS_UINT32 bit_mask;
    _Checksum  ad_checksum;
    OSSC::COssString  i_realm;
    _PrincipalName  i_sname;
    _AuthorizationData * elements;
};

struct _AD_AND_OR {
    OSS_INT32  condition_count;
    _AuthorizationData * elements;
};

struct _ChangePasswdData {
    OSS_UINT32 bit_mask;
    OSSC::COssString  newpasswd;
    _PrincipalName  targname;
    OSSC::COssString  targrealm;
};

struct _ExternalPrincipalIdentifier {
    OSS_UINT32 bit_mask;
    OSSC::COssString  subjectName;
    OSSC::COssString  issuerAndSerialNumber;
    OSSC::COssString  subjectKeyIdentifier;
};

struct _seqof9 {
    struct _seqof9 * next;
    _ExternalPrincipalIdentifier  value;
};

struct _PA_PK_AS_REQ {
    OSS_UINT32 bit_mask;
    OSSC::COssString  signedAuthPack;
    _seqof9 * trustedCertifiers;
    OSSC::COssString  kdcPkId;
};
#ifdef OSS_DETECT_UNKNOWN_EXTENSION
#define OSS_UNKNOWN_EXT_FOUND(_g)	((_EncDecGlobals *)((_g)->encDecVar))->_genflags |= _F_UEXT_FOUND
#else
#define OSS_UNKNOWN_EXT_FOUND(_g)
#endif


struct _PKAuthenticator {
    OSS_UINT32 bit_mask;
    OSS_UINT32  cusec;
    char *  ctime;
    OSS_UINT32  nonce;
    OSSC::COssString  paChecksum;
};

struct _AlgorithmIdentifier {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  algorithm;
    OSSC::COssString  parameters;
};

struct _SubjectPublicKeyInfo {
    _AlgorithmIdentifier  algorithm;
    OSSC::COssBitString  subjectPublicKey;
};

struct _seqof10 {
    struct _seqof10 * next;
    _AlgorithmIdentifier  value;
};

struct _AuthPack {
    OSS_UINT32 bit_mask;
    _PKAuthenticator  pkAuthenticator;
    _SubjectPublicKeyInfo  clientPublicValue;
    _seqof10 * supportedCMSTypes;
    OSSC::COssString  clientDHNonce;
};

struct _KRB5PrincipalName {
    OSSC::COssString  realm;
    _PrincipalName  principalName;
};

struct _DHRepInfo {
    OSS_UINT32 bit_mask;
    OSSC::COssString  dhSignedData;
    OSSC::COssString  serverDHNonce;
};

struct _PA_PK_AS_REP {
    OSS_UINT32 choice;
    union {
	_DHRepInfo * dhInfo;
	OSSC::COssString  encKeyPack;
    } u;
};

struct _KDCDHKeyInfo {
    OSSC::COssBitString  subjectPublicKey;
    OSS_UINT32  nonce;
    char *  dhKeyExpiration;
};

struct _ReplyKeyPack {
    _EncryptionKey  replyKey;
    _Checksum  asChecksum;
};

struct _Attribute {
    OSSC::COssEncOID  type;
    _seqof1 * values;
};

struct _X520name {
    OSS_UINT32 choice;
    union {
	OSSC::COssString  teletexString;
	OSSC::COssString  printableString;
	OSSC::COssUniversalString  universalString;
	OSSC::COssString  utf8String;
	OSSC::COssBMPString  bmpString;
    } u;
};

struct _AttributeTypeAndValue {
    OSSC::COssEncOID  type;
    OSSC::COssString  value;
};

struct _RelativeDistinguishedName {
    struct _RelativeDistinguishedName * next;
    _AttributeTypeAndValue  value;
};

struct _RDNSequence {
    struct _RDNSequence * next;
    _RelativeDistinguishedName * value;
};

struct _Name {
    OSS_UINT32 choice;
    union {
	_RDNSequence * rdnSequence;
    } u;
};

struct _Time {
    OSS_UINT32 choice;
    union {
	char *  utcTime;
	char *  generalTime;
    } u;
};

struct _Validity {
    _Time  notBefore;
    _Time  notAfter;
};

struct _Extension {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  extnID;
    ossBoolean  critical;
    OSSC::COssString  extnValue;
};

struct _Extensions {
    struct _Extensions * next;
    _Extension  value;
};

struct _TBSCertificate {
    OSS_UINT32 bit_mask;
    OSS_INT32  version;
    OSS_INT32  serialNumber;
    _AlgorithmIdentifier  signature;
    _Name  issuer;
    _Validity  validity;
    _Name  subject;
    _SubjectPublicKeyInfo  subjectPublicKeyInfo;
    OSSC::COssBitString  issuerUniqueID;
    OSSC::COssBitString  subjectUniqueID;
    _Extensions * extensions;
};

struct _Certificate {
    _TBSCertificate  tbsCertificate;
    _AlgorithmIdentifier  signatureAlgorithm;
    OSSC::COssBitString  signature;
};

struct _seq4 {
    OSS_UINT32 bit_mask;
    OSS_INT32  userCertificate;
    _Time  revocationDate;
    _Extensions * crlEntryExtensions;
};

struct _seqof11 {
    struct _seqof11 * next;
    _seq4  value;
};

struct _TBSCertList {
    OSS_UINT32 bit_mask;
    OSS_INT32  version;
    _AlgorithmIdentifier  signature;
    _Name  issuer;
    _Time  thisUpdate;
    _Time  nextUpdate;
    _seqof11 * revokedCertificates;
    _Extensions * crlExtensions;
};

struct _CertificateList {
    _TBSCertList  tbsCertList;
    _AlgorithmIdentifier  signatureAlgorithm;
    OSSC::COssBitString  signature;
};

struct _CountryName {
    OSS_UINT32 choice;
    union {
	OSSC::COssString  x121_dcc_code;
	OSSC::COssString  iso_3166_alpha2_code;
    } u;
};

struct _AdministrationDomainName {
    OSS_UINT32 choice;
    union {
	OSSC::COssString  numeric;
	OSSC::COssString  printable;
    } u;
};

struct _PersonalName {
    OSS_UINT32 bit_mask;
    OSSC::COssString  surname;
    OSSC::COssString  given_name;
    OSSC::COssString  initials;
    OSSC::COssString  generation_qualifier;
};

struct _BuiltInStandardAttributes {
    OSS_UINT32 bit_mask;
    _CountryName  country_name;
    _AdministrationDomainName  administration_domain_name;
    OSSC::COssString  network_address;
    OSSC::COssString  terminal_identifier;
    _AdministrationDomainName  private_domain_name;
    OSSC::COssString  organization_name;
    OSSC::COssString  numeric_user_identifier;
    _PersonalName  personal_name;
    _seqof1 * organizational_unit_names;
};

struct _BuiltInDomainDefinedAttribute {
    OSSC::COssString  type;
    OSSC::COssString  value;
};

struct _BuiltInDomainDefinedAttributes {
    struct _BuiltInDomainDefinedAttributes * next;
    _BuiltInDomainDefinedAttribute  value;
};

struct _ExtensionAttribute {
    OSS_UINT32  extension_attribute_type;
    OSSC::COssString  extension_attribute_value;
};

struct _ExtensionAttributes {
    struct _ExtensionAttributes * next;
    _ExtensionAttribute  value;
};

struct _ORAddress {
    OSS_UINT32 bit_mask;
    _BuiltInStandardAttributes  built_in_standard_attributes;
    _BuiltInDomainDefinedAttributes * built_in_domain_defined_attributes;
    _ExtensionAttributes * extension_attributes;
};

struct _PostalCode {
    OSS_UINT32 choice;
    union {
	OSSC::COssString  numeric_code;
	OSSC::COssString  printable_code;
    } u;
};

struct _PDSParameter {
    OSS_UINT32 bit_mask;
    OSSC::COssString  printable_string;
    OSSC::COssString  teletex_string;
};

struct _UnformattedPostalAddress {
    OSS_UINT32 bit_mask;
    _seqof1 * printable_address;
    OSSC::COssString  teletex_string;
};

struct _seq5 {
    OSS_UINT32 bit_mask;
    OSSC::COssString  number;
    OSSC::COssString  sub_address;
};

struct _PresentationAddress {
    OSS_UINT32 bit_mask;
    OSSC::COssString  pSelector;
    OSSC::COssString  sSelector;
    OSSC::COssString  tSelector;
    _seqof1 * nAddresses;
};

struct _ExtendedNetworkAddress {
    OSS_UINT32 choice;
    union {
	_seq5 * e163_4_address;
	_PresentationAddress * psap_address;
    } u;
};

struct _PKAuthenticator_OLD {
    _PrincipalName  kdc_name;
    OSSC::COssString  kdc_realm;
    OSS_INT32  cusec;
    char *  ctime;
    OSS_INT32  nonce;
};

struct _AuthPack_OLD {
    _PKAuthenticator_OLD  pkAuthenticator;
};

struct _KERB_REPLY_KEY_PACKAGE {
    _EncryptionKey  replyKey;
    OSS_INT32  nonce;
};

struct _PA_FOR_USER_ENC {
    _PrincipalName  userName;
    OSSC::COssString  userRealm;
    _Checksum  cksum;
    OSSC::COssString  auth_package;
};

struct _S4UUserID {
    OSS_UINT32 bit_mask;
    OSS_UINT32  nonce;
    _PrincipalName  cname;
    OSSC::COssString  crealm;
    OSSC::COssString  subject_certificate;
    OSSC::COssBitString  options;
};

struct _PA_S4U_X509_USER {
    _S4UUserID  user_id;
    _Checksum  checksum;
};

struct _PA_PAC_OPTIONS {
    OSSC::COssBitString  kerberosFlags;
};

struct _KERB_PA_PAC_REQUEST {
    ossBoolean  include_pac;
};

struct _KERB_AD_RESTRICTION_ENTRY {
    OSS_INT32  restriction_type;
    OSSC::COssString  restriction;
};
static long _ed_seqof1(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof1 ** _in_data);
static void _d__seqof1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof1 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr);
#endif
static long _edPrincipalName(OssGlobal * _g, char ** _out_pos, long * _max_len, _PrincipalName * _in_data);
static void _d_PrincipalName(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _PrincipalName * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_PrincipalName(OssGlobal * _g, _PrincipalName * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_PrincipalName(OssGlobal * _g, _PrincipalName * _data_ptr);
#endif
static long _edHostAddress(OssGlobal * _g, char ** _out_pos, long * _max_len, _HostAddress * _in_data);
static void _d_HostAddress(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _HostAddress * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_HostAddress(OssGlobal * _g, _HostAddress * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_HostAddress(OssGlobal * _g, _HostAddress * _data_ptr);
#endif
static long _edHostAddresses(OssGlobal * _g, char ** _out_pos, long * _max_len, _HostAddresses ** _in_data);
static void _d_HostAddresses(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _HostAddresses ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_HostAddresses(OssGlobal * _g, _HostAddresses ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_HostAddresses(OssGlobal * _g, _HostAddresses ** _data_ptr);
#endif
static long _ed_seq1(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq1 * _in_data);
static void _d__seq1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq1 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seq1(OssGlobal * _g, _seq1 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seq1(OssGlobal * _g, _seq1 * _data_ptr);
#endif
static long _edAuthorizationData(OssGlobal * _g, char ** _out_pos, long * _max_len, _AuthorizationData ** _in_data);
static void _d_AuthorizationData(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AuthorizationData ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_AuthorizationData(OssGlobal * _g, _AuthorizationData ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_AuthorizationData(OssGlobal * _g, _AuthorizationData ** _data_ptr);
#endif
static long _edPA_DATA(OssGlobal * _g, char ** _out_pos, long * _max_len, _PA_DATA * _in_data);
static void _d_PA_DATA(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _PA_DATA * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_PA_DATA(OssGlobal * _g, _PA_DATA * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_PA_DATA(OssGlobal * _g, _PA_DATA * _data_ptr);
#endif
static long _edEncryptedData(OssGlobal * _g, char ** _out_pos, long * _max_len, _EncryptedData * _in_data);
static void _d_EncryptedData(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _EncryptedData * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_EncryptedData(OssGlobal * _g, _EncryptedData * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_EncryptedData(OssGlobal * _g, _EncryptedData * _data_ptr);
#endif
static long _edEncryptionKey(OssGlobal * _g, char ** _out_pos, long * _max_len, _EncryptionKey * _in_data);
static void _d_EncryptionKey(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _EncryptionKey * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_EncryptionKey(OssGlobal * _g, _EncryptionKey * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_EncryptionKey(OssGlobal * _g, _EncryptionKey * _data_ptr);
#endif
static long _edChecksum(OssGlobal * _g, char ** _out_pos, long * _max_len, _Checksum * _in_data);
static void _d_Checksum(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Checksum * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Checksum(OssGlobal * _g, _Checksum * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Checksum(OssGlobal * _g, _Checksum * _data_ptr);
#endif
static long _ed_seqof2(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof2 ** _in_data);
static void _d__seqof2(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof2 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof2(OssGlobal * _g, _seqof2 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof2(OssGlobal * _g, _seqof2 ** _data_ptr);
#endif
static long _ed_seqof3(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof3 ** _in_data);
static void _d__seqof3(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof3 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof3(OssGlobal * _g, _seqof3 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof3(OssGlobal * _g, _seqof3 ** _data_ptr);
#endif
static long _ed_seqof4(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof4 ** _in_data);
static void _d__seqof4(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof4 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof4(OssGlobal * _g, _seqof4 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof4(OssGlobal * _g, _seqof4 ** _data_ptr);
#endif
static long _edKDC_REQ(OssGlobal * _g, char ** _out_pos, long * _max_len, _KDC_REQ * _in_data);
static void _d_KDC_REQ(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _KDC_REQ * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_KDC_REQ(OssGlobal * _g, _KDC_REQ * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_KDC_REQ(OssGlobal * _g, _KDC_REQ * _data_ptr);
#endif
static long _ed_seqof5(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof4 ** _in_data);
static void _d__seqof5(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof4 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof5(OssGlobal * _g, _seqof4 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof5(OssGlobal * _g, _seqof4 ** _data_ptr);
#endif
static long _edKDC_REP(OssGlobal * _g, char ** _out_pos, long * _max_len, _KDC_REP * _in_data);
static void _d_KDC_REP(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _KDC_REP * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_KDC_REP(OssGlobal * _g, _KDC_REP * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_KDC_REP(OssGlobal * _g, _KDC_REP * _data_ptr);
#endif
static long _ed_seqof6(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof4 ** _in_data);
static void _d__seqof6(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof4 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof6(OssGlobal * _g, _seqof4 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof6(OssGlobal * _g, _seqof4 ** _data_ptr);
#endif
static long _edEncKDCRepPart(OssGlobal * _g, char ** _out_pos, long * _max_len, _EncKDCRepPart * _in_data);
static void _d_EncKDCRepPart(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _EncKDCRepPart * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_EncKDCRepPart(OssGlobal * _g, _EncKDCRepPart * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_EncKDCRepPart(OssGlobal * _g, _EncKDCRepPart * _data_ptr);
#endif
static long _ed_seq2(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq2 * _in_data);
static void _d__seq2(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq2 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seq2(OssGlobal * _g, _seq2 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seq2(OssGlobal * _g, _seq2 * _data_ptr);
#endif
static long _edLastReq(OssGlobal * _g, char ** _out_pos, long * _max_len, _LastReq ** _in_data);
static void _d_LastReq(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _LastReq ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_LastReq(OssGlobal * _g, _LastReq ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_LastReq(OssGlobal * _g, _LastReq ** _data_ptr);
#endif
static long _edExternalPrincipalIdentifier(OssGlobal * _g, char ** _out_pos, long * _max_len, _ExternalPrincipalIdentifier * _in_data);
static void _d_ExternalPrincipalIdentifier(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ExternalPrincipalIdentifier * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_ExternalPrincipalIdentifier(OssGlobal * _g, _ExternalPrincipalIdentifier * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_ExternalPrincipalIdentifier(OssGlobal * _g, _ExternalPrincipalIdentifier * _data_ptr);
#endif
static long _edAlgorithmIdentifier(OssGlobal * _g, char ** _out_pos, long * _max_len, _AlgorithmIdentifier * _in_data);
static void _d_AlgorithmIdentifier(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AlgorithmIdentifier * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_AlgorithmIdentifier(OssGlobal * _g, _AlgorithmIdentifier * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_AlgorithmIdentifier(OssGlobal * _g, _AlgorithmIdentifier * _data_ptr);
#endif
static long _edSubjectPublicKeyInfo(OssGlobal * _g, char ** _out_pos, long * _max_len, _SubjectPublicKeyInfo * _in_data);
static void _d_SubjectPublicKeyInfo(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _SubjectPublicKeyInfo * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_SubjectPublicKeyInfo(OssGlobal * _g, _SubjectPublicKeyInfo * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_SubjectPublicKeyInfo(OssGlobal * _g, _SubjectPublicKeyInfo * _data_ptr);
#endif
static long _edName(OssGlobal * _g, char ** _out_pos, long * _max_len, _Name * _in_data);
static void _d_Name(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Name * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Name(OssGlobal * _g, _Name * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Name(OssGlobal * _g, _Name * _data_ptr);
#endif
static long _edRDNSequence(OssGlobal * _g, char ** _out_pos, long * _max_len, _RDNSequence ** _in_data);
static void _d_RDNSequence(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RDNSequence ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr);
#endif
static long _edTime(OssGlobal * _g, char ** _out_pos, long * _max_len, _Time * _in_data);
static void _d_Time(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Time * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Time(OssGlobal * _g, _Time * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Time(OssGlobal * _g, _Time * _data_ptr);
#endif
static long _edExtension(OssGlobal * _g, char ** _out_pos, long * _max_len, _Extension * _in_data);
static void _d_Extension(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Extension * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Extension(OssGlobal * _g, _Extension * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Extension(OssGlobal * _g, _Extension * _data_ptr);
#endif
static long _edExtensions(OssGlobal * _g, char ** _out_pos, long * _max_len, _Extensions ** _in_data);
static void _d_Extensions(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Extensions ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Extensions(OssGlobal * _g, _Extensions ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Extensions(OssGlobal * _g, _Extensions ** _data_ptr);
#endif
static long _edPDSParameter(OssGlobal * _g, char ** _out_pos, long * _max_len, _PDSParameter * _in_data);
static void _d_PDSParameter(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _PDSParameter * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_PDSParameter(OssGlobal * _g, _PDSParameter * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_PDSParameter(OssGlobal * _g, _PDSParameter * _data_ptr);
#endif
static void _eTicket(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTicket(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTicket(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTicket(OssGlobal * _g, void * _data);
#endif
static void _eEncTicketPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dEncTicketPart(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEncTicketPart(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEncTicketPart(OssGlobal * _g, void * _data);
#endif
static void _eAS_REQ(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAS_REQ(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAS_REQ(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAS_REQ(OssGlobal * _g, void * _data);
#endif
static void _eTGS_REQ(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTGS_REQ(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTGS_REQ(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTGS_REQ(OssGlobal * _g, void * _data);
#endif
static void _eKDC_REQ_BODY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKDC_REQ_BODY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKDC_REQ_BODY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKDC_REQ_BODY(OssGlobal * _g, void * _data);
#endif
static void _eAS_REP(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAS_REP(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAS_REP(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAS_REP(OssGlobal * _g, void * _data);
#endif
static void _eTGS_REP(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTGS_REP(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTGS_REP(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTGS_REP(OssGlobal * _g, void * _data);
#endif
static void _eEncASRepPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dEncASRepPart(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEncASRepPart(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEncASRepPart(OssGlobal * _g, void * _data);
#endif
static void _eEncTGSRepPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dEncTGSRepPart(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEncTGSRepPart(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEncTGSRepPart(OssGlobal * _g, void * _data);
#endif
static void _eAP_REQ(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAP_REQ(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAP_REQ(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAP_REQ(OssGlobal * _g, void * _data);
#endif
static void _eAuthenticator(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAuthenticator(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAuthenticator(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAuthenticator(OssGlobal * _g, void * _data);
#endif
static void _eAP_REP(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAP_REP(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAP_REP(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAP_REP(OssGlobal * _g, void * _data);
#endif
static void _eEncAPRepPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dEncAPRepPart(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEncAPRepPart(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEncAPRepPart(OssGlobal * _g, void * _data);
#endif
static void _eKRB_SAFE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKRB_SAFE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKRB_SAFE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKRB_SAFE(OssGlobal * _g, void * _data);
#endif
static void _eKRB_PRIV(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKRB_PRIV(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKRB_PRIV(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKRB_PRIV(OssGlobal * _g, void * _data);
#endif
static void _eEncKrbPrivPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dEncKrbPrivPart(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEncKrbPrivPart(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEncKrbPrivPart(OssGlobal * _g, void * _data);
#endif
static void _eKRB_CRED(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKRB_CRED(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKRB_CRED(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKRB_CRED(OssGlobal * _g, void * _data);
#endif
static void _eEncKrbCredPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dEncKrbCredPart(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEncKrbCredPart(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEncKrbCredPart(OssGlobal * _g, void * _data);
#endif
static void _eKRB_ERROR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKRB_ERROR(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKRB_ERROR(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKRB_ERROR(OssGlobal * _g, void * _data);
#endif
static void _eMETHOD_DATA(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dMETHOD_DATA(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fMETHOD_DATA(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pMETHOD_DATA(OssGlobal * _g, void * _data);
#endif
static void _eTYPED_DATA(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTYPED_DATA(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTYPED_DATA(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTYPED_DATA(OssGlobal * _g, void * _data);
#endif
static void _ePA_ENC_TIMESTAMP(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPA_ENC_TIMESTAMP(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPA_ENC_TIMESTAMP(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPA_ENC_TIMESTAMP(OssGlobal * _g, void * _data);
#endif
static void _ePA_ENC_TS_ENC(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPA_ENC_TS_ENC(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPA_ENC_TS_ENC(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPA_ENC_TS_ENC(OssGlobal * _g, void * _data);
#endif
static void _eETYPE_INFO(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dETYPE_INFO(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fETYPE_INFO(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pETYPE_INFO(OssGlobal * _g, void * _data);
#endif
static void _eETYPE_INFO2(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dETYPE_INFO2(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fETYPE_INFO2(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pETYPE_INFO2(OssGlobal * _g, void * _data);
#endif
static void _eAD_IF_RELEVANT(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAD_IF_RELEVANT(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAD_IF_RELEVANT(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAD_IF_RELEVANT(OssGlobal * _g, void * _data);
#endif
static void _eAD_KDCIssued(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAD_KDCIssued(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAD_KDCIssued(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAD_KDCIssued(OssGlobal * _g, void * _data);
#endif
static void _eAD_AND_OR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAD_AND_OR(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAD_AND_OR(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAD_AND_OR(OssGlobal * _g, void * _data);
#endif
static void _eAD_MANDATORY_FOR_KDC(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAD_MANDATORY_FOR_KDC(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAD_MANDATORY_FOR_KDC(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAD_MANDATORY_FOR_KDC(OssGlobal * _g, void * _data);
#endif
static void _eChangePasswdData(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dChangePasswdData(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fChangePasswdData(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pChangePasswdData(OssGlobal * _g, void * _data);
#endif
static void _ePA_PK_AS_REQ(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPA_PK_AS_REQ(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPA_PK_AS_REQ(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPA_PK_AS_REQ(OssGlobal * _g, void * _data);
#endif
static void _eAuthPack(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAuthPack(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAuthPack(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAuthPack(OssGlobal * _g, void * _data);
#endif
static void _eTD_TRUSTED_CERTIFIERS(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTD_TRUSTED_CERTIFIERS(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTD_TRUSTED_CERTIFIERS(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTD_TRUSTED_CERTIFIERS(OssGlobal * _g, void * _data);
#endif
static void _eTD_INVALID_CERTIFICATES(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTD_INVALID_CERTIFICATES(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTD_INVALID_CERTIFICATES(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTD_INVALID_CERTIFICATES(OssGlobal * _g, void * _data);
#endif
static void _eKRB5PrincipalName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKRB5PrincipalName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKRB5PrincipalName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKRB5PrincipalName(OssGlobal * _g, void * _data);
#endif
static void _eAD_INITIAL_VERIFIED_CAS(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAD_INITIAL_VERIFIED_CAS(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAD_INITIAL_VERIFIED_CAS(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAD_INITIAL_VERIFIED_CAS(OssGlobal * _g, void * _data);
#endif
static void _ePA_PK_AS_REP(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPA_PK_AS_REP(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPA_PK_AS_REP(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPA_PK_AS_REP(OssGlobal * _g, void * _data);
#endif
static void _eKDCDHKeyInfo(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKDCDHKeyInfo(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKDCDHKeyInfo(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKDCDHKeyInfo(OssGlobal * _g, void * _data);
#endif
static void _eReplyKeyPack(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dReplyKeyPack(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fReplyKeyPack(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pReplyKeyPack(OssGlobal * _g, void * _data);
#endif
static void _eTD_DH_PARAMETERS(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTD_DH_PARAMETERS(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTD_DH_PARAMETERS(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTD_DH_PARAMETERS(OssGlobal * _g, void * _data);
#endif
static void _eAttribute(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAttribute(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAttribute(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAttribute(OssGlobal * _g, void * _data);
#endif
static void _eX520name(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520name(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520name(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520name(OssGlobal * _g, void * _data);
#endif
static void _eX520CommonName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520CommonName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520CommonName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520CommonName(OssGlobal * _g, void * _data);
#endif
static void _eX520LocalityName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520LocalityName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520LocalityName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520LocalityName(OssGlobal * _g, void * _data);
#endif
static void _eX520StateOrProvinceName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520StateOrProvinceName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520StateOrProvinceName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520StateOrProvinceName(OssGlobal * _g, void * _data);
#endif
static void _eX520OrganizationName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520OrganizationName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520OrganizationName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520OrganizationName(OssGlobal * _g, void * _data);
#endif
static void _eX520OrganizationalUnitName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520OrganizationalUnitName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520OrganizationalUnitName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520OrganizationalUnitName(OssGlobal * _g, void * _data);
#endif
static void _eX520Title(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520Title(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520Title(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520Title(OssGlobal * _g, void * _data);
#endif
static void _eX520dnQualifier(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520dnQualifier(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520dnQualifier(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520dnQualifier(OssGlobal * _g, void * _data);
#endif
static void _eX520countryName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520countryName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520countryName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520countryName(OssGlobal * _g, void * _data);
#endif
static void _eX520SerialNumber(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520SerialNumber(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520SerialNumber(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520SerialNumber(OssGlobal * _g, void * _data);
#endif
static void _eX520Pseudonym(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dX520Pseudonym(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX520Pseudonym(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX520Pseudonym(OssGlobal * _g, void * _data);
#endif
static void _eDomainComponent(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dDomainComponent(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDomainComponent(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDomainComponent(OssGlobal * _g, void * _data);
#endif
static void _eEmailAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dEmailAddress(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEmailAddress(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEmailAddress(OssGlobal * _g, void * _data);
#endif
static void _eDistinguishedName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dDistinguishedName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDistinguishedName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDistinguishedName(OssGlobal * _g, void * _data);
#endif
static void _eDirectoryString(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dDirectoryString(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDirectoryString(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDirectoryString(OssGlobal * _g, void * _data);
#endif
static void _eCertificate(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dCertificate(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCertificate(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCertificate(OssGlobal * _g, void * _data);
#endif
static void _eCertificateList(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dCertificateList(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCertificateList(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCertificateList(OssGlobal * _g, void * _data);
#endif
static void _eORAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dORAddress(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fORAddress(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pORAddress(OssGlobal * _g, void * _data);
#endif
static void _eCommonName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dCommonName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCommonName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCommonName(OssGlobal * _g, void * _data);
#endif
static void _eTeletexCommonName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTeletexCommonName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTeletexCommonName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTeletexCommonName(OssGlobal * _g, void * _data);
#endif
static void _eTeletexOrganizationName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTeletexOrganizationName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTeletexOrganizationName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTeletexOrganizationName(OssGlobal * _g, void * _data);
#endif
static void _eTeletexPersonalName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTeletexPersonalName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTeletexPersonalName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTeletexPersonalName(OssGlobal * _g, void * _data);
#endif
static void _e0TeletexOrganizationalUnitNa(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _d0TeletexOrganizationalUnitNa(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f0TeletexOrganizationalUnitNa(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p0TeletexOrganizationalUnitNa(OssGlobal * _g, void * _data);
#endif
static void _ePDSName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPDSName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPDSName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPDSName(OssGlobal * _g, void * _data);
#endif
static void _ePhysicalDeliveryCountryName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPhysicalDeliveryCountryName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPhysicalDeliveryCountryName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPhysicalDeliveryCountryName(OssGlobal * _g, void * _data);
#endif
static void _ePostalCode(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPostalCode(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPostalCode(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPostalCode(OssGlobal * _g, void * _data);
#endif
static void _ePhysicalDeliveryOfficeName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPhysicalDeliveryOfficeName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPhysicalDeliveryOfficeName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPhysicalDeliveryOfficeName(OssGlobal * _g, void * _data);
#endif
static void _ePhysicalDeliveryOfficeNumber(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPhysicalDeliveryOfficeNumber(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPhysicalDeliveryOfficeNumber(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPhysicalDeliveryOfficeNumber(OssGlobal * _g, void * _data);
#endif
static void _eExtensionORAddressComponents(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dExtensionORAddressComponents(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fExtensionORAddressComponents(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pExtensionORAddressComponents(OssGlobal * _g, void * _data);
#endif
static void _ePhysicalDeliveryPersonalName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPhysicalDeliveryPersonalName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPhysicalDeliveryPersonalName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPhysicalDeliveryPersonalName(OssGlobal * _g, void * _data);
#endif
static void _e1PhysicalDeliveryOrganizatio(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _d1PhysicalDeliveryOrganizatio(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f1PhysicalDeliveryOrganizatio(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p1PhysicalDeliveryOrganizatio(OssGlobal * _g, void * _data);
#endif
static void _e2ExtensionPhysicalDeliveryAd(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _d2ExtensionPhysicalDeliveryAd(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f2ExtensionPhysicalDeliveryAd(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p2ExtensionPhysicalDeliveryAd(OssGlobal * _g, void * _data);
#endif
static void _eUnformattedPostalAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dUnformattedPostalAddress(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fUnformattedPostalAddress(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pUnformattedPostalAddress(OssGlobal * _g, void * _data);
#endif
static void _eStreetAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dStreetAddress(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fStreetAddress(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pStreetAddress(OssGlobal * _g, void * _data);
#endif
static void _ePostOfficeBoxAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPostOfficeBoxAddress(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPostOfficeBoxAddress(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPostOfficeBoxAddress(OssGlobal * _g, void * _data);
#endif
static void _ePosteRestanteAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPosteRestanteAddress(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPosteRestanteAddress(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPosteRestanteAddress(OssGlobal * _g, void * _data);
#endif
static void _eUniquePostalName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dUniquePostalName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fUniquePostalName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pUniquePostalName(OssGlobal * _g, void * _data);
#endif
static void _eLocalPostalAttributes(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dLocalPostalAttributes(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fLocalPostalAttributes(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pLocalPostalAttributes(OssGlobal * _g, void * _data);
#endif
static void _eExtendedNetworkAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dExtendedNetworkAddress(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fExtendedNetworkAddress(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pExtendedNetworkAddress(OssGlobal * _g, void * _data);
#endif
static void _eTerminalType(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTerminalType(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTerminalType(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTerminalType(OssGlobal * _g, void * _data);
#endif
static void _e3TeletexDomainDefinedAttribu(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _d3TeletexDomainDefinedAttribu(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f3TeletexDomainDefinedAttribu(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p3TeletexDomainDefinedAttribu(OssGlobal * _g, void * _data);
#endif
static void _eAuthPack_OLD(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAuthPack_OLD(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAuthPack_OLD(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAuthPack_OLD(OssGlobal * _g, void * _data);
#endif
static void _eKERB_REPLY_KEY_PACKAGE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKERB_REPLY_KEY_PACKAGE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKERB_REPLY_KEY_PACKAGE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKERB_REPLY_KEY_PACKAGE(OssGlobal * _g, void * _data);
#endif
static void _ePA_FOR_USER_ENC(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPA_FOR_USER_ENC(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPA_FOR_USER_ENC(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPA_FOR_USER_ENC(OssGlobal * _g, void * _data);
#endif
static void _ePA_S4U_X509_USER(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPA_S4U_X509_USER(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPA_S4U_X509_USER(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPA_S4U_X509_USER(OssGlobal * _g, void * _data);
#endif
static void _ePA_PAC_OPTIONS(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPA_PAC_OPTIONS(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPA_PAC_OPTIONS(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPA_PAC_OPTIONS(OssGlobal * _g, void * _data);
#endif
static void _eKERB_PA_PAC_REQUEST(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKERB_PA_PAC_REQUEST(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKERB_PA_PAC_REQUEST(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKERB_PA_PAC_REQUEST(OssGlobal * _g, void * _data);
#endif
static void _eKERB_LOCAL(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKERB_LOCAL(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKERB_LOCAL(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKERB_LOCAL(OssGlobal * _g, void * _data);
#endif
static void _eKERB_AD_RESTRICTION_ENTRY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKERB_AD_RESTRICTION_ENTRY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKERB_AD_RESTRICTION_ENTRY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKERB_AD_RESTRICTION_ENTRY(OssGlobal * _g, void * _data);
#endif
static void _ePA_SUPPORTED_ENCTYPES(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPA_SUPPORTED_ENCTYPES(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPA_SUPPORTED_ENCTYPES(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPA_SUPPORTED_ENCTYPES(OssGlobal * _g, void * _data);
#endif
void DLL_ENTRY _emMS_SFU_KILE(struct ossGlobal * _g, int _pdunum, void * _inbuf);
void DLL_ENTRY _dmMS_SFU_KILE(struct ossGlobal * _g, int * _pdunum, void ** _outbuf);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
int DLL_ENTRY _fmMS_SFU_KILE(struct ossGlobal * _g, int _pdunum, void * _data);
#endif
#ifdef OSSPRINT
int DLL_ENTRY _pmMS_SFU_KILE(struct ossGlobal * _g, int _pdunum, void * _data);
#endif



#ifdef OSS_COPY_VALUE
static _Ticket  * _cpTicket(OssGlobal * _g, _Ticket  * psVal, _Ticket  * pdVal);
static _KDC_REQ_BODY  * _cpKDC_REQ_BODY(OssGlobal * _g, _KDC_REQ_BODY  * psVal, _KDC_REQ_BODY  * pdVal);
static _seqof1 * * _cp_seqof1(OssGlobal * _g, _seqof1 * * psVal, _seqof1 * * pdVal);
static _PrincipalName  * _cpPrincipalName(OssGlobal * _g, _PrincipalName  * psVal, _PrincipalName  * pdVal);
static _HostAddress  * _cpHostAddress(OssGlobal * _g, _HostAddress  * psVal, _HostAddress  * pdVal);
static _HostAddresses * * _cpHostAddresses(OssGlobal * _g, _HostAddresses * * psVal, _HostAddresses * * pdVal);
static _seq1  * _cp_seq1(OssGlobal * _g, _seq1  * psVal, _seq1  * pdVal);
static _AuthorizationData * * _cpAuthorizationData(OssGlobal * _g, _AuthorizationData * * psVal, _AuthorizationData * * pdVal);
static _PA_DATA  * _cpPA_DATA(OssGlobal * _g, _PA_DATA  * psVal, _PA_DATA  * pdVal);
static _EncryptedData  * _cpEncryptedData(OssGlobal * _g, _EncryptedData  * psVal, _EncryptedData  * pdVal);
static _EncryptionKey  * _cpEncryptionKey(OssGlobal * _g, _EncryptionKey  * psVal, _EncryptionKey  * pdVal);
static _Checksum  * _cpChecksum(OssGlobal * _g, _Checksum  * psVal, _Checksum  * pdVal);
static _seqof3 * * _cp_seqof3(OssGlobal * _g, _seqof3 * * psVal, _seqof3 * * pdVal);
static _seqof4 * * _cp_seqof4(OssGlobal * _g, _seqof4 * * psVal, _seqof4 * * pdVal);
static _KDC_REQ  * _cpKDC_REQ(OssGlobal * _g, _KDC_REQ  * psVal, _KDC_REQ  * pdVal);
static _seqof4 * * _cp_seqof5(OssGlobal * _g, _seqof4 * * psVal, _seqof4 * * pdVal);
static _KDC_REP  * _cpKDC_REP(OssGlobal * _g, _KDC_REP  * psVal, _KDC_REP  * pdVal);
static _seqof4 * * _cp_seqof6(OssGlobal * _g, _seqof4 * * psVal, _seqof4 * * pdVal);
static _EncKDCRepPart  * _cpEncKDCRepPart(OssGlobal * _g, _EncKDCRepPart  * psVal, _EncKDCRepPart  * pdVal);
static _seq2  * _cp_seq2(OssGlobal * _g, _seq2  * psVal, _seq2  * pdVal);
static _LastReq * * _cpLastReq(OssGlobal * _g, _LastReq * * psVal, _LastReq * * pdVal);
static _ExternalPrincipalIdentifier  * _cpExternalPrincipalIdentifier(OssGlobal * _g, _ExternalPrincipalIdentifier  * psVal, _ExternalPrincipalIdentifier  * pdVal);
static _AlgorithmIdentifier  * _cpAlgorithmIdentifier(OssGlobal * _g, _AlgorithmIdentifier  * psVal, _AlgorithmIdentifier  * pdVal);
static _SubjectPublicKeyInfo  * _cpSubjectPublicKeyInfo(OssGlobal * _g, _SubjectPublicKeyInfo  * psVal, _SubjectPublicKeyInfo  * pdVal);
static _Name  * _cpName(OssGlobal * _g, _Name  * psVal, _Name  * pdVal);
static _RDNSequence * * _cpRDNSequence(OssGlobal * _g, _RDNSequence * * psVal, _RDNSequence * * pdVal);
static _Time  * _cpTime(OssGlobal * _g, _Time  * psVal, _Time  * pdVal);
static _Extension  * _cpExtension(OssGlobal * _g, _Extension  * psVal, _Extension  * pdVal);
static _Extensions * * _cpExtensions(OssGlobal * _g, _Extensions * * psVal, _Extensions * * pdVal);
static _PDSParameter  * _cpPDSParameter(OssGlobal * _g, _PDSParameter  * psVal, _PDSParameter  * pdVal);
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
static int _cmTicket(OssGlobal * _g, _Ticket  * _odata, _Ticket  * _cdata);
static int _cmKDC_REQ_BODY(OssGlobal * _g, _KDC_REQ_BODY  * _odata, _KDC_REQ_BODY  * _cdata);
static int _cm_seqof1(OssGlobal * _g, _seqof1 * * _odata, _seqof1 * * _cdata);
static int _cmPrincipalName(OssGlobal * _g, _PrincipalName  * _odata, _PrincipalName  * _cdata);
static int _cmHostAddress(OssGlobal * _g, _HostAddress  * _odata, _HostAddress  * _cdata);
static int _cmHostAddresses(OssGlobal * _g, _HostAddresses * * _odata, _HostAddresses * * _cdata);
static int _cm_seq1(OssGlobal * _g, _seq1  * _odata, _seq1  * _cdata);
static int _cmAuthorizationData(OssGlobal * _g, _AuthorizationData * * _odata, _AuthorizationData * * _cdata);
static int _cmPA_DATA(OssGlobal * _g, _PA_DATA  * _odata, _PA_DATA  * _cdata);
static int _cmEncryptedData(OssGlobal * _g, _EncryptedData  * _odata, _EncryptedData  * _cdata);
static int _cmEncryptionKey(OssGlobal * _g, _EncryptionKey  * _odata, _EncryptionKey  * _cdata);
static int _cmChecksum(OssGlobal * _g, _Checksum  * _odata, _Checksum  * _cdata);
static int _cm_seqof2(OssGlobal * _g, _seqof2 * * _odata, _seqof2 * * _cdata);
static int _cm_seqof3(OssGlobal * _g, _seqof3 * * _odata, _seqof3 * * _cdata);
static int _cm_seqof4(OssGlobal * _g, _seqof4 * * _odata, _seqof4 * * _cdata);
static int _cmKDC_REQ(OssGlobal * _g, _KDC_REQ  * _odata, _KDC_REQ  * _cdata);
static int _cm_seqof5(OssGlobal * _g, _seqof4 * * _odata, _seqof4 * * _cdata);
static int _cmKDC_REP(OssGlobal * _g, _KDC_REP  * _odata, _KDC_REP  * _cdata);
static int _cm_seqof6(OssGlobal * _g, _seqof4 * * _odata, _seqof4 * * _cdata);
static int _cmEncKDCRepPart(OssGlobal * _g, _EncKDCRepPart  * _odata, _EncKDCRepPart  * _cdata);
static int _cm_seq2(OssGlobal * _g, _seq2  * _odata, _seq2  * _cdata);
static int _cmLastReq(OssGlobal * _g, _LastReq * * _odata, _LastReq * * _cdata);
static int _cmExternalPrincipalIdentifier(OssGlobal * _g, _ExternalPrincipalIdentifier  * _odata, _ExternalPrincipalIdentifier  * _cdata);
static int _cmAlgorithmIdentifier(OssGlobal * _g, _AlgorithmIdentifier  * _odata, _AlgorithmIdentifier  * _cdata);
static int _cmSubjectPublicKeyInfo(OssGlobal * _g, _SubjectPublicKeyInfo  * _odata, _SubjectPublicKeyInfo  * _cdata);
static int _cmName(OssGlobal * _g, _Name  * _odata, _Name  * _cdata);
static int _cmRDNSequence(OssGlobal * _g, _RDNSequence * * _odata, _RDNSequence * * _cdata);
static int _cmTime(OssGlobal * _g, _Time  * _odata, _Time  * _cdata);
static int _cmExtension(OssGlobal * _g, _Extension  * _odata, _Extension  * _cdata);
static int _cmExtensions(OssGlobal * _g, _Extensions * * _odata, _Extensions * * _cdata);
static int _cmPDSParameter(OssGlobal * _g, _PDSParameter  * _odata, _PDSParameter  * _cdata);
#endif /* OSS_COMPARE_VALUE */

static void (* const _Encoders[91])(OssGlobal *, void *, char **, long *, unsigned int) = {
    _eTicket,
    _eEncTicketPart,
    _eAS_REQ,
    _eTGS_REQ,
    _eKDC_REQ_BODY,
    _eAS_REP,
    _eTGS_REP,
    _eEncASRepPart,
    _eEncTGSRepPart,
    _eAP_REQ,
    _eAuthenticator,
    _eAP_REP,
    _eEncAPRepPart,
    _eKRB_SAFE,
    _eKRB_PRIV,
    _eEncKrbPrivPart,
    _eKRB_CRED,
    _eEncKrbCredPart,
    _eKRB_ERROR,
    _eMETHOD_DATA,
    _eTYPED_DATA,
    _ePA_ENC_TIMESTAMP,
    _ePA_ENC_TS_ENC,
    _eETYPE_INFO,
    _eETYPE_INFO2,
    _eAD_IF_RELEVANT,
    _eAD_KDCIssued,
    _eAD_AND_OR,
    _eAD_MANDATORY_FOR_KDC,
    _eChangePasswdData,
    _ePA_PK_AS_REQ,
    _eAuthPack,
    _eTD_TRUSTED_CERTIFIERS,
    _eTD_INVALID_CERTIFICATES,
    _eKRB5PrincipalName,
    _eAD_INITIAL_VERIFIED_CAS,
    _ePA_PK_AS_REP,
    _eKDCDHKeyInfo,
    _eReplyKeyPack,
    _eTD_DH_PARAMETERS,
    _eAttribute,
    _eX520name,
    _eX520CommonName,
    _eX520LocalityName,
    _eX520StateOrProvinceName,
    _eX520OrganizationName,
    _eX520OrganizationalUnitName,
    _eX520Title,
    _eX520dnQualifier,
    _eX520countryName,
    _eX520SerialNumber,
    _eX520Pseudonym,
    _eDomainComponent,
    _eEmailAddress,
    _eDistinguishedName,
    _eDirectoryString,
    _eCertificate,
    _eCertificateList,
    _eORAddress,
    _eCommonName,
    _eTeletexCommonName,
    _eTeletexOrganizationName,
    _eTeletexPersonalName,
    _e0TeletexOrganizationalUnitNa,
    _ePDSName,
    _ePhysicalDeliveryCountryName,
    _ePostalCode,
    _ePhysicalDeliveryOfficeName,
    _ePhysicalDeliveryOfficeNumber,
    _eExtensionORAddressComponents,
    _ePhysicalDeliveryPersonalName,
    _e1PhysicalDeliveryOrganizatio,
    _e2ExtensionPhysicalDeliveryAd,
    _eUnformattedPostalAddress,
    _eStreetAddress,
    _ePostOfficeBoxAddress,
    _ePosteRestanteAddress,
    _eUniquePostalName,
    _eLocalPostalAttributes,
    _eExtendedNetworkAddress,
    _eTerminalType,
    _e3TeletexDomainDefinedAttribu,
    _eAuthPack_OLD,
    _eKERB_REPLY_KEY_PACKAGE,
    _ePA_FOR_USER_ENC,
    _ePA_S4U_X509_USER,
    _ePA_PAC_OPTIONS,
    _eKERB_PA_PAC_REQUEST,
    _eKERB_LOCAL,
    _eKERB_AD_RESTRICTION_ENTRY,
    _ePA_SUPPORTED_ENCTYPES
};
static void *(* const _Decoders[91])(OssGlobal *) = {
    _dTicket,
    _dEncTicketPart,
    _dAS_REQ,
    _dTGS_REQ,
    _dKDC_REQ_BODY,
    _dAS_REP,
    _dTGS_REP,
    _dEncASRepPart,
    _dEncTGSRepPart,
    _dAP_REQ,
    _dAuthenticator,
    _dAP_REP,
    _dEncAPRepPart,
    _dKRB_SAFE,
    _dKRB_PRIV,
    _dEncKrbPrivPart,
    _dKRB_CRED,
    _dEncKrbCredPart,
    _dKRB_ERROR,
    _dMETHOD_DATA,
    _dTYPED_DATA,
    _dPA_ENC_TIMESTAMP,
    _dPA_ENC_TS_ENC,
    _dETYPE_INFO,
    _dETYPE_INFO2,
    _dAD_IF_RELEVANT,
    _dAD_KDCIssued,
    _dAD_AND_OR,
    _dAD_MANDATORY_FOR_KDC,
    _dChangePasswdData,
    _dPA_PK_AS_REQ,
    _dAuthPack,
    _dTD_TRUSTED_CERTIFIERS,
    _dTD_INVALID_CERTIFICATES,
    _dKRB5PrincipalName,
    _dAD_INITIAL_VERIFIED_CAS,
    _dPA_PK_AS_REP,
    _dKDCDHKeyInfo,
    _dReplyKeyPack,
    _dTD_DH_PARAMETERS,
    _dAttribute,
    _dX520name,
    _dX520CommonName,
    _dX520LocalityName,
    _dX520StateOrProvinceName,
    _dX520OrganizationName,
    _dX520OrganizationalUnitName,
    _dX520Title,
    _dX520dnQualifier,
    _dX520countryName,
    _dX520SerialNumber,
    _dX520Pseudonym,
    _dDomainComponent,
    _dEmailAddress,
    _dDistinguishedName,
    _dDirectoryString,
    _dCertificate,
    _dCertificateList,
    _dORAddress,
    _dCommonName,
    _dTeletexCommonName,
    _dTeletexOrganizationName,
    _dTeletexPersonalName,
    _d0TeletexOrganizationalUnitNa,
    _dPDSName,
    _dPhysicalDeliveryCountryName,
    _dPostalCode,
    _dPhysicalDeliveryOfficeName,
    _dPhysicalDeliveryOfficeNumber,
    _dExtensionORAddressComponents,
    _dPhysicalDeliveryPersonalName,
    _d1PhysicalDeliveryOrganizatio,
    _d2ExtensionPhysicalDeliveryAd,
    _dUnformattedPostalAddress,
    _dStreetAddress,
    _dPostOfficeBoxAddress,
    _dPosteRestanteAddress,
    _dUniquePostalName,
    _dLocalPostalAttributes,
    _dExtendedNetworkAddress,
    _dTerminalType,
    _d3TeletexDomainDefinedAttribu,
    _dAuthPack_OLD,
    _dKERB_REPLY_KEY_PACKAGE,
    _dPA_FOR_USER_ENC,
    _dPA_S4U_X509_USER,
    _dPA_PAC_OPTIONS,
    _dKERB_PA_PAC_REQUEST,
    _dKERB_LOCAL,
    _dKERB_AD_RESTRICTION_ENTRY,
    _dPA_SUPPORTED_ENCTYPES
};
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void (* const _FreePDU[91])(OssGlobal *, void *) = {
    _fTicket,
    _fEncTicketPart,
    _fAS_REQ,
    _fTGS_REQ,
    _fKDC_REQ_BODY,
    _fAS_REP,
    _fTGS_REP,
    _fEncASRepPart,
    _fEncTGSRepPart,
    _fAP_REQ,
    _fAuthenticator,
    _fAP_REP,
    _fEncAPRepPart,
    _fKRB_SAFE,
    _fKRB_PRIV,
    _fEncKrbPrivPart,
    _fKRB_CRED,
    _fEncKrbCredPart,
    _fKRB_ERROR,
    _fMETHOD_DATA,
    _fTYPED_DATA,
    _fPA_ENC_TIMESTAMP,
    _fPA_ENC_TS_ENC,
    _fETYPE_INFO,
    _fETYPE_INFO2,
    _fAD_IF_RELEVANT,
    _fAD_KDCIssued,
    _fAD_AND_OR,
    _fAD_MANDATORY_FOR_KDC,
    _fChangePasswdData,
    _fPA_PK_AS_REQ,
    _fAuthPack,
    _fTD_TRUSTED_CERTIFIERS,
    _fTD_INVALID_CERTIFICATES,
    _fKRB5PrincipalName,
    _fAD_INITIAL_VERIFIED_CAS,
    _fPA_PK_AS_REP,
    _fKDCDHKeyInfo,
    _fReplyKeyPack,
    _fTD_DH_PARAMETERS,
    _fAttribute,
    _fX520name,
    _fX520CommonName,
    _fX520LocalityName,
    _fX520StateOrProvinceName,
    _fX520OrganizationName,
    _fX520OrganizationalUnitName,
    _fX520Title,
    _fX520dnQualifier,
    _fX520countryName,
    _fX520SerialNumber,
    _fX520Pseudonym,
    _fDomainComponent,
    _fEmailAddress,
    _fDistinguishedName,
    _fDirectoryString,
    _fCertificate,
    _fCertificateList,
    _fORAddress,
    _fCommonName,
    _fTeletexCommonName,
    _fTeletexOrganizationName,
    _fTeletexPersonalName,
    _f0TeletexOrganizationalUnitNa,
    _fPDSName,
    _fPhysicalDeliveryCountryName,
    _fPostalCode,
    _fPhysicalDeliveryOfficeName,
    _fPhysicalDeliveryOfficeNumber,
    _fExtensionORAddressComponents,
    _fPhysicalDeliveryPersonalName,
    _f1PhysicalDeliveryOrganizatio,
    _f2ExtensionPhysicalDeliveryAd,
    _fUnformattedPostalAddress,
    _fStreetAddress,
    _fPostOfficeBoxAddress,
    _fPosteRestanteAddress,
    _fUniquePostalName,
    _fLocalPostalAttributes,
    _fExtendedNetworkAddress,
    _fTerminalType,
    _f3TeletexDomainDefinedAttribu,
    _fAuthPack_OLD,
    _fKERB_REPLY_KEY_PACKAGE,
    _fPA_FOR_USER_ENC,
    _fPA_S4U_X509_USER,
    _fPA_PAC_OPTIONS,
    _fKERB_PA_PAC_REQUEST,
    _fKERB_LOCAL,
    _fKERB_AD_RESTRICTION_ENTRY,
    _fPA_SUPPORTED_ENCTYPES
};
#endif
#ifdef OSSPRINT
static _print_pdu_ const _PrintPDU[91] = {
    { _pTicket, (char *)"Ticket" },
    { _pEncTicketPart, (char *)"EncTicketPart" },
    { _pAS_REQ, (char *)"AS-REQ" },
    { _pTGS_REQ, (char *)"TGS-REQ" },
    { _pKDC_REQ_BODY, (char *)"KDC-REQ-BODY" },
    { _pAS_REP, (char *)"AS-REP" },
    { _pTGS_REP, (char *)"TGS-REP" },
    { _pEncASRepPart, (char *)"EncASRepPart" },
    { _pEncTGSRepPart, (char *)"EncTGSRepPart" },
    { _pAP_REQ, (char *)"AP-REQ" },
    { _pAuthenticator, (char *)"Authenticator" },
    { _pAP_REP, (char *)"AP-REP" },
    { _pEncAPRepPart, (char *)"EncAPRepPart" },
    { _pKRB_SAFE, (char *)"KRB-SAFE" },
    { _pKRB_PRIV, (char *)"KRB-PRIV" },
    { _pEncKrbPrivPart, (char *)"EncKrbPrivPart" },
    { _pKRB_CRED, (char *)"KRB-CRED" },
    { _pEncKrbCredPart, (char *)"EncKrbCredPart" },
    { _pKRB_ERROR, (char *)"KRB-ERROR" },
    { _pMETHOD_DATA, (char *)"METHOD-DATA" },
    { _pTYPED_DATA, (char *)"TYPED-DATA" },
    { _pPA_ENC_TIMESTAMP, (char *)"PA-ENC-TIMESTAMP" },
    { _pPA_ENC_TS_ENC, (char *)"PA-ENC-TS-ENC" },
    { _pETYPE_INFO, (char *)"ETYPE-INFO" },
    { _pETYPE_INFO2, (char *)"ETYPE-INFO2" },
    { _pAD_IF_RELEVANT, (char *)"AD-IF-RELEVANT" },
    { _pAD_KDCIssued, (char *)"AD-KDCIssued" },
    { _pAD_AND_OR, (char *)"AD-AND-OR" },
    { _pAD_MANDATORY_FOR_KDC, (char *)"AD-MANDATORY-FOR-KDC" },
    { _pChangePasswdData, (char *)"ChangePasswdData" },
    { _pPA_PK_AS_REQ, (char *)"PA-PK-AS-REQ" },
    { _pAuthPack, (char *)"AuthPack" },
    { _pTD_TRUSTED_CERTIFIERS, (char *)"TD-TRUSTED-CERTIFIERS" },
    { _pTD_INVALID_CERTIFICATES, (char *)"TD-INVALID-CERTIFICATES" },
    { _pKRB5PrincipalName, (char *)"KRB5PrincipalName" },
    { _pAD_INITIAL_VERIFIED_CAS, (char *)"AD-INITIAL-VERIFIED-CAS" },
    { _pPA_PK_AS_REP, (char *)"PA-PK-AS-REP" },
    { _pKDCDHKeyInfo, (char *)"KDCDHKeyInfo" },
    { _pReplyKeyPack, (char *)"ReplyKeyPack" },
    { _pTD_DH_PARAMETERS, (char *)"TD-DH-PARAMETERS" },
    { _pAttribute, (char *)"Attribute" },
    { _pX520name, (char *)"X520name" },
    { _pX520CommonName, (char *)"X520CommonName" },
    { _pX520LocalityName, (char *)"X520LocalityName" },
    { _pX520StateOrProvinceName, (char *)"X520StateOrProvinceName" },
    { _pX520OrganizationName, (char *)"X520OrganizationName" },
    { _pX520OrganizationalUnitName, (char *)"X520OrganizationalUnitName" },
    { _pX520Title, (char *)"X520Title" },
    { _pX520dnQualifier, (char *)"X520dnQualifier" },
    { _pX520countryName, (char *)"X520countryName" },
    { _pX520SerialNumber, (char *)"X520SerialNumber" },
    { _pX520Pseudonym, (char *)"X520Pseudonym" },
    { _pDomainComponent, (char *)"DomainComponent" },
    { _pEmailAddress, (char *)"EmailAddress" },
    { _pDistinguishedName, (char *)"DistinguishedName" },
    { _pDirectoryString, (char *)"DirectoryString" },
    { _pCertificate, (char *)"Certificate" },
    { _pCertificateList, (char *)"CertificateList" },
    { _pORAddress, (char *)"ORAddress" },
    { _pCommonName, (char *)"CommonName" },
    { _pTeletexCommonName, (char *)"TeletexCommonName" },
    { _pTeletexOrganizationName, (char *)"TeletexOrganizationName" },
    { _pTeletexPersonalName, (char *)"TeletexPersonalName" },
    { _p0TeletexOrganizationalUnitNa, (char *)"TeletexOrganizationalUnitNames" },
    { _pPDSName, (char *)"PDSName" },
    { _pPhysicalDeliveryCountryName, (char *)"PhysicalDeliveryCountryName" },
    { _pPostalCode, (char *)"PostalCode" },
    { _pPhysicalDeliveryOfficeName, (char *)"PhysicalDeliveryOfficeName" },
    { _pPhysicalDeliveryOfficeNumber, (char *)"PhysicalDeliveryOfficeNumber" },
    { _pExtensionORAddressComponents, (char *)"ExtensionORAddressComponents" },
    { _pPhysicalDeliveryPersonalName, (char *)"PhysicalDeliveryPersonalName" },
    { _p1PhysicalDeliveryOrganizatio, (char *)"PhysicalDeliveryOrganizationName" },
    { _p2ExtensionPhysicalDeliveryAd, (char *)"ExtensionPhysicalDeliveryAddressComponents" },
    { _pUnformattedPostalAddress, (char *)"UnformattedPostalAddress" },
    { _pStreetAddress, (char *)"StreetAddress" },
    { _pPostOfficeBoxAddress, (char *)"PostOfficeBoxAddress" },
    { _pPosteRestanteAddress, (char *)"PosteRestanteAddress" },
    { _pUniquePostalName, (char *)"UniquePostalName" },
    { _pLocalPostalAttributes, (char *)"LocalPostalAttributes" },
    { _pExtendedNetworkAddress, (char *)"ExtendedNetworkAddress" },
    { _pTerminalType, (char *)"TerminalType" },
    { _p3TeletexDomainDefinedAttribu, (char *)"TeletexDomainDefinedAttributes" },
    { _pAuthPack_OLD, (char *)"AuthPack_OLD" },
    { _pKERB_REPLY_KEY_PACKAGE, (char *)"KERB-REPLY-KEY-PACKAGE" },
    { _pPA_FOR_USER_ENC, (char *)"PA-FOR-USER-ENC" },
    { _pPA_S4U_X509_USER, (char *)"PA-S4U-X509-USER" },
    { _pPA_PAC_OPTIONS, (char *)"PA-PAC-OPTIONS" },
    { _pKERB_PA_PAC_REQUEST, (char *)"KERB-PA-PAC-REQUEST" },
    { _pKERB_LOCAL, (char *)"KERB-LOCAL" },
    { _pKERB_AD_RESTRICTION_ENTRY, (char *)"KERB-AD-RESTRICTION-ENTRY" },
    { _pPA_SUPPORTED_ENCTYPES, (char *)"PA-SUPPORTED-ENCTYPES" }
};
#endif

/* TOED internal function implementations */

#if OSSDEBUG > 1
static const _Context_Id _context_id[] = {
    {(char *)"enc-part", (char *)"EncryptedData", _sequence_type},
    {(char *)"sname", (char *)"PrincipalName", _sequence_type},
    {(char *)"realm", (char *)"Realm", _charstring_type},
    {(char *)"tkt-vno", (char *)"INTEGER", _integer_type},
    {(char *)"additional-tickets", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"enc-authorization-data", (char *)"EncryptedData", _sequence_type},
    {(char *)"addresses", (char *)"HostAddresses", _sequence_of_type},
    {(char *)"etype", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"nonce", (char *)"UInt32", _integer_type},
    {(char *)"rtime", (char *)"KerberosTime", _charstring_type},
    {(char *)"till", (char *)"KerberosTime", _charstring_type},
    {(char *)"from", (char *)"KerberosTime", _charstring_type},
    {(char *)"cname", (char *)"PrincipalName", _sequence_type},
    {(char *)"kdc-options", (char *)"KDCOptions", _bitstring_type},
    {NULL, (char *)"KerberosString", _charstring_type},
    {(char *)"name-string", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"name-type", (char *)"Int32", _integer_type},
    {(char *)"address", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"addr-type", (char *)"Int32", _integer_type},
    {NULL, (char *)"HostAddress", _sequence_type},
    {(char *)"ad-data", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"ad-type", (char *)"Int32", _integer_type},
    {NULL, (char *)"SEQUENCE", _sequence_type},
    {(char *)"padata-value", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"padata-type", (char *)"Int32", _integer_type},
    {(char *)"cipher", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"kvno", (char *)"UInt32", _integer_type},
    {(char *)"etype", (char *)"Int32", _integer_type},
    {(char *)"keyvalue", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"keytype", (char *)"Int32", _integer_type},
    {(char *)"checksum", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"cksumtype", (char *)"Int32", _integer_type},
    {NULL, (char *)"Int32", _integer_type},
    {NULL, (char *)"Ticket", _sequence_type},
    {NULL, (char *)"PA-DATA", _sequence_type},
    {(char *)"req-body", (char *)"KDC-REQ-BODY", _sequence_type},
    {(char *)"padata", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"msg-type", (char *)"INTEGER", _integer_type},
    {(char *)"pvno", (char *)"INTEGER", _integer_type},
    {(char *)"ticket", (char *)"Ticket", _sequence_type},
    {(char *)"crealm", (char *)"Realm", _charstring_type},
    {(char *)"encrypted-pa-data", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"caddr", (char *)"HostAddresses", _sequence_of_type},
    {(char *)"srealm", (char *)"Realm", _charstring_type},
    {(char *)"renew-till", (char *)"KerberosTime", _charstring_type},
    {(char *)"endtime", (char *)"KerberosTime", _charstring_type},
    {(char *)"starttime", (char *)"KerberosTime", _charstring_type},
    {(char *)"authtime", (char *)"KerberosTime", _charstring_type},
    {(char *)"flags", (char *)"TicketFlags", _bitstring_type},
    {(char *)"key-expiration", (char *)"KerberosTime", _charstring_type},
    {(char *)"last-req", (char *)"LastReq", _sequence_of_type},
    {(char *)"key", (char *)"EncryptionKey", _sequence_type},
    {(char *)"lr-value", (char *)"KerberosTime", _charstring_type},
    {(char *)"lr-type", (char *)"Int32", _integer_type},
    {(char *)"subjectKeyIdentifier", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"issuerAndSerialNumber", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"subjectName", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"parameters", (char *)"ANY", _any_type},
    {(char *)"algorithm", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"subjectPublicKey", (char *)"BIT STRING", _bitstring_type},
    {(char *)"algorithm", (char *)"AlgorithmIdentifier", _sequence_type},
    {(char *)"rdnSequence", (char *)"RDNSequence", _sequence_of_type},
    {NULL, (char *)"RelativeDistinguishedName", _set_of_type},
    {NULL, (char *)"AttributeTypeAndValue", _sequence_type},
    {(char *)"value", (char *)"AttributeValue", _any_type},
    {(char *)"type", (char *)"AttributeType", _object_identifier_type},
    {(char *)"utcTime", (char *)"Character String", _charstring_type},
    {(char *)"generalTime", (char *)"Character String", _charstring_type},
    {(char *)"extnValue", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"critical", (char *)"BOOLEAN", _boolean_type},
    {(char *)"extnID", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {NULL, (char *)"Extension", _sequence_type},
    {(char *)"teletex-string", (char *)"Character String", _charstring_type},
    {(char *)"printable-string", (char *)"Character String", _charstring_type},
    {(char *)"Ticket", (char *)"SEQUENCE", _sequence_type},
    {(char *)"EncTicketPart", (char *)"SEQUENCE", _sequence_type},
    {(char *)"authorization-data", (char *)"AuthorizationData", _sequence_of_type},
    {(char *)"transited", (char *)"TransitedEncoding", _sequence_type},
    {(char *)"contents", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"tr-type", (char *)"Int32", _integer_type},
    {(char *)"AS-REQ", (char *)"SEQUENCE", _sequence_type},
    {(char *)"TGS-REQ", (char *)"SEQUENCE", _sequence_type},
    {(char *)"KDC-REQ-BODY", (char *)"SEQUENCE", _sequence_type},
    {(char *)"AS-REP", (char *)"SEQUENCE", _sequence_type},
    {(char *)"TGS-REP", (char *)"SEQUENCE", _sequence_type},
    {(char *)"EncASRepPart", (char *)"SEQUENCE", _sequence_type},
    {(char *)"EncTGSRepPart", (char *)"SEQUENCE", _sequence_type},
    {(char *)"AP-REQ", (char *)"SEQUENCE", _sequence_type},
    {(char *)"authenticator", (char *)"EncryptedData", _sequence_type},
    {(char *)"ap-options", (char *)"APOptions", _bitstring_type},
    {(char *)"Authenticator", (char *)"SEQUENCE", _sequence_type},
    {(char *)"seq-number", (char *)"UInt32", _integer_type},
    {(char *)"subkey", (char *)"EncryptionKey", _sequence_type},
    {(char *)"ctime", (char *)"KerberosTime", _charstring_type},
    {(char *)"cusec", (char *)"Microseconds", _integer_type},
    {(char *)"cksum", (char *)"Checksum", _sequence_type},
    {(char *)"authenticator-vno", (char *)"INTEGER", _integer_type},
    {(char *)"AP-REP", (char *)"SEQUENCE", _sequence_type},
    {(char *)"EncAPRepPart", (char *)"SEQUENCE", _sequence_type},
    {(char *)"KRB-SAFE", (char *)"SEQUENCE", _sequence_type},
    {(char *)"safe-body", (char *)"KRB-SAFE-BODY", _sequence_type},
    {(char *)"r-address", (char *)"HostAddress", _sequence_type},
    {(char *)"s-address", (char *)"HostAddress", _sequence_type},
    {(char *)"usec", (char *)"Microseconds", _integer_type},
    {(char *)"timestamp", (char *)"KerberosTime", _charstring_type},
    {(char *)"user-data", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"KRB-PRIV", (char *)"SEQUENCE", _sequence_type},
    {(char *)"EncKrbPrivPart", (char *)"SEQUENCE", _sequence_type},
    {(char *)"KRB-CRED", (char *)"SEQUENCE", _sequence_type},
    {(char *)"tickets", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"EncKrbCredPart", (char *)"SEQUENCE", _sequence_type},
    {(char *)"ticket-info", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"KrbCredInfo", _sequence_type},
    {(char *)"pname", (char *)"PrincipalName", _sequence_type},
    {(char *)"prealm", (char *)"Realm", _charstring_type},
    {(char *)"KRB-ERROR", (char *)"SEQUENCE", _sequence_type},
    {(char *)"e-data", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"e-text", (char *)"KerberosString", _charstring_type},
    {(char *)"error-code", (char *)"Int32", _integer_type},
    {(char *)"susec", (char *)"Microseconds", _integer_type},
    {(char *)"stime", (char *)"KerberosTime", _charstring_type},
    {(char *)"METHOD-DATA", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"TYPED-DATA", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"data-value", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"data-type", (char *)"Int32", _integer_type},
    {(char *)"PA-ENC-TIMESTAMP", (char *)"SEQUENCE", _sequence_type},
    {(char *)"PA-ENC-TS-ENC", (char *)"SEQUENCE", _sequence_type},
    {(char *)"pausec", (char *)"Microseconds", _integer_type},
    {(char *)"patimestamp", (char *)"KerberosTime", _charstring_type},
    {(char *)"ETYPE-INFO", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"ETYPE-INFO-ENTRY", _sequence_type},
    {(char *)"salt", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"ETYPE-INFO2", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"ETYPE-INFO2-ENTRY", _sequence_type},
    {(char *)"s2kparams", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"salt", (char *)"KerberosString", _charstring_type},
    {(char *)"AD-IF-RELEVANT", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"AD-KDCIssued", (char *)"SEQUENCE", _sequence_type},
    {(char *)"elements", (char *)"AuthorizationData", _sequence_of_type},
    {(char *)"i-sname", (char *)"PrincipalName", _sequence_type},
    {(char *)"i-realm", (char *)"Realm", _charstring_type},
    {(char *)"ad-checksum", (char *)"Checksum", _sequence_type},
    {(char *)"AD-AND-OR", (char *)"SEQUENCE", _sequence_type},
    {(char *)"condition-count", (char *)"Int32", _integer_type},
    {(char *)"AD-MANDATORY-FOR-KDC", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"ChangePasswdData", (char *)"SEQUENCE", _sequence_type},
    {(char *)"targrealm", (char *)"Realm", _charstring_type},
    {(char *)"targname", (char *)"PrincipalName", _sequence_type},
    {(char *)"newpasswd", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"PA-PK-AS-REQ", (char *)"SEQUENCE", _sequence_type},
    {(char *)"kdcPkId", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"trustedCertifiers", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"ExternalPrincipalIdentifier", _sequence_type},
    {(char *)"signedAuthPack", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"AuthPack", (char *)"SEQUENCE", _sequence_type},
    {(char *)"clientDHNonce", (char *)"DHNonce", _octetstring_type},
    {(char *)"supportedCMSTypes", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"AlgorithmIdentifier", _sequence_type},
    {(char *)"clientPublicValue", (char *)"SubjectPublicKeyInfo", _sequence_type},
    {(char *)"pkAuthenticator", (char *)"PKAuthenticator", _sequence_type},
    {(char *)"paChecksum", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"nonce", (char *)"INTEGER", _integer_type},
    {(char *)"cusec", (char *)"INTEGER", _integer_type},
    {(char *)"TD-TRUSTED-CERTIFIERS", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"TD-INVALID-CERTIFICATES", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"KRB5PrincipalName", (char *)"SEQUENCE", _sequence_type},
    {(char *)"principalName", (char *)"PrincipalName", _sequence_type},
    {(char *)"AD-INITIAL-VERIFIED-CAS", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"PA-PK-AS-REP", (char *)"CHOICE", _choice_type},
    {(char *)"dhInfo", (char *)"DHRepInfo", _sequence_type},
    {(char *)"serverDHNonce", (char *)"DHNonce", _octetstring_type},
    {(char *)"dhSignedData", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"encKeyPack", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"KDCDHKeyInfo", (char *)"SEQUENCE", _sequence_type},
    {(char *)"dhKeyExpiration", (char *)"KerberosTime", _charstring_type},
    {(char *)"ReplyKeyPack", (char *)"SEQUENCE", _sequence_type},
    {(char *)"asChecksum", (char *)"Checksum", _sequence_type},
    {(char *)"replyKey", (char *)"EncryptionKey", _sequence_type},
    {(char *)"TD-DH-PARAMETERS", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"Attribute", (char *)"SEQUENCE", _sequence_type},
    {(char *)"values", (char *)"SET OF", _set_of_type},
    {NULL, (char *)"AttributeValue", _any_type},
    {(char *)"X520name", (char *)"CHOICE", _choice_type},
    {(char *)"teletexString", (char *)"Character String", _charstring_type},
    {(char *)"printableString", (char *)"Character String", _charstring_type},
    {(char *)"universalString", (char *)"Character String", _charstring_type},
    {(char *)"utf8String", (char *)"Character String", _charstring_type},
    {(char *)"bmpString", (char *)"Character String", _charstring_type},
    {(char *)"X520CommonName", (char *)"CHOICE", _choice_type},
    {(char *)"X520LocalityName", (char *)"CHOICE", _choice_type},
    {(char *)"X520StateOrProvinceName", (char *)"CHOICE", _choice_type},
    {(char *)"X520OrganizationName", (char *)"CHOICE", _choice_type},
    {(char *)"X520OrganizationalUnitName", (char *)"CHOICE", _choice_type},
    {(char *)"X520Title", (char *)"CHOICE", _choice_type},
    {(char *)"X520dnQualifier", (char *)"Character String", _charstring_type},
    {(char *)"X520countryName", (char *)"Character String", _charstring_type},
    {(char *)"X520SerialNumber", (char *)"Character String", _charstring_type},
    {(char *)"X520Pseudonym", (char *)"CHOICE", _choice_type},
    {(char *)"DomainComponent", (char *)"Character String", _charstring_type},
    {(char *)"EmailAddress", (char *)"Character String", _charstring_type},
    {(char *)"DistinguishedName", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"DirectoryString", (char *)"CHOICE", _choice_type},
    {(char *)"Certificate", (char *)"SEQUENCE", _sequence_type},
    {(char *)"signature", (char *)"BIT STRING", _bitstring_type},
    {(char *)"signatureAlgorithm", (char *)"AlgorithmIdentifier", _sequence_type},
    {(char *)"tbsCertificate", (char *)"TBSCertificate", _sequence_type},
    {(char *)"extensions", (char *)"Extensions", _sequence_of_type},
    {(char *)"subjectUniqueID", (char *)"UniqueIdentifier", _bitstring_type},
    {(char *)"issuerUniqueID", (char *)"UniqueIdentifier", _bitstring_type},
    {(char *)"subjectPublicKeyInfo", (char *)"SubjectPublicKeyInfo", _sequence_type},
    {(char *)"subject", (char *)"Name", _choice_type},
    {(char *)"validity", (char *)"Validity", _sequence_type},
    {(char *)"notAfter", (char *)"Time", _choice_type},
    {(char *)"notBefore", (char *)"Time", _choice_type},
    {(char *)"issuer", (char *)"Name", _choice_type},
    {(char *)"signature", (char *)"AlgorithmIdentifier", _sequence_type},
    {(char *)"serialNumber", (char *)"CertificateSerialNumber", _integer_type},
    {(char *)"version", (char *)"Version", _integer_type},
    {(char *)"CertificateList", (char *)"SEQUENCE", _sequence_type},
    {(char *)"tbsCertList", (char *)"TBSCertList", _sequence_type},
    {(char *)"crlExtensions", (char *)"Extensions", _sequence_of_type},
    {(char *)"revokedCertificates", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"crlEntryExtensions", (char *)"Extensions", _sequence_of_type},
    {(char *)"revocationDate", (char *)"Time", _choice_type},
    {(char *)"userCertificate", (char *)"CertificateSerialNumber", _integer_type},
    {(char *)"nextUpdate", (char *)"Time", _choice_type},
    {(char *)"thisUpdate", (char *)"Time", _choice_type},
    {(char *)"ORAddress", (char *)"SEQUENCE", _sequence_type},
    {(char *)"extension-attributes", (char *)"ExtensionAttributes", _set_of_type},
    {NULL, (char *)"ExtensionAttribute", _sequence_type},
    {(char *)"extension-attribute-value", (char *)"ANY", _any_type},
    {(char *)"extension-attribute-type", (char *)"INTEGER", _integer_type},
    {(char *)"built-in-domain-defined-attributes", (char *)"BuiltInDomainDefinedAttributes", _sequence_of_type},
    {NULL, (char *)"BuiltInDomainDefinedAttribute", _sequence_type},
    {(char *)"value", (char *)"Character String", _charstring_type},
    {(char *)"type", (char *)"Character String", _charstring_type},
    {(char *)"built-in-standard-attributes", (char *)"BuiltInStandardAttributes", _sequence_type},
    {(char *)"organizational-unit-names", (char *)"OrganizationalUnitNames", _sequence_of_type},
    {NULL, (char *)"OrganizationalUnitName", _charstring_type},
    {(char *)"personal-name", (char *)"PersonalName", _set_type},
    {(char *)"generation-qualifier", (char *)"Character String", _charstring_type},
    {(char *)"initials", (char *)"Character String", _charstring_type},
    {(char *)"given-name", (char *)"Character String", _charstring_type},
    {(char *)"surname", (char *)"Character String", _charstring_type},
    {(char *)"numeric-user-identifier", (char *)"NumericUserIdentifier", _charstring_type},
    {(char *)"organization-name", (char *)"OrganizationName", _charstring_type},
    {(char *)"private-domain-name", (char *)"PrivateDomainName", _choice_type},
    {(char *)"numeric", (char *)"Character String", _charstring_type},
    {(char *)"printable", (char *)"Character String", _charstring_type},
    {(char *)"terminal-identifier", (char *)"TerminalIdentifier", _charstring_type},
    {(char *)"network-address", (char *)"NetworkAddress", _charstring_type},
    {(char *)"administration-domain-name", (char *)"AdministrationDomainName", _choice_type},
    {(char *)"country-name", (char *)"CountryName", _choice_type},
    {(char *)"x121-dcc-code", (char *)"Character String", _charstring_type},
    {(char *)"iso-3166-alpha2-code", (char *)"Character String", _charstring_type},
    {(char *)"CommonName", (char *)"Character String", _charstring_type},
    {(char *)"TeletexCommonName", (char *)"Character String", _charstring_type},
    {(char *)"TeletexOrganizationName", (char *)"Character String", _charstring_type},
    {(char *)"TeletexPersonalName", (char *)"SET", _set_type},
    {(char *)"TeletexOrganizationalUnitNames", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"TeletexOrganizationalUnitName", _charstring_type},
    {(char *)"PDSName", (char *)"Character String", _charstring_type},
    {(char *)"PhysicalDeliveryCountryName", (char *)"CHOICE", _choice_type},
    {(char *)"PostalCode", (char *)"CHOICE", _choice_type},
    {(char *)"numeric-code", (char *)"Character String", _charstring_type},
    {(char *)"printable-code", (char *)"Character String", _charstring_type},
    {(char *)"PhysicalDeliveryOfficeName", (char *)"SET", _set_type},
    {(char *)"PhysicalDeliveryOfficeNumber", (char *)"SET", _set_type},
    {(char *)"ExtensionORAddressComponents", (char *)"SET", _set_type},
    {(char *)"PhysicalDeliveryPersonalName", (char *)"SET", _set_type},
    {(char *)"PhysicalDeliveryOrganizationName", (char *)"SET", _set_type},
    {(char *)"ExtensionPhysicalDeliveryAddressComponents", (char *)"SET", _set_type},
    {(char *)"UnformattedPostalAddress", (char *)"SET", _set_type},
    {(char *)"printable-address", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"Character String", _charstring_type},
    {(char *)"StreetAddress", (char *)"SET", _set_type},
    {(char *)"PostOfficeBoxAddress", (char *)"SET", _set_type},
    {(char *)"PosteRestanteAddress", (char *)"SET", _set_type},
    {(char *)"UniquePostalName", (char *)"SET", _set_type},
    {(char *)"LocalPostalAttributes", (char *)"SET", _set_type},
    {(char *)"ExtendedNetworkAddress", (char *)"CHOICE", _choice_type},
    {(char *)"e163-4-address", (char *)"SEQUENCE", _sequence_type},
    {(char *)"sub-address", (char *)"Character String", _charstring_type},
    {(char *)"number", (char *)"Character String", _charstring_type},
    {(char *)"psap-address", (char *)"PresentationAddress", _sequence_type},
    {(char *)"nAddresses", (char *)"SET OF", _set_of_type},
    {NULL, (char *)"OCTET STRING", _octetstring_type},
    {(char *)"tSelector", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"sSelector", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"pSelector", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"TerminalType", (char *)"INTEGER", _integer_type},
    {(char *)"TeletexDomainDefinedAttributes", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"TeletexDomainDefinedAttribute", _sequence_type},
    {(char *)"AuthPack_OLD", (char *)"SEQUENCE", _sequence_type},
    {(char *)"pkAuthenticator", (char *)"PKAuthenticator_OLD", _sequence_type},
    {(char *)"kdc-realm", (char *)"Realm", _charstring_type},
    {(char *)"kdc-name", (char *)"PrincipalName", _sequence_type},
    {(char *)"KERB-REPLY-KEY-PACKAGE", (char *)"SEQUENCE", _sequence_type},
    {(char *)"PA-FOR-USER-ENC", (char *)"SEQUENCE", _sequence_type},
    {(char *)"auth-package", (char *)"KerberosString", _charstring_type},
    {(char *)"userRealm", (char *)"Realm", _charstring_type},
    {(char *)"userName", (char *)"PrincipalName", _sequence_type},
    {(char *)"PA-S4U-X509-USER", (char *)"SEQUENCE", _sequence_type},
    {(char *)"checksum", (char *)"Checksum", _sequence_type},
    {(char *)"user-id", (char *)"S4UUserID", _sequence_type},
    {(char *)"options", (char *)"BIT STRING", _bitstring_type},
    {(char *)"subject-certificate", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"PA-PAC-OPTIONS", (char *)"SEQUENCE", _sequence_type},
    {(char *)"kerberosFlags", (char *)"KerberosFlags", _bitstring_type},
    {(char *)"KERB-PA-PAC-REQUEST", (char *)"SEQUENCE", _sequence_type},
    {(char *)"include-pac", (char *)"BOOLEAN", _boolean_type},
    {(char *)"KERB-LOCAL", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"KERB-AD-RESTRICTION-ENTRY", (char *)"SEQUENCE", _sequence_type},
    {(char *)"restriction", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"restriction-type", (char *)"Int32", _integer_type},
    {(char *)"PA-SUPPORTED-ENCTYPES", (char *)"INTEGER", _integer_type}
};
#endif


#ifdef OSS_NO_DETAIL_MM_ERROR_CODES
void DLL_ENTRY_FDEF _oeMS_SFU_KILE(OssGlobal * _g, int _pdunum, void * _inbuf)
{
    (void)_pdunum;	/* to avoid C-compilation warning */
    (void)_inbuf;	/* to avoid C-compilation warning */
    _oss_toed_error(_g, _unlinked_encrules_err, "OER/COER");
}

void * DLL_ENTRY_FDEF _odMS_SFU_KILE(OssGlobal * _g, int _pdunum)
{
    (void)_pdunum;	/* to avoid C-compilation warning */
    _oss_toed_error(_g, _unlinked_encrules_err, "OER/COER");
    return NULL;
}

#endif
#if OSS_TOED_API_LEVEL >= 34
void DLL_ENTRY_FDEF _jeMS_SFU_KILE(OssGlobal * _g, int _pdunum, void * _inbuf)
{
    (void)_pdunum;	/* to avoid C-compilation warning */
    (void)_inbuf;	/* to avoid C-compilation warning */
    _oss_toed_error(_g, _unlinked_encrules_err, "JSON");
}

void * DLL_ENTRY_FDEF _jdMS_SFU_KILE(OssGlobal * _g, int _pdunum)
{
    (void)_pdunum;	/* to avoid C-compilation warning */
    _oss_toed_error(_g, _unlinked_encrules_err, "JSON");
    return NULL;
}

#endif
#if OSS_TOED_API_LEVEL >= 41
void DLL_ENTRY_FDEF _veMS_SFU_KILE(OssGlobal * _g, int _pdunum, void * _inbuf)
{
    (void)_pdunum;	/* to avoid C-compilation warning */
    (void)_inbuf;	/* to avoid C-compilation warning */
    _oss_toed_error(_g, _unlinked_encrules_err, "AVN");
}

void * DLL_ENTRY_FDEF _vdMS_SFU_KILE(OssGlobal * _g, int _pdunum)
{
    (void)_pdunum;	/* to avoid C-compilation warning */
    _oss_toed_error(_g, _unlinked_encrules_err, "AVN");
    return NULL;
}

#endif
static long _edTicket(OssGlobal * _g, char ** _out_pos, long * _max_len, _Ticket * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 0)
	_data_len = _edEncryptedData(_g, _out_pos, &_out_len, &_in_data->enc_part);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(1)
	_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->sname);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(2)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->realm.value, _in_data->realm.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(3)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->tkt_vno, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edKDC_REQ_BODY(OssGlobal * _g, char ** _out_pos, long * _max_len, _KDC_REQ_BODY * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 4)
	if (_in_data->bit_mask & 0x8000000) {
	    _data_len = _ed_seqof3(_g, _out_pos, &_out_len, &_in_data->additional_tickets);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xAB);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(5)
	if (_in_data->bit_mask & 0x10000000) {
	    _data_len = _edEncryptedData(_g, _out_pos, &_out_len, &_in_data->enc_authorization_data);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xAA);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(6)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _edHostAddresses(_g, _out_pos, &_out_len, &_in_data->addresses);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA9);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(7)
	_data_len = _ed_seqof2(_g, _out_pos, &_out_len, &_in_data->etype);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA8);
	_total_len += _data_len;
	OSS_CNTX_SET(8)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->nonce, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
	_total_len += _data_len;
	OSS_CNTX_SET(9)
	if (_in_data->rtime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->rtime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->rtime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA6);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(10)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->till == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->till, -1, 0);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA5);
	_total_len += _data_len;
	OSS_CNTX_SET(11)
	if (_in_data->from) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->from == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->from, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA4);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(1)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->sname);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(2)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->realm.value, _in_data->realm.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(12)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->cname);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(13)
	_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->kdc_options.value, _in_data->kdc_options.length, -1, FALSE);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seqof1(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	_seqof1 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 14)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof1 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edPrincipalName(OssGlobal * _g, char ** _out_pos, long * _max_len, _PrincipalName * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 15)
	_data_len = _ed_seqof1(_g, _out_pos, &_out_len, &_in_data->name_string);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(16)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->name_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edHostAddress(OssGlobal * _g, char ** _out_pos, long * _max_len, _HostAddress * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 17)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->address.value, _in_data->address.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(18)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->addr_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edHostAddresses(OssGlobal * _g, char ** _out_pos, long * _max_len, _HostAddresses ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_HostAddresses * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 19)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_HostAddresses *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edHostAddress(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seq1(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq1 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 20)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->ad_data.value, _in_data->ad_data.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(21)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->ad_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edAuthorizationData(OssGlobal * _g, char ** _out_pos, long * _max_len, _AuthorizationData ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_AuthorizationData * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 22)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_AuthorizationData *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _ed_seq1(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edPA_DATA(OssGlobal * _g, char ** _out_pos, long * _max_len, _PA_DATA * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 23)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->padata_value.value, _in_data->padata_value.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(24)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->padata_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edEncryptedData(OssGlobal * _g, char ** _out_pos, long * _max_len, _EncryptedData * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 25)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->cipher.value, _in_data->cipher.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(26)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->kvno, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(27)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->etype, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edEncryptionKey(OssGlobal * _g, char ** _out_pos, long * _max_len, _EncryptionKey * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 28)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->keyvalue.value, _in_data->keyvalue.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(29)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->keytype, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edChecksum(OssGlobal * _g, char ** _out_pos, long * _max_len, _Checksum * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 30)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->checksum.value, _in_data->checksum.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(31)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->cksumtype, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seqof2(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof2 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_seqof2 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 32)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof2 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value, 0x2);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seqof3(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof3 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_seqof3 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 33)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof3 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edTicket(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x61);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seqof4(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof4 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_seqof4 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 34)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof4 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edPA_DATA(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edKDC_REQ(OssGlobal * _g, char ** _out_pos, long * _max_len, _KDC_REQ * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 35)
	_data_len = _edKDC_REQ_BODY(_g, _out_pos, &_out_len, &_in_data->req_body);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA4);
	_total_len += _data_len;
	OSS_CNTX_SET(36)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _ed_seqof4(_g, _out_pos, &_out_len, &_in_data->padata);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(37)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->msg_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pvno, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seqof5(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof4 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_seqof4 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 34)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof4 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edPA_DATA(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edKDC_REP(OssGlobal * _g, char ** _out_pos, long * _max_len, _KDC_REP * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 0)
	_data_len = _edEncryptedData(_g, _out_pos, &_out_len, &_in_data->enc_part);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA6);
	_total_len += _data_len;
	OSS_CNTX_SET(39)
	_data_len = _edTicket(_g, _out_pos, &_out_len, &_in_data->ticket);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x61);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA5);
	_total_len += _data_len;
	OSS_CNTX_SET(12)
	_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->cname);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA4);
	_total_len += _data_len;
	OSS_CNTX_SET(40)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->crealm.value, _in_data->crealm.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(36)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _ed_seqof5(_g, _out_pos, &_out_len, &_in_data->padata);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(37)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->msg_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pvno, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seqof6(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof4 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_seqof4 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 34)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof4 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edPA_DATA(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edEncKDCRepPart(OssGlobal * _g, char ** _out_pos, long * _max_len, _EncKDCRepPart * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 41)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _ed_seqof6(_g, _out_pos, &_out_len, &_in_data->encrypted_pa_data);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xAC);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(42)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edHostAddresses(_g, _out_pos, &_out_len, &_in_data->caddr);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xAB);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(1)
	_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->sname);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xAA);
	_total_len += _data_len;
	OSS_CNTX_SET(43)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->srealm.value, _in_data->srealm.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA9);
	_total_len += _data_len;
	OSS_CNTX_SET(44)
	if (_in_data->renew_till) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->renew_till == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->renew_till, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA8);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(45)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->endtime == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->endtime, -1, 0);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA7);
	_total_len += _data_len;
	OSS_CNTX_SET(46)
	if (_in_data->starttime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->starttime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->starttime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA6);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(47)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->authtime == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->authtime, -1, 0);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA5);
	_total_len += _data_len;
	OSS_CNTX_SET(48)
	_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->flags.value, _in_data->flags.length, -1, FALSE);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3, 0xA4);
	_total_len += _data_len;
	OSS_CNTX_SET(49)
	if (_in_data->key_expiration) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->key_expiration == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->key_expiration, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(8)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->nonce, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(50)
	_data_len = _edLastReq(_g, _out_pos, &_out_len, &_in_data->last_req);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(51)
	_data_len = _edEncryptionKey(_g, _out_pos, &_out_len, &_in_data->key);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seq2(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq2 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 52)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->lr_value == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->lr_value, -1, 0);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(53)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->lr_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edLastReq(OssGlobal * _g, char ** _out_pos, long * _max_len, _LastReq ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_LastReq * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 22)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_LastReq *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _ed_seq2(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edExternalPrincipalIdentifier(OssGlobal * _g, char ** _out_pos, long * _max_len, _ExternalPrincipalIdentifier * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 54)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->subjectKeyIdentifier.value, _in_data->subjectKeyIdentifier.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA2 : 0x82);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(55)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->issuerAndSerialNumber.value, _in_data->issuerAndSerialNumber.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(56)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->subjectName.value, _in_data->subjectName.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edAlgorithmIdentifier(OssGlobal * _g, char ** _out_pos, long * _max_len, _AlgorithmIdentifier * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 57)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_uany(_g, _out_pos, &_out_len, (unsigned char *)_in_data->parameters.value, _in_data->parameters.length);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(58)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->algorithm.value, _in_data->algorithm.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edSubjectPublicKeyInfo(OssGlobal * _g, char ** _out_pos, long * _max_len, _SubjectPublicKeyInfo * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 59)
	_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->subjectPublicKey.value, _in_data->subjectPublicKey.length, -1, FALSE);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
	_total_len += _data_len;
	OSS_CNTX_SET(60)
	_data_len = _edAlgorithmIdentifier(_g, _out_pos, &_out_len, &_in_data->algorithm);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edName(OssGlobal * _g, char ** _out_pos, long * _max_len, _Name * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 61)
	    _data_len = _edRDNSequence(_g, _out_pos, &_out_len, &_in_data->u.rdnSequence);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edRDNSequence(OssGlobal * _g, char ** _out_pos, long * _max_len, _RDNSequence ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_RDNSequence * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 62)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_RDNSequence *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    {
		_RelativeDistinguishedName * _temp1;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_CNTX_NEW(_oss_c, 63)
		for (_temp1 = _temp->value, count = 0; _temp1; _temp1 = _temp1->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp1;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp1 = (_RelativeDistinguishedName *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 64)
			_data_len = _oss_encd_uany(_g, _out_pos, &_out_len, (unsigned char *)_temp1->value.value.value, _temp1->value.value.length);
			_total_len += _data_len;
			OSS_CNTX_SET(65)
			_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp1->value.type.value, _temp1->value.type.length, -1);
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
			_total_len += _data_len;
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _total_len += _data_len;
		}
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edTime(OssGlobal * _g, char ** _out_pos, long * _max_len, _Time * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 66)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.utcTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->u.utcTime, -1, 1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x37 : 0x17);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 67)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.generalTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->u.generalTime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edExtension(OssGlobal * _g, char ** _out_pos, long * _max_len, _Extension * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 68)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->extnValue.value, _in_data->extnValue.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(69)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->critical, (ossBoolean  *)&Extension::default_critical, sizeof(ossBoolean ), 0, -1, 8)) {
	    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _in_data->critical);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(70)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->extnID.value, _in_data->extnID.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edExtensions(OssGlobal * _g, char ** _out_pos, long * _max_len, _Extensions ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_Extensions * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 71)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_Extensions *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edExtension(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edPDSParameter(OssGlobal * _g, char ** _out_pos, long * _max_len, _PDSParameter * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 72)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->teletex_string.value, _in_data->teletex_string.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(73)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->printable_string.value, _in_data->printable_string.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _eTicket(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Ticket	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_Ticket *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(1,74)
    _data_len = _edTicket(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x61);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eEncTicketPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncTicketPart	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_EncTicketPart *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(2,75)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 76)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edAuthorizationData(_g, _out_pos, &_out_len, &_in_data->authorization_data);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xAA);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(42)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edHostAddresses(_g, _out_pos, &_out_len, &_in_data->caddr);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA9);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(44)
	if (_in_data->renew_till) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->renew_till == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->renew_till, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA8);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(45)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->endtime == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->endtime, -1, 0);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA7);
	_total_len += _data_len;
	OSS_CNTX_SET(46)
	if (_in_data->starttime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->starttime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->starttime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA6);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(47)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->authtime == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->authtime, -1, 0);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA5);
	_total_len += _data_len;
	OSS_CNTX_SET(77)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 78)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->transited.contents.value, _in_data->transited.contents.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
	    _total_len += _data_len;
	    OSS_CNTX_SET(79)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->transited.tr_type, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA4);
	_total_len += _data_len;
	OSS_CNTX_SET(12)
	_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->cname);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(40)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->crealm.value, _in_data->crealm.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(51)
	_data_len = _edEncryptionKey(_g, _out_pos, &_out_len, &_in_data->key);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(48)
	_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->flags.value, _in_data->flags.length, -1, FALSE);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x63);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAS_REQ(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDC_REQ	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_KDC_REQ *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(3,80)
    _data_len = _edKDC_REQ(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x6A);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTGS_REQ(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDC_REQ	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_KDC_REQ *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(4,81)
    _data_len = _edKDC_REQ(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x6C);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKDC_REQ_BODY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDC_REQ_BODY	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_KDC_REQ_BODY *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(5,82)
    _data_len = _edKDC_REQ_BODY(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAS_REP(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDC_REP	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_KDC_REP *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(6,83)
    _data_len = _edKDC_REP(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x6B);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTGS_REP(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDC_REP	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_KDC_REP *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(7,84)
    _data_len = _edKDC_REP(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x6D);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eEncASRepPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncKDCRepPart	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_EncKDCRepPart *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(8,85)
    _data_len = _edEncKDCRepPart(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x79);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eEncTGSRepPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncKDCRepPart	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_EncKDCRepPart *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(9,86)
    _data_len = _edEncKDCRepPart(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x7A);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAP_REQ(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AP_REQ	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_AP_REQ *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(10,87)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 88)
	_data_len = _edEncryptedData(_g, _out_pos, &_out_len, &_in_data->authenticator);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA4);
	_total_len += _data_len;
	OSS_CNTX_SET(39)
	_data_len = _edTicket(_g, _out_pos, &_out_len, &_in_data->ticket);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x61);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(89)
	_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->ap_options.value, _in_data->ap_options.length, -1, FALSE);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(37)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->msg_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pvno, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x6E);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAuthenticator(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Authenticator	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_Authenticator *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(11,90)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 76)
	if (_in_data->bit_mask & 0x10000000) {
	    _data_len = _edAuthorizationData(_g, _out_pos, &_out_len, &_in_data->authorization_data);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA8);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(91)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->seq_number, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(92)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edEncryptionKey(_g, _out_pos, &_out_len, &_in_data->subkey);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA6);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(93)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->ctime == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->ctime, -1, 0);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA5);
	_total_len += _data_len;
	OSS_CNTX_SET(94)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->cusec, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
	_total_len += _data_len;
	OSS_CNTX_SET(95)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edChecksum(_g, _out_pos, &_out_len, &_in_data->cksum);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(12)
	_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->cname);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(40)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->crealm.value, _in_data->crealm.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(96)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->authenticator_vno, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x62);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAP_REP(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AP_REP	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_AP_REP *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(12,97)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 0)
	_data_len = _edEncryptedData(_g, _out_pos, &_out_len, &_in_data->enc_part);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(37)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->msg_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pvno, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x6F);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eEncAPRepPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncAPRepPart	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_EncAPRepPart *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(13,98)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 91)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->seq_number, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(92)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edEncryptionKey(_g, _out_pos, &_out_len, &_in_data->subkey);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(94)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->cusec, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(93)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->ctime == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->ctime, -1, 0);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x7B);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKRB_SAFE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KRB_SAFE	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_KRB_SAFE *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(14,99)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 95)
	_data_len = _edChecksum(_g, _out_pos, &_out_len, &_in_data->cksum);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(100)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 101)
	    if (_in_data->safe_body.bit_mask & 0x20000000) {
		_data_len = _edHostAddress(_g, _out_pos, &_out_len, &_in_data->safe_body.r_address);
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA5);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(102)
	    _data_len = _edHostAddress(_g, _out_pos, &_out_len, &_in_data->safe_body.s_address);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA4);
	    _total_len += _data_len;
	    OSS_CNTX_SET(91)
	    if (_in_data->safe_body.bit_mask & 0x40000000) {
		_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->safe_body.seq_number, 0x2);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(103)
	    if (_in_data->safe_body.bit_mask & 0x80000000) {
		_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->safe_body.usec, 0x2);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(104)
	    if (_in_data->safe_body.timestamp) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_in_data->safe_body.timestamp == NULL)
		    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
		_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->safe_body.timestamp, -1, 0);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA1);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(105)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->safe_body.user_data.value, _in_data->safe_body.user_data.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(37)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->msg_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pvno, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x74);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKRB_PRIV(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AP_REP	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_AP_REP *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(15,106)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 0)
	_data_len = _edEncryptedData(_g, _out_pos, &_out_len, &_in_data->enc_part);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(37)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->msg_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pvno, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x75);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eEncKrbPrivPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KRB_SAFE_BODY	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_KRB_SAFE_BODY *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(16,107)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 101)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _edHostAddress(_g, _out_pos, &_out_len, &_in_data->r_address);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA5);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(102)
	_data_len = _edHostAddress(_g, _out_pos, &_out_len, &_in_data->s_address);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA4);
	_total_len += _data_len;
	OSS_CNTX_SET(91)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->seq_number, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(103)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->usec, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(104)
	if (_in_data->timestamp) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->timestamp == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->timestamp, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(105)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->user_data.value, _in_data->user_data.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x7C);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKRB_CRED(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KRB_CRED	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_KRB_CRED *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(17,108)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 0)
	_data_len = _edEncryptedData(_g, _out_pos, &_out_len, &_in_data->enc_part);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(109)
	{
	    _seqof3 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 33)
	    for (_temp = _in_data->tickets, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_seqof3 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		_oss_save_enc_stack(_g, _sp);
		_data_len = _edTicket(_g, _out_pos, &_out_len, &_temp->value);
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x61);
		_st = _oss_load_enc_stack(_g, &_sp);
		_total_len += _data_len;
	    }
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(37)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->msg_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pvno, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x76);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eEncKrbCredPart(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncKrbCredPart	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_EncKrbCredPart *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(18,110)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 101)
	if (_in_data->bit_mask & 0x10000000) {
	    _data_len = _edHostAddress(_g, _out_pos, &_out_len, &_in_data->r_address);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA5);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(102)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _edHostAddress(_g, _out_pos, &_out_len, &_in_data->s_address);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA4);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(103)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->usec, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(104)
	if (_in_data->timestamp) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->timestamp == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->timestamp, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(8)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->nonce, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(111)
	{
	    _seqof8 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 112)
	    for (_temp = _in_data->ticket_info, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_seqof8 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		_oss_save_enc_stack(_g, _sp);
		{
		    long _total_len = 0;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 42)
		    if (_temp->value.bit_mask & 0x4000000) {
			_data_len = _edHostAddresses(_g, _out_pos, &_out_len, &_temp->value.caddr);
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xAA);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(1)
		    if (_temp->value.bit_mask & 0x8000000) {
			_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_temp->value.sname);
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA9);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(43)
		    if (_temp->value.bit_mask & 0x10000000) {
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.srealm.value, _temp->value.srealm.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA8);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(44)
		    if (_temp->value.renew_till) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.renew_till == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _temp->value.renew_till, -1, 0);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA7);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(45)
		    if (_temp->value.endtime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.endtime == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _temp->value.endtime, -1, 0);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA6);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(46)
		    if (_temp->value.starttime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.starttime == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _temp->value.starttime, -1, 0);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA5);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(47)
		    if (_temp->value.authtime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.authtime == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _temp->value.authtime, -1, 0);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA4);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(48)
		    if (_temp->value.bit_mask & 0x20000000) {
			_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _temp->value.flags.value, _temp->value.flags.length, -1, FALSE);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3, 0xA3);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(113)
		    if (_temp->value.bit_mask & 0x40000000) {
			_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_temp->value.pname);
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(114)
		    if (_temp->value.bit_mask & 0x80000000) {
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.prealm.value, _temp->value.prealm.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA1);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(51)
		    _data_len = _edEncryptionKey(_g, _out_pos, &_out_len, &_temp->value.key);
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
		    _total_len += _data_len;
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		_st = _oss_load_enc_stack(_g, &_sp);
		_total_len += _data_len;
	    }
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x7D);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKRB_ERROR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KRB_ERROR	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_KRB_ERROR *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(19,115)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 116)
	if (_in_data->bit_mask & 0x8000000) {
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->e_data.value, _in_data->e_data.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xAC);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(117)
	if (_in_data->bit_mask & 0x10000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->e_text.value, _in_data->e_text.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xAB);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(1)
	_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->sname);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xAA);
	_total_len += _data_len;
	OSS_CNTX_SET(2)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->realm.value, _in_data->realm.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA9);
	_total_len += _data_len;
	OSS_CNTX_SET(12)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->cname);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA8);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(40)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->crealm.value, _in_data->crealm.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA7);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(118)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->error_code, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
	_total_len += _data_len;
	OSS_CNTX_SET(119)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->susec, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA5);
	_total_len += _data_len;
	OSS_CNTX_SET(120)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->stime == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->stime, -1, 0);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA4);
	_total_len += _data_len;
	OSS_CNTX_SET(94)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->cusec, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(93)
	if (_in_data->ctime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->ctime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->ctime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(37)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->msg_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pvno, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0x7E);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eMETHOD_DATA(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof4	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_seqof4 **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(20,121)
    {
	_seqof4 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 34)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof4 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edPA_DATA(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTYPED_DATA(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TYPED_DATA	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_TYPED_DATA **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(21,122)
    {
	_TYPED_DATA * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 22)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_TYPED_DATA *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 123)
		if (_temp->value.bit_mask & 0x80000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.data_value.value, _temp->value.data_value.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(124)
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value.data_type, 0x2);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePA_ENC_TIMESTAMP(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncryptedData	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_EncryptedData *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(22,125)
    _data_len = _edEncryptedData(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePA_ENC_TS_ENC(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_ENC_TS_ENC	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_PA_ENC_TS_ENC *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(23,126)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 127)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pausec, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(128)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->patimestamp == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->patimestamp, -1, 0);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eETYPE_INFO(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ETYPE_INFO	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_ETYPE_INFO **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(24,129)
    {
	_ETYPE_INFO * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 130)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_ETYPE_INFO *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 131)
		if (_temp->value.bit_mask & 0x80000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.salt.value, _temp->value.salt.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(27)
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value.etype, 0x2);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eETYPE_INFO2(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ETYPE_INFO2	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_ETYPE_INFO2 **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(25,132)
    {
	_ETYPE_INFO2 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 133)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_ETYPE_INFO2 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 134)
		if (_temp->value.bit_mask & 0x40000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.s2kparams.value, _temp->value.s2kparams.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA2);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(135)
		if (_temp->value.bit_mask & 0x80000000) {
		    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.salt.value, _temp->value.salt.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA1);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(27)
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value.etype, 0x2);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAD_IF_RELEVANT(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AuthorizationData	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_AuthorizationData **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(26,136)
    _data_len = _edAuthorizationData(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAD_KDCIssued(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AD_KDCIssued	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_AD_KDCIssued *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(27,137)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 138)
	_data_len = _edAuthorizationData(_g, _out_pos, &_out_len, &_in_data->elements);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(139)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->i_sname);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(140)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->i_realm.value, _in_data->i_realm.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(141)
	_data_len = _edChecksum(_g, _out_pos, &_out_len, &_in_data->ad_checksum);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAD_AND_OR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AD_AND_OR	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_AD_AND_OR *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(28,142)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 138)
	_data_len = _edAuthorizationData(_g, _out_pos, &_out_len, &_in_data->elements);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(143)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->condition_count, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAD_MANDATORY_FOR_KDC(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AuthorizationData	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_AuthorizationData **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(29,144)
    _data_len = _edAuthorizationData(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eChangePasswdData(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ChangePasswdData	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_ChangePasswdData *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(30,145)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 146)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->targrealm.value, _in_data->targrealm.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(147)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->targname);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(148)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->newpasswd.value, _in_data->newpasswd.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePA_PK_AS_REQ(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_PK_AS_REQ	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_PA_PK_AS_REQ *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(31,149)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 150)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->kdcPkId.value, _in_data->kdcPkId.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA2 : 0x82);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(151)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_seqof9 * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 152)
		for (_temp = _in_data->trustedCertifiers, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_seqof9 *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    _data_len = _edExternalPrincipalIdentifier(_g, _out_pos, &_out_len, &_temp->value);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(153)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->signedAuthPack.value, _in_data->signedAuthPack.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAuthPack(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AuthPack	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_AuthPack *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(32,154)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 155)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->clientDHNonce.value, _in_data->clientDHNonce.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(156)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		_seqof10 * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 157)
		for (_temp = _in_data->supportedCMSTypes, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_seqof10 *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    _data_len = _edAlgorithmIdentifier(_g, _out_pos, &_out_len, &_temp->value);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(158)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edSubjectPublicKeyInfo(_g, _out_pos, &_out_len, &_in_data->clientPublicValue);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(159)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 160)
	    if (_in_data->pkAuthenticator.bit_mask & 0x80000000) {
		_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->pkAuthenticator.paChecksum.value, _in_data->pkAuthenticator.paChecksum.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA3);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(161)
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pkAuthenticator.nonce, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    _total_len += _data_len;
	    OSS_CNTX_SET(93)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->pkAuthenticator.ctime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->pkAuthenticator.ctime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA1);
	    _total_len += _data_len;
	    OSS_CNTX_SET(162)
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->pkAuthenticator.cusec, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTD_TRUSTED_CERTIFIERS(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof9	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_seqof9 **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(33,163)
    {
	_seqof9 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 152)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof9 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edExternalPrincipalIdentifier(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTD_INVALID_CERTIFICATES(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof9	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_seqof9 **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(34,164)
    {
	_seqof9 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 152)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof9 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edExternalPrincipalIdentifier(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKRB5PrincipalName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KRB5PrincipalName	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_KRB5PrincipalName *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(35,165)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 166)
	_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->principalName);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(2)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->realm.value, _in_data->realm.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAD_INITIAL_VERIFIED_CAS(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof9	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_seqof9 **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(36,167)
    {
	_seqof9 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 152)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof9 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edExternalPrincipalIdentifier(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePA_PK_AS_REP(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_PK_AS_REP	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_PA_PK_AS_REP *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(37,168)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 169)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.dhInfo == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 170)
		if (_in_data->u.dhInfo->bit_mask & 0x80000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.dhInfo->serverDHNonce.value, _in_data->u.dhInfo->serverDHNonce.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(171)
		_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.dhInfo->dhSignedData.value, _in_data->u.dhInfo->dhSignedData.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 172)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.encKeyPack.value, _in_data->u.encKeyPack.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKDCDHKeyInfo(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDCDHKeyInfo	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_KDCDHKeyInfo *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(38,173)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 174)
	if (_in_data->dhKeyExpiration) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->dhKeyExpiration == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->dhKeyExpiration, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(161)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->nonce, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(59)
	_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->subjectPublicKey.value, _in_data->subjectPublicKey.length, -1, FALSE);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eReplyKeyPack(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ReplyKeyPack	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_ReplyKeyPack *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(39,175)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 176)
	_data_len = _edChecksum(_g, _out_pos, &_out_len, &_in_data->asChecksum);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(177)
	_data_len = _edEncryptionKey(_g, _out_pos, &_out_len, &_in_data->replyKey);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTD_DH_PARAMETERS(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof10	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_seqof10 **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(40,178)
    {
	_seqof10 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 157)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof10 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edAlgorithmIdentifier(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAttribute(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Attribute	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_Attribute *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(41,179)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 180)
	{
	    _seqof1 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 181)
	    for (_temp = _in_data->values, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_seqof1 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		if (count > 1) _oss_nextItem(_g, &_out_len);
		_data_len = _oss_encd_uany(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.value, _temp->value.length);
		_total_len += _data_len;
	    }
	    _oss_save_enc_stack(_g, _sp);
	    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	_total_len += _data_len;
	OSS_CNTX_SET(65)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->type.value, _in_data->type.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520name(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_X520name *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(42,182)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.teletexString.value, _in_data->u.teletexString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printableString.value, _in_data->u.printableString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _data_len = _oss_encd_unistr_ia(_g, _out_pos, &_out_len, (int *)_in_data->u.universalString.value, _in_data->u.universalString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3C : 0x1C);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.utf8String.value, _in_data->u.utf8String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _data_len = _oss_encd_bmpstr_ia(_g, _out_pos, &_out_len, _in_data->u.bmpString.value, _in_data->u.bmpString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3E : 0x1E);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520CommonName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_X520name *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(43,188)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.teletexString.value, _in_data->u.teletexString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printableString.value, _in_data->u.printableString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _data_len = _oss_encd_unistr_ia(_g, _out_pos, &_out_len, (int *)_in_data->u.universalString.value, _in_data->u.universalString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3C : 0x1C);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.utf8String.value, _in_data->u.utf8String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _data_len = _oss_encd_bmpstr_ia(_g, _out_pos, &_out_len, _in_data->u.bmpString.value, _in_data->u.bmpString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3E : 0x1E);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520LocalityName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_X520name *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(44,189)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.teletexString.value, _in_data->u.teletexString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printableString.value, _in_data->u.printableString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _data_len = _oss_encd_unistr_ia(_g, _out_pos, &_out_len, (int *)_in_data->u.universalString.value, _in_data->u.universalString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3C : 0x1C);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.utf8String.value, _in_data->u.utf8String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _data_len = _oss_encd_bmpstr_ia(_g, _out_pos, &_out_len, _in_data->u.bmpString.value, _in_data->u.bmpString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3E : 0x1E);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520StateOrProvinceName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_X520name *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(45,190)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.teletexString.value, _in_data->u.teletexString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printableString.value, _in_data->u.printableString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _data_len = _oss_encd_unistr_ia(_g, _out_pos, &_out_len, (int *)_in_data->u.universalString.value, _in_data->u.universalString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3C : 0x1C);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.utf8String.value, _in_data->u.utf8String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _data_len = _oss_encd_bmpstr_ia(_g, _out_pos, &_out_len, _in_data->u.bmpString.value, _in_data->u.bmpString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3E : 0x1E);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520OrganizationName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_X520name *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(46,191)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.teletexString.value, _in_data->u.teletexString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printableString.value, _in_data->u.printableString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _data_len = _oss_encd_unistr_ia(_g, _out_pos, &_out_len, (int *)_in_data->u.universalString.value, _in_data->u.universalString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3C : 0x1C);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.utf8String.value, _in_data->u.utf8String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _data_len = _oss_encd_bmpstr_ia(_g, _out_pos, &_out_len, _in_data->u.bmpString.value, _in_data->u.bmpString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3E : 0x1E);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520OrganizationalUnitName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_X520name *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(47,192)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.teletexString.value, _in_data->u.teletexString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printableString.value, _in_data->u.printableString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _data_len = _oss_encd_unistr_ia(_g, _out_pos, &_out_len, (int *)_in_data->u.universalString.value, _in_data->u.universalString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3C : 0x1C);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.utf8String.value, _in_data->u.utf8String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _data_len = _oss_encd_bmpstr_ia(_g, _out_pos, &_out_len, _in_data->u.bmpString.value, _in_data->u.bmpString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3E : 0x1E);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520Title(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_X520name *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(48,193)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.teletexString.value, _in_data->u.teletexString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printableString.value, _in_data->u.printableString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _data_len = _oss_encd_unistr_ia(_g, _out_pos, &_out_len, (int *)_in_data->u.universalString.value, _in_data->u.universalString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3C : 0x1C);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.utf8String.value, _in_data->u.utf8String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _data_len = _oss_encd_bmpstr_ia(_g, _out_pos, &_out_len, _in_data->u.bmpString.value, _in_data->u.bmpString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3E : 0x1E);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520dnQualifier(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(49,194)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520countryName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(50,195)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520SerialNumber(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(51,196)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eX520Pseudonym(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_X520name *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(52,197)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.teletexString.value, _in_data->u.teletexString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printableString.value, _in_data->u.printableString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _data_len = _oss_encd_unistr_ia(_g, _out_pos, &_out_len, (int *)_in_data->u.universalString.value, _in_data->u.universalString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3C : 0x1C);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.utf8String.value, _in_data->u.utf8String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _data_len = _oss_encd_bmpstr_ia(_g, _out_pos, &_out_len, _in_data->u.bmpString.value, _in_data->u.bmpString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3E : 0x1E);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eDomainComponent(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(53,198)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x36 : 0x16);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eEmailAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(54,199)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x36 : 0x16);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eDistinguishedName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RDNSequence	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RDNSequence **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(55,200)
    _data_len = _edRDNSequence(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eDirectoryString(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_X520name *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(56,201)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.teletexString.value, _in_data->u.teletexString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printableString.value, _in_data->u.printableString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _data_len = _oss_encd_unistr_ia(_g, _out_pos, &_out_len, (int *)_in_data->u.universalString.value, _in_data->u.universalString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3C : 0x1C);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.utf8String.value, _in_data->u.utf8String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _data_len = _oss_encd_bmpstr_ia(_g, _out_pos, &_out_len, _in_data->u.bmpString.value, _in_data->u.bmpString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3E : 0x1E);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eCertificate(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Certificate	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_Certificate *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(57,202)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 203)
	_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->signature.value, _in_data->signature.length, -1, FALSE);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
	_total_len += _data_len;
	OSS_CNTX_SET(204)
	_data_len = _edAlgorithmIdentifier(_g, _out_pos, &_out_len, &_in_data->signatureAlgorithm);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(205)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 206)
	    if (_in_data->tbsCertificate.bit_mask & 0x10000000) {
		_data_len = _edExtensions(_g, _out_pos, &_out_len, &_in_data->tbsCertificate.extensions);
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(207)
	    if (_in_data->tbsCertificate.bit_mask & 0x20000000) {
		_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->tbsCertificate.subjectUniqueID.value, _in_data->tbsCertificate.subjectUniqueID.length, -1, FALSE);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA2 : 0x82);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(208)
	    if (_in_data->tbsCertificate.bit_mask & 0x40000000) {
		_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->tbsCertificate.issuerUniqueID.value, _in_data->tbsCertificate.issuerUniqueID.length, -1, FALSE);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(209)
	    _data_len = _edSubjectPublicKeyInfo(_g, _out_pos, &_out_len, &_in_data->tbsCertificate.subjectPublicKeyInfo);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_SET(210)
	    _data_len = _edName(_g, _out_pos, &_out_len, &_in_data->tbsCertificate.subject);
	    _total_len += _data_len;
	    OSS_CNTX_SET(211)
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 212)
		_data_len = _edTime(_g, _out_pos, &_out_len, &_in_data->tbsCertificate.validity.notAfter);
		_total_len += _data_len;
		OSS_CNTX_SET(213)
		_data_len = _edTime(_g, _out_pos, &_out_len, &_in_data->tbsCertificate.validity.notBefore);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_SET(214)
	    _data_len = _edName(_g, _out_pos, &_out_len, &_in_data->tbsCertificate.issuer);
	    _total_len += _data_len;
	    OSS_CNTX_SET(215)
	    _data_len = _edAlgorithmIdentifier(_g, _out_pos, &_out_len, &_in_data->tbsCertificate.signature);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_SET(216)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->tbsCertificate.serialNumber, 0x2);
	    _total_len += _data_len;
	    OSS_CNTX_SET(217)
	    if (_in_data->tbsCertificate.bit_mask & 0x80000000 &&
		_oss_not_dflt_ia(_g, &_in_data->tbsCertificate.version, (OSS_INT32  *)&TBSCertificate::default_version, sizeof(OSS_INT32 ), 0, -1, 0)) {
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->tbsCertificate.version, 0x2);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		_total_len += _data_len;
	    }
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eCertificateList(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CertificateList	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_CertificateList *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(58,218)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 203)
	_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->signature.value, _in_data->signature.length, -1, FALSE);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
	_total_len += _data_len;
	OSS_CNTX_SET(204)
	_data_len = _edAlgorithmIdentifier(_g, _out_pos, &_out_len, &_in_data->signatureAlgorithm);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(219)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 220)
	    if (_in_data->tbsCertList.bit_mask & 0x10000000) {
		_data_len = _edExtensions(_g, _out_pos, &_out_len, &_in_data->tbsCertList.crlExtensions);
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(221)
	    if (_in_data->tbsCertList.bit_mask & 0x20000000) {
		{
		    _seqof11 * _temp;
		    unsigned long count;
		    unsigned long _lindex;
		    long _total_len = 0;
		    OSS_UINT32 _sp;
		    void **_st = _oss_load_enc_stack(_g, &_sp);
		    OSS_CNTX_NEW(_oss_c, 22)
		    for (_temp = _in_data->tbsCertList.revokedCertificates, count = 0; _temp; _temp = _temp->next) {
			OSS_CNTX_SETOCC(count + 1)
			if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			_st[_sp++] = _temp;
			count++;
		    }
		    for (_lindex = 0; _lindex < count; _lindex++) {
			OSS_CNTX_SETOCC(count - _lindex)
			_temp = (_seqof11 *)_st[--_sp];
			if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			_oss_save_enc_stack(_g, _sp);
			{
			    long _total_len = 0;
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 222)
			    if (_temp->value.bit_mask & 0x80000000) {
				_data_len = _edExtensions(_g, _out_pos, &_out_len, &_temp->value.crlEntryExtensions);
				_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
				_total_len += _data_len;
			    }
			    OSS_CNTX_SET(223)
			    _data_len = _edTime(_g, _out_pos, &_out_len, &_temp->value.revocationDate);
			    _total_len += _data_len;
			    OSS_CNTX_SET(224)
			    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value.userCertificate, 0x2);
			    _total_len += _data_len;
			    OSS_CNTX_POP(_oss_c)
			    _data_len = _total_len;
			}
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
			_st = _oss_load_enc_stack(_g, &_sp);
			_total_len += _data_len;
		    }
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(225)
	    if (_in_data->tbsCertList.bit_mask & 0x40000000) {
		_data_len = _edTime(_g, _out_pos, &_out_len, &_in_data->tbsCertList.nextUpdate);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(226)
	    _data_len = _edTime(_g, _out_pos, &_out_len, &_in_data->tbsCertList.thisUpdate);
	    _total_len += _data_len;
	    OSS_CNTX_SET(214)
	    _data_len = _edName(_g, _out_pos, &_out_len, &_in_data->tbsCertList.issuer);
	    _total_len += _data_len;
	    OSS_CNTX_SET(215)
	    _data_len = _edAlgorithmIdentifier(_g, _out_pos, &_out_len, &_in_data->tbsCertList.signature);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_SET(217)
	    if (_in_data->tbsCertList.bit_mask & 0x80000000) {
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->tbsCertList.version, 0x2);
		_total_len += _data_len;
	    }
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eORAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ORAddress	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_ORAddress *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(59,227)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 228)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		_ExtensionAttributes * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 229)
		for (_temp = _in_data->extension_attributes, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 256) _oss_enc_error(_g, _too_long, count);
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_ExtensionAttributes *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 230)
			_data_len = _oss_encd_uany(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.extension_attribute_value.value, _temp->value.extension_attribute_value.length);
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
			_total_len += _data_len;
			OSS_CNTX_SET(231)
			_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _temp->value.extension_attribute_type, 0x80);
			_total_len += _data_len;
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(232)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_BuiltInDomainDefinedAttributes * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 233)
		for (_temp = _in_data->built_in_domain_defined_attributes, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 4) _oss_enc_error(_g, _too_long, count);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_BuiltInDomainDefinedAttributes *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 234)
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.value.value, _temp->value.value.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
			_total_len += _data_len;
			OSS_CNTX_SET(235)
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.type.value, _temp->value.type.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
			_total_len += _data_len;
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(236)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 237)
	    if (_in_data->built_in_standard_attributes.bit_mask & 0x800000) {
		{
		    _seqof1 * _temp;
		    unsigned long count;
		    unsigned long _lindex;
		    long _total_len = 0;
		    OSS_UINT32 _sp;
		    void **_st = _oss_load_enc_stack(_g, &_sp);
		    OSS_CNTX_NEW(_oss_c, 238)
		    for (_temp = _in_data->built_in_standard_attributes.organizational_unit_names, count = 0; _temp; _temp = _temp->next) {
			OSS_CNTX_SETOCC(count + 1)
			if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			_st[_sp++] = _temp;
			count++;
		    }
		    if (count > 4) _oss_enc_error(_g, _too_long, count);
		    for (_lindex = 0; _lindex < count; _lindex++) {
			OSS_CNTX_SETOCC(count - _lindex)
			_temp = (_seqof1 *)_st[--_sp];
			if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
			_total_len += _data_len;
		    }
		    _oss_save_enc_stack(_g, _sp);
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(239)
	    if (_in_data->built_in_standard_attributes.bit_mask & 0x1000000) {
		{
		    long _total_len = 0;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 240)
		    if (_in_data->built_in_standard_attributes.personal_name.bit_mask & 0x20000000) {
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.personal_name.generation_qualifier.value, _in_data->built_in_standard_attributes.personal_name.generation_qualifier.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA3 : 0x83);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(241)
		    if (_in_data->built_in_standard_attributes.personal_name.bit_mask & 0x40000000) {
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.personal_name.initials.value, _in_data->built_in_standard_attributes.personal_name.initials.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA2 : 0x82);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(242)
		    if (_in_data->built_in_standard_attributes.personal_name.bit_mask & 0x80000000) {
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.personal_name.given_name.value, _in_data->built_in_standard_attributes.personal_name.given_name.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(243)
		    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.personal_name.surname.value, _in_data->built_in_standard_attributes.personal_name.surname.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
		    _total_len += _data_len;
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA5);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(244)
	    if (_in_data->built_in_standard_attributes.bit_mask & 0x2000000) {
		_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.numeric_user_identifier.value, _in_data->built_in_standard_attributes.numeric_user_identifier.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA4 : 0x84);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(245)
	    if (_in_data->built_in_standard_attributes.bit_mask & 0x4000000) {
		_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.organization_name.value, _in_data->built_in_standard_attributes.organization_name.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA3 : 0x83);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(246)
	    if (_in_data->built_in_standard_attributes.bit_mask & 0x8000000) {
		{
		    OSS_CNTX_INIT

		    switch (_in_data->built_in_standard_attributes.private_domain_name.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 247)
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.private_domain_name.u.numeric.value, _in_data->built_in_standard_attributes.private_domain_name.u.numeric.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x32 : 0x12);
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 248)
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.private_domain_name.u.printable.value, _in_data->built_in_standard_attributes.private_domain_name.u.printable.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _in_data->built_in_standard_attributes.private_domain_name.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(249)
	    if (_in_data->built_in_standard_attributes.bit_mask & 0x10000000) {
		_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.terminal_identifier.value, _in_data->built_in_standard_attributes.terminal_identifier.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(250)
	    if (_in_data->built_in_standard_attributes.bit_mask & 0x20000000) {
		_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.network_address.value, _in_data->built_in_standard_attributes.network_address.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(251)
	    if (_in_data->built_in_standard_attributes.bit_mask & 0x40000000) {
		{
		    OSS_CNTX_INIT

		    switch (_in_data->built_in_standard_attributes.administration_domain_name.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 247)
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.administration_domain_name.u.numeric.value, _in_data->built_in_standard_attributes.administration_domain_name.u.numeric.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x32 : 0x12);
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 248)
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.administration_domain_name.u.printable.value, _in_data->built_in_standard_attributes.administration_domain_name.u.printable.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _in_data->built_in_standard_attributes.administration_domain_name.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x62);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(252)
	    if (_in_data->built_in_standard_attributes.bit_mask & 0x80000000) {
		{
		    OSS_CNTX_INIT

		    switch (_in_data->built_in_standard_attributes.country_name.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 253)
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.country_name.u.x121_dcc_code.value, _in_data->built_in_standard_attributes.country_name.u.x121_dcc_code.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x32 : 0x12);
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 254)
			_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->built_in_standard_attributes.country_name.u.iso_3166_alpha2_code.value, _in_data->built_in_standard_attributes.country_name.u.iso_3166_alpha2_code.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _in_data->built_in_standard_attributes.country_name.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x61);
		_total_len += _data_len;
	    }
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eCommonName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(60,255)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTeletexCommonName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(61,256)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTeletexOrganizationName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(62,257)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTeletexPersonalName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PersonalName	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_PersonalName *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(63,258)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 240)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->generation_qualifier.value, _in_data->generation_qualifier.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA3 : 0x83);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(241)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->initials.value, _in_data->initials.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA2 : 0x82);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(242)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->given_name.value, _in_data->given_name.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(243)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->surname.value, _in_data->surname.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _e0TeletexOrganizationalUnitNa(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof1	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_seqof1 **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(64,259)
    {
	_seqof1 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 260)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 4) _oss_enc_error(_g, _too_long, count);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof1 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePDSName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(65,261)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePhysicalDeliveryCountryName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CountryName	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_CountryName *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(66,262)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 253)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.x121_dcc_code.value, _in_data->u.x121_dcc_code.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x32 : 0x12);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 254)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.iso_3166_alpha2_code.value, _in_data->u.iso_3166_alpha2_code.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePostalCode(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PostalCode	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_PostalCode *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(67,263)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 264)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.numeric_code.value, _in_data->u.numeric_code.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x32 : 0x12);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 265)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printable_code.value, _in_data->u.printable_code.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePhysicalDeliveryOfficeName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(68,266)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePhysicalDeliveryOfficeNumber(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(69,267)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eExtensionORAddressComponents(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(70,268)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePhysicalDeliveryPersonalName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(71,269)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _e1PhysicalDeliveryOrganizatio(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(72,270)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _e2ExtensionPhysicalDeliveryAd(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(73,271)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eUnformattedPostalAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _UnformattedPostalAddress	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_UnformattedPostalAddress *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(74,272)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 72)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->teletex_string.value, _in_data->teletex_string.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(273)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_seqof1 * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 274)
		for (_temp = _in_data->printable_address, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 6) _oss_enc_error(_g, _too_long, count);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_seqof1 *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eStreetAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(75,275)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePostOfficeBoxAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(76,276)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePosteRestanteAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(77,277)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eUniquePostalName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(78,278)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eLocalPostalAttributes(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PDSParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(79,279)
    _data_len = _edPDSParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eExtendedNetworkAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ExtendedNetworkAddress	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_ExtendedNetworkAddress *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(80,280)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 281)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.e163_4_address == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 282)
		if (_in_data->u.e163_4_address->bit_mask & 0x80000000) {
		    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.e163_4_address->sub_address.value, _in_data->u.e163_4_address->sub_address.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(283)
		_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.e163_4_address->number.value, _in_data->u.e163_4_address->number.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 284)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.psap_address == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 285)
		{
		    _seqof1 * _temp;
		    unsigned long count;
		    unsigned long _lindex;
		    long _total_len = 0;
		    OSS_UINT32 _sp;
		    void **_st = _oss_load_enc_stack(_g, &_sp);
		    OSS_CNTX_NEW(_oss_c, 286)
		    for (_temp = _in_data->u.psap_address->nAddresses, count = 0; _temp; _temp = _temp->next) {
			OSS_CNTX_SETOCC(count + 1)
			if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			_st[_sp++] = _temp;
			count++;
		    }
		    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		    for (_lindex = 0; _lindex < count; _lindex++) {
			OSS_CNTX_SETOCC(count - _lindex)
			_temp = (_seqof1 *)_st[--_sp];
			if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			if (count > 1) _oss_nextItem(_g, &_out_len);
			_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.value, _temp->value.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
			_total_len += _data_len;
		    }
		    _oss_save_enc_stack(_g, _sp);
		    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA3);
		_total_len += _data_len;
		OSS_CNTX_SET(287)
		if (_in_data->u.psap_address->bit_mask & 0x20000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.psap_address->tSelector.value, _in_data->u.psap_address->tSelector.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA2);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(288)
		if (_in_data->u.psap_address->bit_mask & 0x40000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.psap_address->sSelector.value, _in_data->u.psap_address->sSelector.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(289)
		if (_in_data->u.psap_address->bit_mask & 0x80000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.psap_address->pSelector.value, _in_data->u.psap_address->pSelector.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA0);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTerminalType(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(81,290)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _e3TeletexDomainDefinedAttribu(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _BuiltInDomainDefinedAttributes	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_BuiltInDomainDefinedAttributes **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(82,291)
    {
	_BuiltInDomainDefinedAttributes * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 292)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 4) _oss_enc_error(_g, _too_long, count);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_BuiltInDomainDefinedAttributes *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 234)
		_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.value.value, _temp->value.value.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
		_total_len += _data_len;
		OSS_CNTX_SET(235)
		_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _temp->value.type.value, _temp->value.type.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAuthPack_OLD(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AuthPack_OLD	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_AuthPack_OLD *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(83,293)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 294)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 161)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->pkAuthenticator.nonce, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
	    _total_len += _data_len;
	    OSS_CNTX_SET(93)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->pkAuthenticator.ctime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->pkAuthenticator.ctime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA3);
	    _total_len += _data_len;
	    OSS_CNTX_SET(162)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->pkAuthenticator.cusec, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    _total_len += _data_len;
	    OSS_CNTX_SET(295)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->pkAuthenticator.kdc_realm.value, _in_data->pkAuthenticator.kdc_realm.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA1);
	    _total_len += _data_len;
	    OSS_CNTX_SET(296)
	    _data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->pkAuthenticator.kdc_name);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKERB_REPLY_KEY_PACKAGE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KERB_REPLY_KEY_PACKAGE	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_KERB_REPLY_KEY_PACKAGE *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(84,297)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 161)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->nonce, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(177)
	_data_len = _edEncryptionKey(_g, _out_pos, &_out_len, &_in_data->replyKey);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePA_FOR_USER_ENC(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_FOR_USER_ENC	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_PA_FOR_USER_ENC *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(85,298)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 299)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->auth_package.value, _in_data->auth_package.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(95)
	_data_len = _edChecksum(_g, _out_pos, &_out_len, &_in_data->cksum);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(300)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->userRealm.value, _in_data->userRealm.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(301)
	_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->userName);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePA_S4U_X509_USER(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_S4U_X509_USER	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_PA_S4U_X509_USER *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(86,302)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 303)
	_data_len = _edChecksum(_g, _out_pos, &_out_len, &_in_data->checksum);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(304)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 305)
	    if (_in_data->user_id.bit_mask & 0x20000000) {
		_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->user_id.options.value, _in_data->user_id.options.length, -1, FALSE);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3, 0xA4);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(306)
	    if (_in_data->user_id.bit_mask & 0x40000000) {
		_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->user_id.subject_certificate.value, _in_data->user_id.subject_certificate.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA3);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(40)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->user_id.crealm.value, _in_data->user_id.crealm.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3B : 0x1B, 0xA2);
	    _total_len += _data_len;
	    OSS_CNTX_SET(12)
	    if (_in_data->user_id.bit_mask & 0x80000000) {
		_data_len = _edPrincipalName(_g, _out_pos, &_out_len, &_in_data->user_id.cname);
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
		_total_len += _data_len;
	    }
	    OSS_CNTX_SET(8)
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->user_id.nonce, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePA_PAC_OPTIONS(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_PAC_OPTIONS	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_PA_PAC_OPTIONS *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(87,307)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 308)
	_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->kerberosFlags.value, _in_data->kerberosFlags.length, -1, FALSE);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKERB_PA_PAC_REQUEST(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KERB_PA_PAC_REQUEST	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_KERB_PA_PAC_REQUEST *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(88,309)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 310)
	_data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _in_data->include_pac);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKERB_LOCAL(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(89,311)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKERB_AD_RESTRICTION_ENTRY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KERB_AD_RESTRICTION_ENTRY	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_KERB_AD_RESTRICTION_ENTRY *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(90,312)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 313)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->restriction.value, _in_data->restriction.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(314)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->restriction_type, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePA_SUPPORTED_ENCTYPES(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_INT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(91,315)
    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    OSS_MEMMOVE(_g, *_outbuf, _data_len, *_out_pos, _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

void DLL_ENTRY_FDEF _emMS_SFU_KILE(struct ossGlobal * _g, int _pdunum, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char **_outbuf = &_oss_c->_oss_outbufpos;
    long *_outlen = &_oss_c->_oss_outbuflen;
    unsigned int _flags = _g->encodingFlags;
    _oss_c->_oss_context_anchor._state = _encoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_pre(_g, _pdunum, _inbuf, NULL, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (_pdunum < 1 || _pdunum > 91)
	_oss_enc_error(_g, _pdu_range, _pdunum);
    else
	_Encoders[_pdunum - 1](_g, _inbuf, _outbuf, _outlen, _flags);
#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_post(_g, 0, *_outbuf, *_outlen);
#endif
}

static void _d_Ticket(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Ticket * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 3)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->tkt_vno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(2)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	_data_tag = 0x1B;
	_out_data->realm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->realm.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(1)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->sname);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(0)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x83);
	_data_tag = 0x8003;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EncryptedData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->enc_part);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_KDC_REQ_BODY(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _KDC_REQ_BODY * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 13)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
	_data_tag = 0x3;
	_out_data->kdc_options.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->kdc_options.value, 0, 0);

	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->cname, sizeof(_out_data->cname), 0, sizeof(_out_data->cname));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 12)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->cname);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 2)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	_data_tag = 0x1B;
	_out_data->realm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->realm.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->sname, sizeof(_out_data->sname), 0, sizeof(_out_data->sname));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->sname);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8004 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->from = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 11)
	    _out_data->from = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->from, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 10)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8005;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	_data_tag = 0x18;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->till, -1, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->rtime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 9)
	    _out_data->rtime = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->rtime, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 8)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 167 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8007;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->nonce = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(7)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 168 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x88);
	_data_tag = 0x8008;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof2(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->etype);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8009 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    OSS_MEMSET(_g, &_out_data->addresses, sizeof(_out_data->addresses), 0, sizeof(_out_data->addresses));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _out_data->addresses = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_HostAddresses(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->addresses);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x800A || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x10000000;
	    OSS_MEMSET(_g, &_out_data->enc_authorization_data, sizeof(_out_data->enc_authorization_data), 0, sizeof(_out_data->enc_authorization_data));
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 5)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_EncryptedData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->enc_authorization_data);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x800B || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x8000000;
	    OSS_MEMSET(_g, &_out_data->additional_tickets, sizeof(_out_data->additional_tickets), 0, sizeof(_out_data->additional_tickets));
	}
else {
	    _out_data->bit_mask |= 0x8000000;
	    OSS_CNTX_PUSH(_oss_c, 4)
	    _out_data->additional_tickets = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d__seqof3(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->additional_tickets);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seqof1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof1 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof1 * _head = NULL;
	_seqof1 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 14)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
	    _head = _cur;
	    for (;;) {
		_seqof1 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x1B)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x1B0000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_temp->value.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, 0);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_PrincipalName(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _PrincipalName * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 16)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->name_type = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(15)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof1(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->name_string);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_HostAddress(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _HostAddress * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 18)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->addr_type = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(17)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->address.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->address.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_HostAddresses(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _HostAddresses ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_HostAddresses * _head = NULL;
	_HostAddresses * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 19)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_HostAddresses *)_oss_dec_const_alloc(_g, sizeof(_HostAddresses));
	    _head = _cur;
	    for (;;) {
		_HostAddresses * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_HostAddress(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_HostAddresses *)_oss_dec_const_alloc(_g, sizeof(_HostAddresses));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seq1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq1 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 21)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->ad_type = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(20)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->ad_data.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->ad_data.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_AuthorizationData(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AuthorizationData ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_AuthorizationData * _head = NULL;
	_AuthorizationData * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 22)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_AuthorizationData *)_oss_dec_const_alloc(_g, sizeof(_AuthorizationData));
	    _head = _cur;
	    for (;;) {
		_AuthorizationData * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d__seq1(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_AuthorizationData *)_oss_dec_const_alloc(_g, sizeof(_AuthorizationData));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_PA_DATA(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _PA_DATA * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 24)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->padata_type = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(23)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->padata_value.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->padata_value.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_EncryptedData(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _EncryptedData * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 27)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->etype = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 26)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->kvno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 25)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->cipher.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->cipher.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_EncryptionKey(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _EncryptionKey * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 29)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->keytype = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(28)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->keyvalue.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->keyvalue.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_Checksum(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Checksum * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 31)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->cksumtype = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(30)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->checksum.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->checksum.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seqof2(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof2 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof2 * _head = NULL;
	_seqof2 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 32)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof2 *)_oss_dec_const_alloc(_g, sizeof(_seqof2));
	    _head = _cur;
	    for (;;) {
		_seqof2 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x2)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_temp->value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof2 *)_oss_dec_const_alloc(_g, sizeof(_seqof2));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seqof3(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof3 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof3 * _head = NULL;
	_seqof3 * _cur;
	int _indef_tags = 0;

	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 33)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof3 *)_oss_dec_const_alloc(_g, sizeof(_seqof3));
	    _head = _cur;
	    for (;;) {
		_seqof3 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x4001)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x40010000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
		_data_tag = 0x10;
		_d_Ticket(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof3 *)_oss_dec_const_alloc(_g, sizeof(_seqof3));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seqof4(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof4 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof4 * _head = NULL;
	_seqof4 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 34)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof4 *)_oss_dec_const_alloc(_g, sizeof(_seqof4));
	    _head = _cur;
	    for (;;) {
		_seqof4 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_PA_DATA(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof4 *)_oss_dec_const_alloc(_g, sizeof(_seqof4));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_KDC_REQ(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _KDC_REQ * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 38)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->pvno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(37)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->msg_type = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->padata, sizeof(_out_data->padata), 0, sizeof(_out_data->padata));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 36)
	    _out_data->padata = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d__seqof4(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->padata);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 35)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8004;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_KDC_REQ_BODY(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->req_body);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seqof5(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof4 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof4 * _head = NULL;
	_seqof4 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 34)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof4 *)_oss_dec_const_alloc(_g, sizeof(_seqof4));
	    _head = _cur;
	    for (;;) {
		_seqof4 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_PA_DATA(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof4 *)_oss_dec_const_alloc(_g, sizeof(_seqof4));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_KDC_REP(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _KDC_REP * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 38)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->pvno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(37)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->msg_type = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->padata, sizeof(_out_data->padata), 0, sizeof(_out_data->padata));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 36)
	    _out_data->padata = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d__seqof5(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->padata);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 40)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8003;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	_data_tag = 0x1B;
	_out_data->crealm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->crealm.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(12)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x84);
	_data_tag = 0x8004;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->cname);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(39)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x85);
	_data_tag = 0x8005;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 97 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x41);
	_data_tag = 0x4001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_Ticket(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->ticket);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(0)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x86);
	_data_tag = 0x8006;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EncryptedData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->enc_part);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seqof6(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof4 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof4 * _head = NULL;
	_seqof4 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 34)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof4 *)_oss_dec_const_alloc(_g, sizeof(_seqof4));
	    _head = _cur;
	    for (;;) {
		_seqof4 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_PA_DATA(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof4 *)_oss_dec_const_alloc(_g, sizeof(_seqof4));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_EncKDCRepPart(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _EncKDCRepPart * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 51)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EncryptionKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->key);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(50)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_LastReq(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->last_req);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(8)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->nonce = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->key_expiration = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 49)
	    _out_data->key_expiration = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->key_expiration, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 48)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8004;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
	_data_tag = 0x3;
	_out_data->flags.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->flags.value, 0, 0);

	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(47)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x85);
	_data_tag = 0x8005;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	_data_tag = 0x18;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->authtime, -1, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->starttime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 46)
	    _out_data->starttime = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->starttime, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 45)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 167 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8007;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	_data_tag = 0x18;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->endtime, -1, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8008 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->renew_till = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 44)
	    _out_data->renew_till = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->renew_till, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 43)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 169 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8009) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x89 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80090000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8009;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	_data_tag = 0x1B;
	_out_data->srealm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->srealm.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(1)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 170 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8A);
	_data_tag = 0x800A;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->sname);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x800B || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->caddr, sizeof(_out_data->caddr), 0, sizeof(_out_data->caddr));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 42)
	    _out_data->caddr = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_HostAddresses(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->caddr);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x800C || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->encrypted_pa_data, sizeof(_out_data->encrypted_pa_data), 0, sizeof(_out_data->encrypted_pa_data));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 41)
	    _out_data->encrypted_pa_data = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d__seqof6(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->encrypted_pa_data);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seq2(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq2 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 53)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->lr_type = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(52)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	_data_tag = 0x18;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->lr_value, -1, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_LastReq(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _LastReq ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_LastReq * _head = NULL;
	_LastReq * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 22)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_LastReq *)_oss_dec_const_alloc(_g, sizeof(_LastReq));
	    _head = _cur;
	    for (;;) {
		_LastReq * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d__seq2(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_LastReq *)_oss_dec_const_alloc(_g, sizeof(_LastReq));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_ExternalPrincipalIdentifier(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ExternalPrincipalIdentifier * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8000 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->subjectName, sizeof(_out_data->subjectName), 0, sizeof(_out_data->subjectName));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 56)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->subjectName.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->subjectName.value, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->issuerAndSerialNumber, sizeof(_out_data->issuerAndSerialNumber), 0, sizeof(_out_data->issuerAndSerialNumber));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 55)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->issuerAndSerialNumber.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->issuerAndSerialNumber.value, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    OSS_MEMSET(_g, &_out_data->subjectKeyIdentifier, sizeof(_out_data->subjectKeyIdentifier), 0, sizeof(_out_data->subjectKeyIdentifier));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 54)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->subjectKeyIdentifier.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->subjectKeyIdentifier.value, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	while ((size_t)_bufpos < (size_t)_end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    OSS_UNKNOWN_EXT_FOUND(_g);
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_AlgorithmIdentifier(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AlgorithmIdentifier * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 58)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x6;
	_out_data->algorithm.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->algorithm.value, -1);
	OSS_CNTX_POP(_oss_c)
	if (_total_len < 0) {
	    if (*_bufpos == 0) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    } else
		_data_tag = 1;
	}
	if ((size_t)_bufpos >= (size_t)_end_pos || (_total_len < 0 && _data_tag == 0))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->parameters, sizeof(_out_data->parameters), 0, sizeof(_out_data->parameters));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 57)
	    if (_data_length == 0) _data_length = 1;
	    _out_data->parameters.length = _oss_dec_uany(_g, &_bufpos, &_buflen, _data_length, &_out_data->parameters.value);
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_SubjectPublicKeyInfo(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _SubjectPublicKeyInfo * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 60)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x10) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x10 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x10;
	_d_AlgorithmIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->algorithm);
	OSS_CNTX_SET(59)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
	_data_tag = 0x3;
	_out_data->subjectPublicKey.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->subjectPublicKey.value, 0, 0);

	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_Name(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Name * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x10: {
	    OSS_CNTX_PUSH(_oss_c, 61)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_RDNSequence(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.rdnSequence);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_RDNSequence(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RDNSequence ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_RDNSequence * _head = NULL;
	_RDNSequence * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 62)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_RDNSequence *)_oss_dec_const_alloc(_g, sizeof(_RDNSequence));
	    _head = _cur;
	    for (;;) {
		_RDNSequence * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x11)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x110000);
		_temp->value = NULL;
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    _RelativeDistinguishedName * _head1 = NULL;
		    _RelativeDistinguishedName * _cur1;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		    unsigned long count = 0;
#endif
		    OSS_CNTX_INIT

		    do {
			OSS_CNTX_PUSH(_oss_c, 63)
			if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos != _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			_cur1 = (_RelativeDistinguishedName *)_oss_dec_const_alloc(_g, sizeof(_RelativeDistinguishedName));
			_head1 = _cur1;
			for (;;) {
			    _RelativeDistinguishedName * _temp1 = _cur1;
#if OSSDEBUG > 1
			    count++;
#endif
			    if (_data_tag != 0x10)
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
			    OSS_CNTX_SETOCC(count)
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				long _total_len = _data_length;
				char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
				OSS_CNTX_INIT

				OSS_CNTX_PUSH(_oss_c, 65)
				if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
				_data_tag = 0x6;
				_temp1->value.type.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp1->value.type.value, -1);
				OSS_CNTX_SET(64)
				if (_data_length == 0) _data_length = 1;
				_temp1->value.value.length = _oss_dec_uany(_g, &_bufpos, &_buflen, _data_length, &_temp1->value.value.value);
				OSS_CNTX_POP(_oss_c)
				if (_bufpos != _end_pos) {
				    if (_total_len < 0) {
					if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

					if (_data_tag)
					    _oss_dec_error(_g, _expec_eoc, 0L);
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
				    } else
					_oss_dec_error(_g, _inconsis_len, 0L);
				}
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				if (_bufpos != _end_pos)
				    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
				break;
			    }
			    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				_bufpos++;
			    } else
				if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				    break;
				}
			    _oss_c->_tag_decoded = TRUE;
			    _cur1 = (_RelativeDistinguishedName *)_oss_dec_const_alloc(_g, sizeof(_RelativeDistinguishedName));
			    _temp1->next = _cur1;
			}
			_cur1->next = NULL;
		    } while (0);
		    _temp->value = _head1;
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_RDNSequence *)_oss_dec_const_alloc(_g, sizeof(_RDNSequence));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_Time(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Time * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x17: {
	    OSS_CNTX_PUSH(_oss_c, 66)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.utcTime, -1, 1);
	}   break;
	case 0x18: {
	    OSS_CNTX_PUSH(_oss_c, 67)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.generalTime, -1, 0);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_Extension(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Extension * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 70)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x6;
	_out_data->extnID.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->extnID.value, -1);
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x1 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    OSS_MEMCPY(_g, &_out_data->critical, sizeof(Extension::default_critical), &Extension::default_critical, sizeof(Extension::default_critical));
#else
	    _out_data->critical = 0;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 69)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->critical = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 68)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x4) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x4 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x40000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x4;
	_out_data->extnValue.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->extnValue.value, 0);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_Extensions(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Extensions ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Extensions * _head = NULL;
	_Extensions * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 71)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_Extensions *)_oss_dec_const_alloc(_g, sizeof(_Extensions));
	    _head = _cur;
	    for (;;) {
		_Extensions * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_Extension(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_Extensions *)_oss_dec_const_alloc(_g, sizeof(_Extensions));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_PDSParameter(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _PDSParameter * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	_out_data->bit_mask = 0;
	for (;;) {
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    case 0x13: {
		OSS_CNTX_PUSH(_oss_c, 73)
		if (_out_data->bit_mask & 0x80000000)
		    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		_out_data->bit_mask |= 0x80000000;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->printable_string.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->printable_string.value, 30);
		_present_flags |= 0x1;
	    }   break;
	    case 0x14: {
		OSS_CNTX_PUSH(_oss_c, 72)
		if (_out_data->bit_mask & 0x40000000)
		    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		_out_data->bit_mask |= 0x40000000;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->teletex_string.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->teletex_string.value, 30);
		_present_flags |= 0x2;
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!(_present_flags & 0x1)) {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->printable_string,  sizeof(_out_data->printable_string), 0, sizeof(_out_data->printable_string));
	}
	if (!(_present_flags & 0x2)) {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->teletex_string,  sizeof(_out_data->teletex_string), 0, sizeof(_out_data->teletex_string));
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void * _dTicket(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Ticket *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(1,74)
    _out_data = (_Ticket *)_oss_dec_const_alloc(_g, sizeof(_Ticket));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 97 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x41);
    _data_tag = 0x4001;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_Ticket(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dEncTicketPart(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncTicketPart *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(2,75)
    _out_data = (_EncTicketPart *)_oss_dec_const_alloc(_g, sizeof(_EncTicketPart));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 99 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x43);
    _data_tag = 0x4003;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 48)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
	_data_tag = 0x3;
	_out_data->flags.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->flags.value, 0, 0);

	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(51)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EncryptionKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->key);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(40)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	_data_tag = 0x1B;
	_out_data->crealm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->crealm.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(12)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x83);
	_data_tag = 0x8003;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->cname);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(77)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x84);
	_data_tag = 0x8004;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 79)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->transited.tr_type = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_SET(78)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	    _data_tag = 0x8001;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	    _data_tag = 0x4;
	    _out_data->transited.contents.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->transited.contents.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(47)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x85);
	_data_tag = 0x8005;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	_data_tag = 0x18;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->authtime, -1, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->starttime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 46)
	    _out_data->starttime = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->starttime, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 45)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 167 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8007;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	_data_tag = 0x18;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->endtime, -1, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8008 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->renew_till = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 44)
	    _out_data->renew_till = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->renew_till, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8009 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->caddr, sizeof(_out_data->caddr), 0, sizeof(_out_data->caddr));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 42)
	    _out_data->caddr = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_HostAddresses(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->caddr);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x800A || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->authorization_data, sizeof(_out_data->authorization_data), 0, sizeof(_out_data->authorization_data));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 76)
	    _out_data->authorization_data = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_AuthorizationData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->authorization_data);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAS_REQ(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDC_REQ *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(3,80)
    _out_data = (_KDC_REQ *)_oss_dec_const_alloc(_g, sizeof(_KDC_REQ));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 106 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4A);
    _data_tag = 0x400A;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_KDC_REQ(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTGS_REQ(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDC_REQ *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(4,81)
    _out_data = (_KDC_REQ *)_oss_dec_const_alloc(_g, sizeof(_KDC_REQ));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 108 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4C);
    _data_tag = 0x400C;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_KDC_REQ(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKDC_REQ_BODY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDC_REQ_BODY *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(5,82)
    _out_data = (_KDC_REQ_BODY *)_oss_dec_const_alloc(_g, sizeof(_KDC_REQ_BODY));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_KDC_REQ_BODY(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAS_REP(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDC_REP *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(6,83)
    _out_data = (_KDC_REP *)_oss_dec_const_alloc(_g, sizeof(_KDC_REP));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 107 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4B);
    _data_tag = 0x400B;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_KDC_REP(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTGS_REP(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDC_REP *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(7,84)
    _out_data = (_KDC_REP *)_oss_dec_const_alloc(_g, sizeof(_KDC_REP));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 109 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4D);
    _data_tag = 0x400D;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_KDC_REP(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dEncASRepPart(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncKDCRepPart *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(8,85)
    _out_data = (_EncKDCRepPart *)_oss_dec_const_alloc(_g, sizeof(_EncKDCRepPart));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 121 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x59);
    _data_tag = 0x4019;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_EncKDCRepPart(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dEncTGSRepPart(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncKDCRepPart *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(9,86)
    _out_data = (_EncKDCRepPart *)_oss_dec_const_alloc(_g, sizeof(_EncKDCRepPart));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 122 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x5A);
    _data_tag = 0x401A;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_EncKDCRepPart(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAP_REQ(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AP_REQ *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(10,87)
    _out_data = (_AP_REQ *)_oss_dec_const_alloc(_g, sizeof(_AP_REQ));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 110 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4E);
    _data_tag = 0x400E;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->pvno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(37)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->msg_type = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(89)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
	_data_tag = 0x3;
	_out_data->ap_options.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->ap_options.value, 0, 0);

	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(39)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x83);
	_data_tag = 0x8003;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 97 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x41);
	_data_tag = 0x4001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_Ticket(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->ticket);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(88)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x84);
	_data_tag = 0x8004;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EncryptedData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->authenticator);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAuthenticator(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Authenticator *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(11,90)
    _out_data = (_Authenticator *)_oss_dec_const_alloc(_g, sizeof(_Authenticator));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 98 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x42);
    _data_tag = 0x4002;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 96)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->authenticator_vno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(40)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	_data_tag = 0x1B;
	_out_data->crealm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->crealm.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(12)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->cname);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->cksum, sizeof(_out_data->cksum), 0, sizeof(_out_data->cksum));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 95)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_Checksum(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->cksum);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 94)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8004;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->cusec = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(93)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x85);
	_data_tag = 0x8005;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	_data_tag = 0x18;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->ctime, -1, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->subkey, sizeof(_out_data->subkey), 0, sizeof(_out_data->subkey));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 92)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_EncryptionKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->subkey);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8007 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 91)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->seq_number = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8008 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x10000000;
	    OSS_MEMSET(_g, &_out_data->authorization_data, sizeof(_out_data->authorization_data), 0, sizeof(_out_data->authorization_data));
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 76)
	    _out_data->authorization_data = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_AuthorizationData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->authorization_data);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAP_REP(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AP_REP *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(12,97)
    _out_data = (_AP_REP *)_oss_dec_const_alloc(_g, sizeof(_AP_REP));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 111 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4F);
    _data_tag = 0x400F;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->pvno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(37)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->msg_type = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(0)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EncryptedData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->enc_part);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dEncAPRepPart(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncAPRepPart *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(13,98)
    _out_data = (_EncAPRepPart *)_oss_dec_const_alloc(_g, sizeof(_EncAPRepPart));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 123 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x5B);
    _data_tag = 0x401B;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 93)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	_data_tag = 0x18;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->ctime, -1, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(94)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->cusec = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->subkey, sizeof(_out_data->subkey), 0, sizeof(_out_data->subkey));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 92)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_EncryptionKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->subkey);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 91)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->seq_number = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKRB_SAFE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KRB_SAFE *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(14,99)
    _out_data = (_KRB_SAFE *)_oss_dec_const_alloc(_g, sizeof(_KRB_SAFE));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 116 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x54);
    _data_tag = 0x4014;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->pvno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(37)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->msg_type = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(100)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    _out_data->safe_body.bit_mask = 0;
	    OSS_CNTX_PUSH(_oss_c, 105)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	    _data_tag = 0x4;
	    _out_data->safe_body.user_data.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->safe_body.user_data.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if ((size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
		_out_data->safe_body.timestamp = NULL;
	    else {
		OSS_CNTX_PUSH(_oss_c, 104)
		_out_data->safe_body.timestamp = NULL;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
		_data_tag = 0x18;
		_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->safe_body.timestamp, -1, 0);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->safe_body.bit_mask &= ~0x80000000;
	    }
else {
		_out_data->safe_body.bit_mask |= 0x80000000;
		OSS_CNTX_PUSH(_oss_c, 103)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		_data_tag = 0x2;
		_out_data->safe_body.usec = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->safe_body.bit_mask &= ~0x40000000;
	    }
else {
		_out_data->safe_body.bit_mask |= 0x40000000;
		OSS_CNTX_PUSH(_oss_c, 91)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		_data_tag = 0x2;
		_out_data->safe_body.seq_number = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    OSS_CNTX_PUSH(_oss_c, 102)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8004;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_HostAddress(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->safe_body.s_address);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if ((size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8005 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->safe_body.bit_mask &= ~0x20000000;
		OSS_MEMSET(_g, &_out_data->safe_body.r_address, sizeof(_out_data->safe_body.r_address), 0, sizeof(_out_data->safe_body.r_address));
	    }
else {
		_out_data->safe_body.bit_mask |= 0x20000000;
		OSS_CNTX_PUSH(_oss_c, 101)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
		_data_tag = 0x10;
		_d_HostAddress(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->safe_body.r_address);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (!_oss_c->_tag_decoded)
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(95)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x83);
	_data_tag = 0x8003;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_Checksum(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->cksum);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKRB_PRIV(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AP_REP *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(15,106)
    _out_data = (_AP_REP *)_oss_dec_const_alloc(_g, sizeof(_AP_REP));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 117 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x55);
    _data_tag = 0x4015;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->pvno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(37)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->msg_type = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(0)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x83);
	_data_tag = 0x8003;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EncryptedData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->enc_part);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dEncKrbPrivPart(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KRB_SAFE_BODY *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(16,107)
    _out_data = (_KRB_SAFE_BODY *)_oss_dec_const_alloc(_g, sizeof(_KRB_SAFE_BODY));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 124 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x5C);
    _data_tag = 0x401C;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 105)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->user_data.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->user_data.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->timestamp = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 104)
	    _out_data->timestamp = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->timestamp, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 103)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->usec = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 91)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->seq_number = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 102)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8004;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_HostAddress(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->s_address);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    OSS_MEMSET(_g, &_out_data->r_address, sizeof(_out_data->r_address), 0, sizeof(_out_data->r_address));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 101)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_HostAddress(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->r_address);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKRB_CRED(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KRB_CRED *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(17,108)
    _out_data = (_KRB_CRED *)_oss_dec_const_alloc(_g, sizeof(_KRB_CRED));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 118 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x56);
    _data_tag = 0x4016;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->pvno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(37)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->msg_type = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(109)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof3 * _head = NULL;
	    _seqof3 * _cur;
	    int _indef_tags = 0;

	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    do {
		OSS_CNTX_PUSH(_oss_c, 33)
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof3 *)_oss_dec_const_alloc(_g, sizeof(_seqof3));
		_head = _cur;
		for (;;) {
		    _seqof3 * _temp = _cur;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x4001)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x40010000);
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
		    _data_tag = 0x10;
		    _d_Ticket(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos != _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_seqof3 *)_oss_dec_const_alloc(_g, sizeof(_seqof3));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } while (0);
	    _out_data->tickets = _head;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(0)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x83);
	_data_tag = 0x8003;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EncryptedData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->enc_part);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dEncKrbCredPart(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncKrbCredPart *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(18,110)
    _out_data = (_EncKrbCredPart *)_oss_dec_const_alloc(_g, sizeof(_EncKrbCredPart));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 125 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x5D);
    _data_tag = 0x401D;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 111)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof8 * _head = NULL;
	    _seqof8 * _cur;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    do {
		OSS_CNTX_PUSH(_oss_c, 112)
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof8 *)_oss_dec_const_alloc(_g, sizeof(_seqof8));
		_head = _cur;
		for (;;) {
		    _seqof8 * _temp = _cur;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			int _indef_tags = 0;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			OSS_CNTX_INIT

			_temp->value.bit_mask = 0;
			OSS_CNTX_PUSH(_oss_c, 51)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
			_data_tag = 0x8000;
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
			_data_tag = 0x10;
			_d_EncryptionKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.key);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
			if ((size_t)_bufpos < (size_t)_end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
			 {
			    _temp->value.bit_mask &= ~0x80000000;
			    OSS_MEMSET(_g, &_temp->value.prealm, sizeof(_temp->value.prealm), 0, sizeof(_temp->value.prealm));
			}
else {
			    _temp->value.bit_mask |= 0x80000000;
			    OSS_CNTX_PUSH(_oss_c, 114)
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
			    _data_tag = 0x1B;
			    _temp->value.prealm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.prealm.value, 0);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
			 {
			    _temp->value.bit_mask &= ~0x40000000;
			    OSS_MEMSET(_g, &_temp->value.pname, sizeof(_temp->value.pname), 0, sizeof(_temp->value.pname));
			}
else {
			    _temp->value.bit_mask |= 0x40000000;
			    OSS_CNTX_PUSH(_oss_c, 113)
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
			    _data_tag = 0x10;
			    _d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.pname);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
			 {
			    _temp->value.bit_mask &= ~0x20000000;
			    OSS_MEMSET(_g, &_temp->value.flags, sizeof(_temp->value.flags), 0, sizeof(_temp->value.flags));
			}
else {
			    _temp->value.bit_mask |= 0x20000000;
			    OSS_CNTX_PUSH(_oss_c, 48)
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
			    _data_tag = 0x3;
			    _temp->value.flags.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.flags.value, 0, 0);

			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8004 || (size_t)_bufpos >= (size_t)_end_pos)
			    _temp->value.authtime = NULL;
			else {
			    OSS_CNTX_PUSH(_oss_c, 47)
			    _temp->value.authtime = NULL;
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
			    _data_tag = 0x18;
			    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_temp->value.authtime, -1, 0);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8005 || (size_t)_bufpos >= (size_t)_end_pos)
			    _temp->value.starttime = NULL;
			else {
			    OSS_CNTX_PUSH(_oss_c, 46)
			    _temp->value.starttime = NULL;
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
			    _data_tag = 0x18;
			    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_temp->value.starttime, -1, 0);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8006 || (size_t)_bufpos >= (size_t)_end_pos)
			    _temp->value.endtime = NULL;
			else {
			    OSS_CNTX_PUSH(_oss_c, 45)
			    _temp->value.endtime = NULL;
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
			    _data_tag = 0x18;
			    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_temp->value.endtime, -1, 0);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8007 || (size_t)_bufpos >= (size_t)_end_pos)
			    _temp->value.renew_till = NULL;
			else {
			    OSS_CNTX_PUSH(_oss_c, 44)
			    _temp->value.renew_till = NULL;
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
			    _data_tag = 0x18;
			    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_temp->value.renew_till, -1, 0);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8008 || (size_t)_bufpos >= (size_t)_end_pos)
			 {
			    _temp->value.bit_mask &= ~0x10000000;
			    OSS_MEMSET(_g, &_temp->value.srealm, sizeof(_temp->value.srealm), 0, sizeof(_temp->value.srealm));
			}
else {
			    _temp->value.bit_mask |= 0x10000000;
			    OSS_CNTX_PUSH(_oss_c, 43)
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
			    _data_tag = 0x1B;
			    _temp->value.srealm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.srealm.value, 0);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8009 || (size_t)_bufpos >= (size_t)_end_pos)
			 {
			    _temp->value.bit_mask &= ~0x8000000;
			    OSS_MEMSET(_g, &_temp->value.sname, sizeof(_temp->value.sname), 0, sizeof(_temp->value.sname));
			}
else {
			    _temp->value.bit_mask |= 0x8000000;
			    OSS_CNTX_PUSH(_oss_c, 1)
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
			    _data_tag = 0x10;
			    _d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.sname);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x800A || (size_t)_bufpos >= (size_t)_end_pos)
			 {
			    _temp->value.bit_mask &= ~0x4000000;
			    OSS_MEMSET(_g, &_temp->value.caddr, sizeof(_temp->value.caddr), 0, sizeof(_temp->value.caddr));
			}
else {
			    _temp->value.bit_mask |= 0x4000000;
			    OSS_CNTX_PUSH(_oss_c, 42)
			    _temp->value.caddr = NULL;
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
			    _data_tag = 0x10;
			    _d_HostAddresses(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.caddr);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (_bufpos != _end_pos) {
			    if (_total_len < 0) {
				if (!_oss_c->_tag_decoded)
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				if (_data_tag)
				    _oss_dec_error(_g, _expec_eoc, 0L);
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
			    } else
				_oss_dec_error(_g, _inconsis_len, 0L);
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos != _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_seqof8 *)_oss_dec_const_alloc(_g, sizeof(_seqof8));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } while (0);
	    _out_data->ticket_info = _head;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 8)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->nonce = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->timestamp = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 104)
	    _out_data->timestamp = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->timestamp, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 103)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->usec = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8004 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    OSS_MEMSET(_g, &_out_data->s_address, sizeof(_out_data->s_address), 0, sizeof(_out_data->s_address));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 102)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_HostAddress(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->s_address);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x10000000;
	    OSS_MEMSET(_g, &_out_data->r_address, sizeof(_out_data->r_address), 0, sizeof(_out_data->r_address));
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 101)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_HostAddress(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->r_address);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKRB_ERROR(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KRB_ERROR *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    int _indef_tags = 0;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(19,115)
    _out_data = (_KRB_ERROR *)_oss_dec_const_alloc(_g, sizeof(_KRB_ERROR));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 126 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x5E);
    _data_tag = 0x401E;
    if (_data_length < 0) ++_indef_tags;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 38)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->pvno = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(37)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->msg_type = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->ctime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 93)
	    _out_data->ctime = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->ctime, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 94)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->cusec = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 120)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8004;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	_data_tag = 0x18;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->stime, -1, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(119)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x85);
	_data_tag = 0x8005;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->susec = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(118)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x86);
	_data_tag = 0x8006;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->error_code = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8007 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->crealm, sizeof(_out_data->crealm), 0, sizeof(_out_data->crealm));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 40)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	    _data_tag = 0x1B;
	    _out_data->crealm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->crealm.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8008 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    OSS_MEMSET(_g, &_out_data->cname, sizeof(_out_data->cname), 0, sizeof(_out_data->cname));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 12)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->cname);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 2)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 169 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8009) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x89 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80090000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8009;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	_data_tag = 0x1B;
	_out_data->realm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->realm.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(1)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 170 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8A);
	_data_tag = 0x800A;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->sname);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x800B || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x10000000;
	    OSS_MEMSET(_g, &_out_data->e_text, sizeof(_out_data->e_text), 0, sizeof(_out_data->e_text));
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 117)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	    _data_tag = 0x1B;
	    _out_data->e_text.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->e_text.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x800C || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x8000000;
	    OSS_MEMSET(_g, &_out_data->e_data, sizeof(_out_data->e_data), 0, sizeof(_out_data->e_data));
	}
else {
	    _out_data->bit_mask |= 0x8000000;
	    OSS_CNTX_PUSH(_oss_c, 116)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	    _data_tag = 0x4;
	    _out_data->e_data.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->e_data.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    while (_indef_tags > 0) {
	if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    if (!_buflen || _bufpos[0])
		_oss_dec_error(_g, _expec_eoc, 0L);
	    else
		_oss_dec_error(_g, _non_std_eoc, 0L);
	_indef_tags--;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dMETHOD_DATA(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof4 **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(20,121)
    _out_data = (_seqof4 **)_oss_dec_const_init_alloc(_g, sizeof(_seqof4 *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof4 * _head = NULL;
	_seqof4 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 34)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof4 *)_oss_dec_const_alloc(_g, sizeof(_seqof4));
	    _head = _cur;
	    for (;;) {
		_seqof4 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_PA_DATA(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof4 *)_oss_dec_const_alloc(_g, sizeof(_seqof4));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTYPED_DATA(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TYPED_DATA **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(21,122)
    _out_data = (_TYPED_DATA **)_oss_dec_const_init_alloc(_g, sizeof(_TYPED_DATA *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_TYPED_DATA * _head = NULL;
	_TYPED_DATA * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 22)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_TYPED_DATA *)_oss_dec_const_alloc(_g, sizeof(_TYPED_DATA));
	    _head = _cur;
	    for (;;) {
		_TYPED_DATA * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _temp->value.bit_mask = 0;
		    OSS_CNTX_PUSH(_oss_c, 124)
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
		    _data_tag = 0x8000;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		    _data_tag = 0x2;
		    _temp->value.data_type = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		    if ((size_t)_bufpos < (size_t)_end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
		     {
			_temp->value.bit_mask &= ~0x80000000;
			OSS_MEMSET(_g, &_temp->value.data_value, sizeof(_temp->value.data_value), 0, sizeof(_temp->value.data_value));
		    }
else {
			_temp->value.bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 123)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			_data_tag = 0x4;
			_temp->value.data_value.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.data_value.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_TYPED_DATA *)_oss_dec_const_alloc(_g, sizeof(_TYPED_DATA));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPA_ENC_TIMESTAMP(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EncryptedData *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(22,125)
    _out_data = (_EncryptedData *)_oss_dec_const_alloc(_g, sizeof(_EncryptedData));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_EncryptedData(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPA_ENC_TS_ENC(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_ENC_TS_ENC *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(23,126)
    _out_data = (_PA_ENC_TS_ENC *)_oss_dec_const_alloc(_g, sizeof(_PA_ENC_TS_ENC));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 128)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	_data_tag = 0x18;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->patimestamp, -1, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 127)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->pausec = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dETYPE_INFO(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ETYPE_INFO **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(24,129)
    _out_data = (_ETYPE_INFO **)_oss_dec_const_init_alloc(_g, sizeof(_ETYPE_INFO *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_ETYPE_INFO * _head = NULL;
	_ETYPE_INFO * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 130)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_ETYPE_INFO *)_oss_dec_const_alloc(_g, sizeof(_ETYPE_INFO));
	    _head = _cur;
	    for (;;) {
		_ETYPE_INFO * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _temp->value.bit_mask = 0;
		    OSS_CNTX_PUSH(_oss_c, 27)
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
		    _data_tag = 0x8000;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		    _data_tag = 0x2;
		    _temp->value.etype = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		    if ((size_t)_bufpos < (size_t)_end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
		     {
			_temp->value.bit_mask &= ~0x80000000;
			OSS_MEMSET(_g, &_temp->value.salt, sizeof(_temp->value.salt), 0, sizeof(_temp->value.salt));
		    }
else {
			_temp->value.bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 131)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			_data_tag = 0x4;
			_temp->value.salt.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.salt.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_ETYPE_INFO *)_oss_dec_const_alloc(_g, sizeof(_ETYPE_INFO));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dETYPE_INFO2(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ETYPE_INFO2 **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(25,132)
    _out_data = (_ETYPE_INFO2 **)_oss_dec_const_init_alloc(_g, sizeof(_ETYPE_INFO2 *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_ETYPE_INFO2 * _head = NULL;
	_ETYPE_INFO2 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 133)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_ETYPE_INFO2 *)_oss_dec_const_alloc(_g, sizeof(_ETYPE_INFO2));
	    _head = _cur;
	    for (;;) {
		_ETYPE_INFO2 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _temp->value.bit_mask = 0;
		    OSS_CNTX_PUSH(_oss_c, 27)
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
		    _data_tag = 0x8000;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		    _data_tag = 0x2;
		    _temp->value.etype = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		    if ((size_t)_bufpos < (size_t)_end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
		     {
			_temp->value.bit_mask &= ~0x80000000;
			OSS_MEMSET(_g, &_temp->value.salt, sizeof(_temp->value.salt), 0, sizeof(_temp->value.salt));
		    }
else {
			_temp->value.bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 135)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
			_data_tag = 0x1B;
			_temp->value.salt.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.salt.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
		     {
			_temp->value.bit_mask &= ~0x40000000;
			OSS_MEMSET(_g, &_temp->value.s2kparams, sizeof(_temp->value.s2kparams), 0, sizeof(_temp->value.s2kparams));
		    }
else {
			_temp->value.bit_mask |= 0x40000000;
			OSS_CNTX_PUSH(_oss_c, 134)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			_data_tag = 0x4;
			_temp->value.s2kparams.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.s2kparams.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_ETYPE_INFO2 *)_oss_dec_const_alloc(_g, sizeof(_ETYPE_INFO2));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAD_IF_RELEVANT(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AuthorizationData **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(26,136)
    _out_data = (_AuthorizationData **)_oss_dec_const_init_alloc(_g, sizeof(_AuthorizationData *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_AuthorizationData(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAD_KDCIssued(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AD_KDCIssued *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(27,137)
    _out_data = (_AD_KDCIssued *)_oss_dec_const_alloc(_g, sizeof(_AD_KDCIssued));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 141)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_Checksum(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->ad_checksum);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->i_realm, sizeof(_out_data->i_realm), 0, sizeof(_out_data->i_realm));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 140)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	    _data_tag = 0x1B;
	    _out_data->i_realm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->i_realm.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->i_sname, sizeof(_out_data->i_sname), 0, sizeof(_out_data->i_sname));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 139)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->i_sname);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 138)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8003;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_AuthorizationData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->elements);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAD_AND_OR(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AD_AND_OR *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(28,142)
    _out_data = (_AD_AND_OR *)_oss_dec_const_alloc(_g, sizeof(_AD_AND_OR));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 143)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->condition_count = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(138)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_AuthorizationData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->elements);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAD_MANDATORY_FOR_KDC(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AuthorizationData **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(29,144)
    _out_data = (_AuthorizationData **)_oss_dec_const_init_alloc(_g, sizeof(_AuthorizationData *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_AuthorizationData(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dChangePasswdData(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ChangePasswdData *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(30,145)
    _out_data = (_ChangePasswdData *)_oss_dec_const_alloc(_g, sizeof(_ChangePasswdData));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 148)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->newpasswd.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->newpasswd.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->targname, sizeof(_out_data->targname), 0, sizeof(_out_data->targname));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 147)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->targname);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->targrealm, sizeof(_out_data->targrealm), 0, sizeof(_out_data->targrealm));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 146)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	    _data_tag = 0x1B;
	    _out_data->targrealm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->targrealm.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPA_PK_AS_REQ(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_PK_AS_REQ *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(31,149)
    _out_data = (_PA_PK_AS_REQ *)_oss_dec_const_alloc(_g, sizeof(_PA_PK_AS_REQ));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 153)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	_out_data->signedAuthPack.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->signedAuthPack.value, 0);
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->trustedCertifiers, sizeof(_out_data->trustedCertifiers), 0, sizeof(_out_data->trustedCertifiers));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 151)
	    _out_data->trustedCertifiers = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_seqof9 * _head = NULL;
		_seqof9 * _cur;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		do {
		    OSS_CNTX_PUSH(_oss_c, 152)
		    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos != _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_seqof9 *)_oss_dec_const_alloc(_g, sizeof(_seqof9));
		    _head = _cur;
		    for (;;) {
			_seqof9 * _temp = _cur;
#if OSSDEBUG > 1
			count++;
#endif
			if (_data_tag != 0x10)
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
			OSS_CNTX_SETOCC(count)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_d_ExternalPrincipalIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
			if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos != _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			_cur = (_seqof9 *)_oss_dec_const_alloc(_g, sizeof(_seqof9));
			_temp->next = _cur;
		    }
		    _cur->next = NULL;
		} while (0);
		_out_data->trustedCertifiers = _head;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->kdcPkId, sizeof(_out_data->kdcPkId), 0, sizeof(_out_data->kdcPkId));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 150)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->kdcPkId.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->kdcPkId.value, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	while ((size_t)_bufpos < (size_t)_end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    OSS_UNKNOWN_EXT_FOUND(_g);
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAuthPack(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AuthPack *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(32,154)
    _out_data = (_AuthPack *)_oss_dec_const_alloc(_g, sizeof(_AuthPack));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 159)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    _out_data->pkAuthenticator.bit_mask = 0;
	    OSS_CNTX_PUSH(_oss_c, 162)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->pkAuthenticator.cusec = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_SET(93)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	    _data_tag = 0x8001;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->pkAuthenticator.ctime, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_SET(161)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	    _data_tag = 0x8002;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->pkAuthenticator.nonce = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if ((size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->pkAuthenticator.bit_mask &= ~0x80000000;
		OSS_MEMSET(_g, &_out_data->pkAuthenticator.paChecksum, sizeof(_out_data->pkAuthenticator.paChecksum), 0, sizeof(_out_data->pkAuthenticator.paChecksum));
	    }
else {
		_out_data->pkAuthenticator.bit_mask |= 0x80000000;
		OSS_CNTX_PUSH(_oss_c, 160)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
		_data_tag = 0x4;
		_out_data->pkAuthenticator.paChecksum.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->pkAuthenticator.paChecksum.value, 0);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    while ((size_t)_bufpos < (size_t)_end_pos || _total_len < 0) {
		if (!_oss_c->_tag_decoded) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (!_data_tag)
		    break;
		OSS_UNKNOWN_EXT_FOUND(_g);
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
		_oss_c->_tag_decoded = FALSE;
	    }
	    if (_total_len < 0 && !_data_tag) {
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->clientPublicValue, sizeof(_out_data->clientPublicValue), 0, sizeof(_out_data->clientPublicValue));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 158)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_SubjectPublicKeyInfo(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->clientPublicValue);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->supportedCMSTypes, sizeof(_out_data->supportedCMSTypes), 0, sizeof(_out_data->supportedCMSTypes));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 156)
	    _out_data->supportedCMSTypes = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_seqof10 * _head = NULL;
		_seqof10 * _cur;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		do {
		    OSS_CNTX_PUSH(_oss_c, 157)
		    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos != _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_seqof10 *)_oss_dec_const_alloc(_g, sizeof(_seqof10));
		    _head = _cur;
		    for (;;) {
			_seqof10 * _temp = _cur;
#if OSSDEBUG > 1
			count++;
#endif
			if (_data_tag != 0x10)
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
			OSS_CNTX_SETOCC(count)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_d_AlgorithmIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
			if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos != _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			_cur = (_seqof10 *)_oss_dec_const_alloc(_g, sizeof(_seqof10));
			_temp->next = _cur;
		    }
		    _cur->next = NULL;
		} while (0);
		_out_data->supportedCMSTypes = _head;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    OSS_MEMSET(_g, &_out_data->clientDHNonce, sizeof(_out_data->clientDHNonce), 0, sizeof(_out_data->clientDHNonce));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 155)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	    _data_tag = 0x4;
	    _out_data->clientDHNonce.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->clientDHNonce.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	while ((size_t)_bufpos < (size_t)_end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    OSS_UNKNOWN_EXT_FOUND(_g);
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTD_TRUSTED_CERTIFIERS(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof9 **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(33,163)
    _out_data = (_seqof9 **)_oss_dec_const_init_alloc(_g, sizeof(_seqof9 *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof9 * _head = NULL;
	_seqof9 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 152)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof9 *)_oss_dec_const_alloc(_g, sizeof(_seqof9));
	    _head = _cur;
	    for (;;) {
		_seqof9 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_ExternalPrincipalIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof9 *)_oss_dec_const_alloc(_g, sizeof(_seqof9));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTD_INVALID_CERTIFICATES(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof9 **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(34,164)
    _out_data = (_seqof9 **)_oss_dec_const_init_alloc(_g, sizeof(_seqof9 *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof9 * _head = NULL;
	_seqof9 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 152)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof9 *)_oss_dec_const_alloc(_g, sizeof(_seqof9));
	    _head = _cur;
	    for (;;) {
		_seqof9 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_ExternalPrincipalIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof9 *)_oss_dec_const_alloc(_g, sizeof(_seqof9));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKRB5PrincipalName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KRB5PrincipalName *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(35,165)
    _out_data = (_KRB5PrincipalName *)_oss_dec_const_alloc(_g, sizeof(_KRB5PrincipalName));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 2)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	_data_tag = 0x1B;
	_out_data->realm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->realm.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(166)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->principalName);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAD_INITIAL_VERIFIED_CAS(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof9 **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(36,167)
    _out_data = (_seqof9 **)_oss_dec_const_init_alloc(_g, sizeof(_seqof9 *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof9 * _head = NULL;
	_seqof9 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 152)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof9 *)_oss_dec_const_alloc(_g, sizeof(_seqof9));
	    _head = _cur;
	    for (;;) {
		_seqof9 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_ExternalPrincipalIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof9 *)_oss_dec_const_alloc(_g, sizeof(_seqof9));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPA_PK_AS_REP(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_PK_AS_REP *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(37,168)
    _out_data = (_PA_PK_AS_REP *)_oss_dec_const_alloc(_g, sizeof(_PA_PK_AS_REP));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 169)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
		_data_tag = 0x10;
		_out_data->u.dhInfo = (_DHRepInfo *)_oss_dec_const_alloc(_g, sizeof(_DHRepInfo));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.dhInfo->bit_mask = 0;
		    OSS_CNTX_PUSH(_oss_c, 171)
		    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
		    _data_tag = 0x8000;
		    _out_data->u.dhInfo->dhSignedData.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.dhInfo->dhSignedData.value, 0);
		    OSS_CNTX_POP(_oss_c)
		    if ((size_t)_bufpos < (size_t)_end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
		     {
			_out_data->u.dhInfo->bit_mask &= ~0x80000000;
			OSS_MEMSET(_g, &_out_data->u.dhInfo->serverDHNonce, sizeof(_out_data->u.dhInfo->serverDHNonce), 0, sizeof(_out_data->u.dhInfo->serverDHNonce));
		    }
else {
			_out_data->u.dhInfo->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 170)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			_data_tag = 0x4;
			_out_data->u.dhInfo->serverDHNonce.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.dhInfo->serverDHNonce.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    while ((size_t)_bufpos < (size_t)_end_pos || _total_len < 0) {
			if (!_oss_c->_tag_decoded) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (!_data_tag)
			    break;
			OSS_UNKNOWN_EXT_FOUND(_g);
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
			_oss_c->_tag_decoded = FALSE;
		    }
		    if (_total_len < 0 && !_data_tag) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 172)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.encKeyPack.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.encKeyPack.value, 0);
	    }   break;
	    default:
		if ((_data_tag & ~0x8000U) > 0x1 || !(_g->decodingFlags & STRICT_ENCODING_DECODING_RULES)) {
		    _oss_c->_tag_decoded = FALSE;
		    _out_data->choice = 0;	/* Unknown choice selector. */
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    OSS_UNKNOWN_EXT_FOUND(_g);
		    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_PUSH(_oss_c, 0)
		} else
		    _oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKDCDHKeyInfo(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KDCDHKeyInfo *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(38,173)
    _out_data = (_KDCDHKeyInfo *)_oss_dec_const_alloc(_g, sizeof(_KDCDHKeyInfo));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 59)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
	_data_tag = 0x3;
	_out_data->subjectPublicKey.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->subjectPublicKey.value, 0, 0);

	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(161)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->nonce = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	    _out_data->dhKeyExpiration = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 174)
	    _out_data->dhKeyExpiration = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->dhKeyExpiration, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	while ((size_t)_bufpos < (size_t)_end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    OSS_UNKNOWN_EXT_FOUND(_g);
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dReplyKeyPack(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ReplyKeyPack *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(39,175)
    _out_data = (_ReplyKeyPack *)_oss_dec_const_alloc(_g, sizeof(_ReplyKeyPack));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 177)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EncryptionKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->replyKey);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(176)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_Checksum(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->asChecksum);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	while ((size_t)_bufpos < (size_t)_end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    OSS_UNKNOWN_EXT_FOUND(_g);
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTD_DH_PARAMETERS(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof10 **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(40,178)
    _out_data = (_seqof10 **)_oss_dec_const_init_alloc(_g, sizeof(_seqof10 *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof10 * _head = NULL;
	_seqof10 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 157)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof10 *)_oss_dec_const_alloc(_g, sizeof(_seqof10));
	    _head = _cur;
	    for (;;) {
		_seqof10 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_AlgorithmIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof10 *)_oss_dec_const_alloc(_g, sizeof(_seqof10));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAttribute(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Attribute *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(41,179)
    _out_data = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 65)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	_data_tag = 0x6;
	_out_data->type.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->type.value, -1);
	OSS_CNTX_SET(180)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof1 * _head = NULL;
	    _seqof1 * _cur;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    do {
		OSS_CNTX_PUSH(_oss_c, 181)
		if (_total_len < 0) {
		    char *tmp_pos = _bufpos;
		    long tmp_len = _buflen;

		    if ((_data_tag = _oss_dec_tag(_g, &tmp_pos, &tmp_len)) == 0) {
			if (_oss_dec_length(_g, &tmp_pos, &tmp_len))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			_bufpos = tmp_pos;
			_buflen = tmp_len;
			break;
		    }
		} else
		    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos != _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		_cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		_head = _cur;
		for (;;) {
		    _seqof1 * _temp = _cur;
#if OSSDEBUG > 1
		    count++;
#endif
		    OSS_CNTX_SETOCC(count)
		    _temp->value.length = _oss_dec_uany(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value);
		    if (_total_len < 0) {
			char *tmp_pos = _bufpos;
			long tmp_len = _buflen;

			if ((_data_tag = _oss_dec_tag(_g, &tmp_pos, &tmp_len)) == 0) {
			    if (_oss_dec_length(_g, &tmp_pos, &tmp_len))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    _bufpos = tmp_pos;
			    _buflen = tmp_len;
			    break;
			}
		    } else
			if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos != _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
		    _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } while (0);
	    _out_data->values = _head;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520name(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(42,182)
    _out_data = (_X520name *)_oss_dec_const_alloc(_g, sizeof(_X520name));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0xC: {
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_out_data->u.utf8String.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.utf8String.value, 196608);
	    } else {
		_out_data->u.utf8String.length = 0;
		_out_data->u.utf8String.value = NULL;
	    }
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printableString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printableString.value, 32768);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.teletexString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.teletexString.value, 32768);
	}   break;
	case 0x1C: {
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.universalString.length = _oss_dec_unistr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.universalString.value, 32768);
	}   break;
	case 0x1E: {
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bmpString.length = _oss_dec_bmpstr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bmpString.value, 32768);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520CommonName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(43,188)
    _out_data = (_X520name *)_oss_dec_const_alloc(_g, sizeof(_X520name));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0xC: {
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_out_data->u.utf8String.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.utf8String.value, 384);
	    } else {
		_out_data->u.utf8String.length = 0;
		_out_data->u.utf8String.value = NULL;
	    }
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printableString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printableString.value, 64);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.teletexString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.teletexString.value, 64);
	}   break;
	case 0x1C: {
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.universalString.length = _oss_dec_unistr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.universalString.value, 64);
	}   break;
	case 0x1E: {
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bmpString.length = _oss_dec_bmpstr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bmpString.value, 64);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520LocalityName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(44,189)
    _out_data = (_X520name *)_oss_dec_const_alloc(_g, sizeof(_X520name));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0xC: {
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_out_data->u.utf8String.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.utf8String.value, 768);
	    } else {
		_out_data->u.utf8String.length = 0;
		_out_data->u.utf8String.value = NULL;
	    }
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printableString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printableString.value, 128);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.teletexString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.teletexString.value, 128);
	}   break;
	case 0x1C: {
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.universalString.length = _oss_dec_unistr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.universalString.value, 128);
	}   break;
	case 0x1E: {
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bmpString.length = _oss_dec_bmpstr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bmpString.value, 128);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520StateOrProvinceName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(45,190)
    _out_data = (_X520name *)_oss_dec_const_alloc(_g, sizeof(_X520name));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0xC: {
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_out_data->u.utf8String.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.utf8String.value, 768);
	    } else {
		_out_data->u.utf8String.length = 0;
		_out_data->u.utf8String.value = NULL;
	    }
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printableString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printableString.value, 128);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.teletexString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.teletexString.value, 128);
	}   break;
	case 0x1C: {
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.universalString.length = _oss_dec_unistr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.universalString.value, 128);
	}   break;
	case 0x1E: {
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bmpString.length = _oss_dec_bmpstr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bmpString.value, 128);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520OrganizationName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(46,191)
    _out_data = (_X520name *)_oss_dec_const_alloc(_g, sizeof(_X520name));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0xC: {
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_out_data->u.utf8String.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.utf8String.value, 384);
	    } else {
		_out_data->u.utf8String.length = 0;
		_out_data->u.utf8String.value = NULL;
	    }
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printableString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printableString.value, 64);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.teletexString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.teletexString.value, 64);
	}   break;
	case 0x1C: {
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.universalString.length = _oss_dec_unistr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.universalString.value, 64);
	}   break;
	case 0x1E: {
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bmpString.length = _oss_dec_bmpstr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bmpString.value, 64);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520OrganizationalUnitName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(47,192)
    _out_data = (_X520name *)_oss_dec_const_alloc(_g, sizeof(_X520name));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0xC: {
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_out_data->u.utf8String.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.utf8String.value, 384);
	    } else {
		_out_data->u.utf8String.length = 0;
		_out_data->u.utf8String.value = NULL;
	    }
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printableString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printableString.value, 64);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.teletexString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.teletexString.value, 64);
	}   break;
	case 0x1C: {
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.universalString.length = _oss_dec_unistr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.universalString.value, 64);
	}   break;
	case 0x1E: {
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bmpString.length = _oss_dec_bmpstr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bmpString.value, 64);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520Title(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(48,193)
    _out_data = (_X520name *)_oss_dec_const_alloc(_g, sizeof(_X520name));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0xC: {
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_out_data->u.utf8String.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.utf8String.value, 384);
	    } else {
		_out_data->u.utf8String.length = 0;
		_out_data->u.utf8String.value = NULL;
	    }
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printableString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printableString.value, 64);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.teletexString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.teletexString.value, 64);
	}   break;
	case 0x1C: {
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.universalString.length = _oss_dec_unistr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.universalString.value, 64);
	}   break;
	case 0x1E: {
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bmpString.length = _oss_dec_bmpstr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bmpString.value, 64);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520dnQualifier(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(49,194)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520countryName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(50,195)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 2);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520SerialNumber(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(51,196)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 64);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dX520Pseudonym(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(52,197)
    _out_data = (_X520name *)_oss_dec_const_alloc(_g, sizeof(_X520name));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0xC: {
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_out_data->u.utf8String.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.utf8String.value, 768);
	    } else {
		_out_data->u.utf8String.length = 0;
		_out_data->u.utf8String.value = NULL;
	    }
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printableString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printableString.value, 128);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.teletexString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.teletexString.value, 128);
	}   break;
	case 0x1C: {
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.universalString.length = _oss_dec_unistr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.universalString.value, 128);
	}   break;
	case 0x1E: {
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bmpString.length = _oss_dec_bmpstr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bmpString.value, 128);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dDomainComponent(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(53,198)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 22 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x16);
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dEmailAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(54,199)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 22 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x16);
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 128);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dDistinguishedName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RDNSequence **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(55,200)
    _out_data = (_RDNSequence **)_oss_dec_const_init_alloc(_g, sizeof(_RDNSequence *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RDNSequence(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dDirectoryString(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _X520name *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(56,201)
    _out_data = (_X520name *)_oss_dec_const_alloc(_g, sizeof(_X520name));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0xC: {
	    OSS_CNTX_PUSH(_oss_c, 186)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_out_data->u.utf8String.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.utf8String.value, 0);
	    } else {
		_out_data->u.utf8String.length = 0;
		_out_data->u.utf8String.value = NULL;
	    }
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printableString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printableString.value, 0);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 183)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.teletexString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.teletexString.value, 0);
	}   break;
	case 0x1C: {
	    OSS_CNTX_PUSH(_oss_c, 185)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.universalString.length = _oss_dec_unistr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.universalString.value, 0);
	}   break;
	case 0x1E: {
	    OSS_CNTX_PUSH(_oss_c, 187)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bmpString.length = _oss_dec_bmpstr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bmpString.value, 0);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dCertificate(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Certificate *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(57,202)
    _out_data = (_Certificate *)_oss_dec_const_alloc(_g, sizeof(_Certificate));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 205)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    _out_data->tbsCertificate.bit_mask = 0;
	    if ((size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8000 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->tbsCertificate.bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		OSS_MEMCPY(_g, &_out_data->tbsCertificate.version, sizeof(TBSCertificate::default_version), &TBSCertificate::default_version, sizeof(TBSCertificate::default_version));
#else
		_out_data->tbsCertificate.version = 0;
#endif
	    }
else {
		_out_data->tbsCertificate.bit_mask |= 0x80000000;
		OSS_CNTX_PUSH(_oss_c, 217)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		_data_tag = 0x2;
		_out_data->tbsCertificate.version = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    OSS_CNTX_PUSH(_oss_c, 216)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x2) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x2 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x2;
	    _out_data->tbsCertificate.serialNumber = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_SET(215)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_AlgorithmIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertificate.signature);
	    OSS_CNTX_SET(214)
	    _d_Name(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertificate.issuer);
	    OSS_CNTX_SET(211)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 213)
		_d_Time(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertificate.validity.notBefore);
		OSS_CNTX_SET(212)
		_d_Time(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertificate.validity.notAfter);
		OSS_CNTX_POP(_oss_c)
		if (_bufpos != _end_pos) {
		    if (_total_len < 0) {
			if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			if (_data_tag)
			    _oss_dec_error(_g, _expec_eoc, 0L);
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    } else
			_oss_dec_error(_g, _inconsis_len, 0L);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_SET(210)
	    _d_Name(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertificate.subject);
	    OSS_CNTX_SET(209)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_SubjectPublicKeyInfo(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertificate.subjectPublicKeyInfo);
	    OSS_CNTX_POP(_oss_c)
	    if ((size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->tbsCertificate.bit_mask &= ~0x40000000;
		OSS_MEMSET(_g, &_out_data->tbsCertificate.issuerUniqueID, sizeof(_out_data->tbsCertificate.issuerUniqueID), 0, sizeof(_out_data->tbsCertificate.issuerUniqueID));
	    }
else {
		_out_data->tbsCertificate.bit_mask |= 0x40000000;
		OSS_CNTX_PUSH(_oss_c, 208)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->tbsCertificate.issuerUniqueID.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->tbsCertificate.issuerUniqueID.value, 0, 0);

		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->tbsCertificate.bit_mask &= ~0x20000000;
		OSS_MEMSET(_g, &_out_data->tbsCertificate.subjectUniqueID, sizeof(_out_data->tbsCertificate.subjectUniqueID), 0, sizeof(_out_data->tbsCertificate.subjectUniqueID));
	    }
else {
		_out_data->tbsCertificate.bit_mask |= 0x20000000;
		OSS_CNTX_PUSH(_oss_c, 207)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->tbsCertificate.subjectUniqueID.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->tbsCertificate.subjectUniqueID.value, 0, 0);

		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->tbsCertificate.bit_mask &= ~0x10000000;
		OSS_MEMSET(_g, &_out_data->tbsCertificate.extensions, sizeof(_out_data->tbsCertificate.extensions), 0, sizeof(_out_data->tbsCertificate.extensions));
	    }
else {
		_out_data->tbsCertificate.bit_mask |= 0x10000000;
		OSS_CNTX_PUSH(_oss_c, 206)
		_out_data->tbsCertificate.extensions = NULL;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
		_data_tag = 0x10;
		_d_Extensions(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertificate.extensions);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (!_oss_c->_tag_decoded)
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(204)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_AlgorithmIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->signatureAlgorithm);
	OSS_CNTX_SET(203)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
	_data_tag = 0x3;
	_out_data->signature.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->signature.value, 0, 0);

	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dCertificateList(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CertificateList *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(58,218)
    _out_data = (_CertificateList *)_oss_dec_const_alloc(_g, sizeof(_CertificateList));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 219)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    _out_data->tbsCertList.bit_mask = 0;
	    if ((size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x2 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->tbsCertList.bit_mask &= ~0x80000000;
	    }
else {
		_out_data->tbsCertList.bit_mask |= 0x80000000;
		OSS_CNTX_PUSH(_oss_c, 217)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->tbsCertList.version = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		OSS_CNTX_POP(_oss_c)
	    }
	    OSS_CNTX_PUSH(_oss_c, 215)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x10) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x10 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x10;
	    _d_AlgorithmIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertList.signature);
	    OSS_CNTX_SET(214)
	    _d_Name(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertList.issuer);
	    OSS_CNTX_SET(226)
	    _d_Time(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertList.thisUpdate);
	    OSS_CNTX_POP(_oss_c)
	    if ((size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if ((_data_tag != 0x17 && _data_tag != 0x18)
		|| (_total_len >= 0 && (size_t)_bufpos >= (size_t)_end_pos))
	     {
		_out_data->tbsCertList.bit_mask &= ~0x40000000;
		OSS_MEMSET(_g, &_out_data->tbsCertList.nextUpdate, sizeof(_out_data->tbsCertList.nextUpdate), 0, sizeof(_out_data->tbsCertList.nextUpdate));
	    }
else {
		_out_data->tbsCertList.bit_mask |= 0x40000000;
		OSS_CNTX_PUSH(_oss_c, 225)
		_d_Time(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertList.nextUpdate);
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x10 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->tbsCertList.bit_mask &= ~0x20000000;
		OSS_MEMSET(_g, &_out_data->tbsCertList.revokedCertificates, sizeof(_out_data->tbsCertList.revokedCertificates), 0, sizeof(_out_data->tbsCertList.revokedCertificates));
	    }
else {
		_out_data->tbsCertList.bit_mask |= 0x20000000;
		OSS_CNTX_PUSH(_oss_c, 221)
		_out_data->tbsCertList.revokedCertificates = NULL;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    _seqof11 * _head = NULL;
		    _seqof11 * _cur;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		    unsigned long count = 0;
#endif
		    OSS_CNTX_INIT

		    do {
			OSS_CNTX_PUSH(_oss_c, 22)
			if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos != _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			_cur = (_seqof11 *)_oss_dec_const_alloc(_g, sizeof(_seqof11));
			_head = _cur;
			for (;;) {
			    _seqof11 * _temp = _cur;
#if OSSDEBUG > 1
			    count++;
#endif
			    if (_data_tag != 0x10)
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
			    OSS_CNTX_SETOCC(count)
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				long _total_len = _data_length;
				char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
				OSS_CNTX_INIT

				_temp->value.bit_mask = 0;
				OSS_CNTX_PUSH(_oss_c, 224)
				if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
				_data_tag = 0x2;
				_temp->value.userCertificate = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				OSS_CNTX_SET(223)
				_d_Time(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.revocationDate);
				OSS_CNTX_POP(_oss_c)
				if ((size_t)_bufpos < (size_t)_end_pos) {
				    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
					_buflen--;
					_oss_c->_bitpos = _bufpos[0] & 0x20;
					_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
					_bufpos++;
				    } else
					_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				    _oss_c->_tag_decoded = TRUE;
				}
				if (_data_tag != 0x10 || (size_t)_bufpos >= (size_t)_end_pos)
				 {
				    _temp->value.bit_mask &= ~0x80000000;
				    OSS_MEMSET(_g, &_temp->value.crlEntryExtensions, sizeof(_temp->value.crlEntryExtensions), 0, sizeof(_temp->value.crlEntryExtensions));
				}
else {
				    _temp->value.bit_mask |= 0x80000000;
				    OSS_CNTX_PUSH(_oss_c, 222)
				    _temp->value.crlEntryExtensions = NULL;
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _d_Extensions(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.crlEntryExtensions);
				    OSS_CNTX_POP(_oss_c)
				}
				if (_bufpos != _end_pos) {
				    if (_total_len < 0) {
					if (!_oss_c->_tag_decoded)
					    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

					if (_data_tag)
					    _oss_dec_error(_g, _expec_eoc, 0L);
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
				    } else
					_oss_dec_error(_g, _inconsis_len, 0L);
				}
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				if (_bufpos != _end_pos)
				    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
				break;
			    }
			    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				_bufpos++;
			    } else
				if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				    break;
				}
			    _oss_c->_tag_decoded = TRUE;
			    _cur = (_seqof11 *)_oss_dec_const_alloc(_g, sizeof(_seqof11));
			    _temp->next = _cur;
			}
			_cur->next = NULL;
		    } while (0);
		    _out_data->tbsCertList.revokedCertificates = _head;
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8000 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->tbsCertList.bit_mask &= ~0x10000000;
		OSS_MEMSET(_g, &_out_data->tbsCertList.crlExtensions, sizeof(_out_data->tbsCertList.crlExtensions), 0, sizeof(_out_data->tbsCertList.crlExtensions));
	    }
else {
		_out_data->tbsCertList.bit_mask |= 0x10000000;
		OSS_CNTX_PUSH(_oss_c, 220)
		_out_data->tbsCertList.crlExtensions = NULL;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
		_data_tag = 0x10;
		_d_Extensions(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbsCertList.crlExtensions);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (!_oss_c->_tag_decoded)
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(204)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_AlgorithmIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->signatureAlgorithm);
	OSS_CNTX_SET(203)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
	_data_tag = 0x3;
	_out_data->signature.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->signature.value, 0, 0);

	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dORAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ORAddress *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(59,227)
    _out_data = (_ORAddress *)_oss_dec_const_alloc(_g, sizeof(_ORAddress));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 236)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    _out_data->built_in_standard_attributes.bit_mask = 0;
	    if ((size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x4001 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->built_in_standard_attributes.bit_mask &= ~0x80000000;
		OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.country_name, sizeof(_out_data->built_in_standard_attributes.country_name), 0, sizeof(_out_data->built_in_standard_attributes.country_name));
	    }
else {
		_out_data->built_in_standard_attributes.bit_mask |= 0x80000000;
		OSS_CNTX_PUSH(_oss_c, 252)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		    switch (_data_tag) {
		    case 0x12: {
			OSS_CNTX_PUSH(_oss_c, 253)
			_out_data->built_in_standard_attributes.country_name.choice = 1;
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_out_data->built_in_standard_attributes.country_name.u.x121_dcc_code.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.country_name.u.x121_dcc_code.value, 3);
		    }   break;
		    case 0x13: {
			OSS_CNTX_PUSH(_oss_c, 254)
			_out_data->built_in_standard_attributes.country_name.choice = 2;
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_out_data->built_in_standard_attributes.country_name.u.iso_3166_alpha2_code.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.country_name.u.iso_3166_alpha2_code.value, 2);
		    }   break;
		    default:
			_oss_dec_error(_g, _unknown_field, _data_tag);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x4002 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->built_in_standard_attributes.bit_mask &= ~0x40000000;
		OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.administration_domain_name, sizeof(_out_data->built_in_standard_attributes.administration_domain_name), 0, sizeof(_out_data->built_in_standard_attributes.administration_domain_name));
	    }
else {
		_out_data->built_in_standard_attributes.bit_mask |= 0x40000000;
		OSS_CNTX_PUSH(_oss_c, 251)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		    switch (_data_tag) {
		    case 0x12: {
			OSS_CNTX_PUSH(_oss_c, 247)
			_out_data->built_in_standard_attributes.administration_domain_name.choice = 1;
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_out_data->built_in_standard_attributes.administration_domain_name.u.numeric.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.administration_domain_name.u.numeric.value, 16);
		    }   break;
		    case 0x13: {
			OSS_CNTX_PUSH(_oss_c, 248)
			_out_data->built_in_standard_attributes.administration_domain_name.choice = 2;
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_out_data->built_in_standard_attributes.administration_domain_name.u.printable.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.administration_domain_name.u.printable.value, 16);
		    }   break;
		    default:
			_oss_dec_error(_g, _unknown_field, _data_tag);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8000 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->built_in_standard_attributes.bit_mask &= ~0x20000000;
		OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.network_address, sizeof(_out_data->built_in_standard_attributes.network_address), 0, sizeof(_out_data->built_in_standard_attributes.network_address));
	    }
else {
		_out_data->built_in_standard_attributes.bit_mask |= 0x20000000;
		OSS_CNTX_PUSH(_oss_c, 250)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->built_in_standard_attributes.network_address.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.network_address.value, 16);
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->built_in_standard_attributes.bit_mask &= ~0x10000000;
		OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.terminal_identifier, sizeof(_out_data->built_in_standard_attributes.terminal_identifier), 0, sizeof(_out_data->built_in_standard_attributes.terminal_identifier));
	    }
else {
		_out_data->built_in_standard_attributes.bit_mask |= 0x10000000;
		OSS_CNTX_PUSH(_oss_c, 249)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->built_in_standard_attributes.terminal_identifier.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.terminal_identifier.value, 24);
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->built_in_standard_attributes.bit_mask &= ~0x8000000;
		OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.private_domain_name, sizeof(_out_data->built_in_standard_attributes.private_domain_name), 0, sizeof(_out_data->built_in_standard_attributes.private_domain_name));
	    }
else {
		_out_data->built_in_standard_attributes.bit_mask |= 0x8000000;
		OSS_CNTX_PUSH(_oss_c, 246)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		    switch (_data_tag) {
		    case 0x12: {
			OSS_CNTX_PUSH(_oss_c, 247)
			_out_data->built_in_standard_attributes.private_domain_name.choice = 1;
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_out_data->built_in_standard_attributes.private_domain_name.u.numeric.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.private_domain_name.u.numeric.value, 16);
		    }   break;
		    case 0x13: {
			OSS_CNTX_PUSH(_oss_c, 248)
			_out_data->built_in_standard_attributes.private_domain_name.choice = 2;
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_out_data->built_in_standard_attributes.private_domain_name.u.printable.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.private_domain_name.u.printable.value, 16);
		    }   break;
		    default:
			_oss_dec_error(_g, _unknown_field, _data_tag);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->built_in_standard_attributes.bit_mask &= ~0x4000000;
		OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.organization_name, sizeof(_out_data->built_in_standard_attributes.organization_name), 0, sizeof(_out_data->built_in_standard_attributes.organization_name));
	    }
else {
		_out_data->built_in_standard_attributes.bit_mask |= 0x4000000;
		OSS_CNTX_PUSH(_oss_c, 245)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->built_in_standard_attributes.organization_name.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.organization_name.value, 64);
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8004 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->built_in_standard_attributes.bit_mask &= ~0x2000000;
		OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.numeric_user_identifier, sizeof(_out_data->built_in_standard_attributes.numeric_user_identifier), 0, sizeof(_out_data->built_in_standard_attributes.numeric_user_identifier));
	    }
else {
		_out_data->built_in_standard_attributes.bit_mask |= 0x2000000;
		OSS_CNTX_PUSH(_oss_c, 244)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->built_in_standard_attributes.numeric_user_identifier.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.numeric_user_identifier.value, 32);
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8005 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->built_in_standard_attributes.bit_mask &= ~0x1000000;
		OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.personal_name, sizeof(_out_data->built_in_standard_attributes.personal_name), 0, sizeof(_out_data->built_in_standard_attributes.personal_name));
	    }
else {
		_out_data->built_in_standard_attributes.bit_mask |= 0x1000000;
		OSS_CNTX_PUSH(_oss_c, 239)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    unsigned short _present_flags = 0;
		    OSS_CNTX_DEF
		    OSS_CNTX_SETOCC(0)
		    _out_data->built_in_standard_attributes.personal_name.bit_mask = 0;
		    for (;;) {
			if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos != _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			switch (_data_tag) {
			default:
			    if (!(_data_tag & 0x8000))
				_oss_dec_error(_g, _unknown_field, _data_tag);
			    switch (_data_tag & 0x7fff) {
			    case 0x0: {
				OSS_CNTX_PUSH(_oss_c, 243)
				if (_present_flags & 0x1)
				    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->built_in_standard_attributes.personal_name.surname.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.personal_name.surname.value, 40);
				_present_flags |= 0x1;
			    }   break;
			    case 0x1: {
				OSS_CNTX_PUSH(_oss_c, 242)
				if (_out_data->built_in_standard_attributes.personal_name.bit_mask & 0x80000000)
				    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				_out_data->built_in_standard_attributes.personal_name.bit_mask |= 0x80000000;
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->built_in_standard_attributes.personal_name.given_name.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.personal_name.given_name.value, 16);
				_present_flags |= 0x2;
			    }   break;
			    case 0x2: {
				OSS_CNTX_PUSH(_oss_c, 241)
				if (_out_data->built_in_standard_attributes.personal_name.bit_mask & 0x40000000)
				    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				_out_data->built_in_standard_attributes.personal_name.bit_mask |= 0x40000000;
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->built_in_standard_attributes.personal_name.initials.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.personal_name.initials.value, 5);
				_present_flags |= 0x4;
			    }   break;
			    case 0x3: {
				OSS_CNTX_PUSH(_oss_c, 240)
				if (_out_data->built_in_standard_attributes.personal_name.bit_mask & 0x20000000)
				    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				_out_data->built_in_standard_attributes.personal_name.bit_mask |= 0x20000000;
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->built_in_standard_attributes.personal_name.generation_qualifier.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->built_in_standard_attributes.personal_name.generation_qualifier.value, 3);
				_present_flags |= 0x8;
			    }   break;
			    default:
				_oss_dec_error(_g, _unknown_field, _data_tag);
			    }
			    break;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!(_present_flags & 0x2)) {
			_out_data->built_in_standard_attributes.personal_name.bit_mask &= ~0x80000000;
			OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.personal_name.given_name,  sizeof(_out_data->built_in_standard_attributes.personal_name.given_name), 0, sizeof(_out_data->built_in_standard_attributes.personal_name.given_name));
		    }
		    if (!(_present_flags & 0x4)) {
			_out_data->built_in_standard_attributes.personal_name.bit_mask &= ~0x40000000;
			OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.personal_name.initials,  sizeof(_out_data->built_in_standard_attributes.personal_name.initials), 0, sizeof(_out_data->built_in_standard_attributes.personal_name.initials));
		    }
		    if (!(_present_flags & 0x8)) {
			_out_data->built_in_standard_attributes.personal_name.bit_mask &= ~0x20000000;
			OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.personal_name.generation_qualifier,  sizeof(_out_data->built_in_standard_attributes.personal_name.generation_qualifier), 0, sizeof(_out_data->built_in_standard_attributes.personal_name.generation_qualifier));
		    }
		    if ((_present_flags & 0x1) != 0x1)
			_oss_dec_error(_g, _field_omit, 0L);
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8006 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->built_in_standard_attributes.bit_mask &= ~0x800000;
		OSS_MEMSET(_g, &_out_data->built_in_standard_attributes.organizational_unit_names, sizeof(_out_data->built_in_standard_attributes.organizational_unit_names), 0, sizeof(_out_data->built_in_standard_attributes.organizational_unit_names));
	    }
else {
		_out_data->built_in_standard_attributes.bit_mask |= 0x800000;
		OSS_CNTX_PUSH(_oss_c, 237)
		_out_data->built_in_standard_attributes.organizational_unit_names = NULL;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    _seqof1 * _head = NULL;
		    _seqof1 * _cur;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    unsigned long count = 0;
		    OSS_CNTX_INIT

		    do {
			OSS_CNTX_PUSH(_oss_c, 238)
			if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos != _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			_cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
			_head = _cur;
			for (;;) {
			    _seqof1 * _temp = _cur;
			    count++;
			    if (!(_g->decodingFlags & NOCONSTRAIN) && (count > 4))
				_oss_dec_error(_g, _sizeConstraint_number, count);
			    if (_data_tag != 0x13)
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x130000);
			    OSS_CNTX_SETOCC(count)
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    _temp->value.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, 32);
			    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				if (_bufpos != _end_pos)
				    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
				break;
			    }
			    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				_bufpos++;
			    } else
				if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				    break;
				}
			    _oss_c->_tag_decoded = TRUE;
			    _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
			    _temp->next = _cur;
			}
			_cur->next = NULL;
		    } while (0);
		    _out_data->built_in_standard_attributes.organizational_unit_names = _head;
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		OSS_CNTX_POP(_oss_c)
	    }
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (!_oss_c->_tag_decoded)
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if ((size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x10 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->built_in_domain_defined_attributes, sizeof(_out_data->built_in_domain_defined_attributes), 0, sizeof(_out_data->built_in_domain_defined_attributes));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 232)
	    _out_data->built_in_domain_defined_attributes = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_BuiltInDomainDefinedAttributes * _head = NULL;
		_BuiltInDomainDefinedAttributes * _cur;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		unsigned long count = 0;
		OSS_CNTX_INIT

		do {
		    OSS_CNTX_PUSH(_oss_c, 233)
		    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos != _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_BuiltInDomainDefinedAttributes *)_oss_dec_const_alloc(_g, sizeof(_BuiltInDomainDefinedAttributes));
		    _head = _cur;
		    for (;;) {
			_BuiltInDomainDefinedAttributes * _temp = _cur;
			count++;
			if (!(_g->decodingFlags & NOCONSTRAIN) && (count > 4))
			    _oss_dec_error(_g, _sizeConstraint_number, count);
			if (_data_tag != 0x10)
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
			OSS_CNTX_SETOCC(count)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 235)
			    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
			    _data_tag = 0x13;
			    _temp->value.type.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.type.value, 8);
			    OSS_CNTX_SET(234)
			    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
			    _data_tag = 0x13;
			    _temp->value.value.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value.value, 128);
			    OSS_CNTX_POP(_oss_c)
			    if (_bufpos != _end_pos) {
				if (_total_len < 0) {
				    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
					_buflen--;
					_bufpos++;
				    } else
					_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				    if (_data_tag)
					_oss_dec_error(_g, _expec_eoc, 0L);
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				} else
				    _oss_dec_error(_g, _inconsis_len, 0L);
			    }
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos != _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			_cur = (_BuiltInDomainDefinedAttributes *)_oss_dec_const_alloc(_g, sizeof(_BuiltInDomainDefinedAttributes));
			_temp->next = _cur;
		    }
		    _cur->next = NULL;
		} while (0);
		_out_data->built_in_domain_defined_attributes = _head;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x11 || (size_t)_bufpos >= (size_t)_end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->extension_attributes, sizeof(_out_data->extension_attributes), 0, sizeof(_out_data->extension_attributes));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 228)
	    _out_data->extension_attributes = NULL;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_ExtensionAttributes * _head = NULL;
		_ExtensionAttributes * _cur;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		unsigned long count = 0;
		OSS_CNTX_INIT

		do {
		    OSS_CNTX_PUSH(_oss_c, 229)
		    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos != _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_ExtensionAttributes *)_oss_dec_const_alloc(_g, sizeof(_ExtensionAttributes));
		    _head = _cur;
		    for (;;) {
			_ExtensionAttributes * _temp = _cur;
			count++;
			if (!(_g->decodingFlags & NOCONSTRAIN) && (count > 256))
			    _oss_dec_error(_g, _sizeConstraint_number, count);
			if (_data_tag != 0x10)
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
			OSS_CNTX_SETOCC(count)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    int _indef_tags = 0;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 231)
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
			    _data_tag = 0x8000;
			    _temp->value.extension_attribute_type = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
			    OSS_CNTX_SET(230)
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
			    _data_tag = 0x8001;
			    if (_data_length < 0) ++_indef_tags;
			    _temp->value.extension_attribute_value.length = _oss_dec_uany(_g, &_bufpos, &_buflen, _data_length, &_temp->value.extension_attribute_value.value);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			    if (_bufpos != _end_pos) {
				if (_total_len < 0) {
				    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
					_buflen--;
					_bufpos++;
				    } else
					_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				    if (_data_tag)
					_oss_dec_error(_g, _expec_eoc, 0L);
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				} else
				    _oss_dec_error(_g, _inconsis_len, 0L);
			    }
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos != _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			_cur = (_ExtensionAttributes *)_oss_dec_const_alloc(_g, sizeof(_ExtensionAttributes));
			_temp->next = _cur;
		    }
		    _cur->next = NULL;
		} while (0);
		_out_data->extension_attributes = _head;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dCommonName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(60,255)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 64);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTeletexCommonName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(61,256)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 20 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x14);
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 64);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTeletexOrganizationName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(62,257)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 20 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x14);
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 64);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTeletexPersonalName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PersonalName *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(63,258)
    _out_data = (_PersonalName *)_oss_dec_const_alloc(_g, sizeof(_PersonalName));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	_out_data->bit_mask = 0;
	for (;;) {
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    default:
		if (!(_data_tag & 0x8000))
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		switch (_data_tag & 0x7fff) {
		case 0x0: {
		    OSS_CNTX_PUSH(_oss_c, 243)
		    if (_present_flags & 0x1)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->surname.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->surname.value, 40);
		    _present_flags |= 0x1;
		}   break;
		case 0x1: {
		    OSS_CNTX_PUSH(_oss_c, 242)
		    if (_out_data->bit_mask & 0x80000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x80000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->given_name.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->given_name.value, 16);
		    _present_flags |= 0x2;
		}   break;
		case 0x2: {
		    OSS_CNTX_PUSH(_oss_c, 241)
		    if (_out_data->bit_mask & 0x40000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x40000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->initials.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->initials.value, 5);
		    _present_flags |= 0x4;
		}   break;
		case 0x3: {
		    OSS_CNTX_PUSH(_oss_c, 240)
		    if (_out_data->bit_mask & 0x20000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x20000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->generation_qualifier.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->generation_qualifier.value, 3);
		    _present_flags |= 0x8;
		}   break;
		default:
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		}
		break;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!(_present_flags & 0x2)) {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->given_name,  sizeof(_out_data->given_name), 0, sizeof(_out_data->given_name));
	}
	if (!(_present_flags & 0x4)) {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->initials,  sizeof(_out_data->initials), 0, sizeof(_out_data->initials));
	}
	if (!(_present_flags & 0x8)) {
	    _out_data->bit_mask &= ~0x20000000;
	    OSS_MEMSET(_g, &_out_data->generation_qualifier,  sizeof(_out_data->generation_qualifier), 0, sizeof(_out_data->generation_qualifier));
	}
	if ((_present_flags & 0x1) != 0x1)
	    _oss_dec_error(_g, _field_omit, 0L);
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _d0TeletexOrganizationalUnitNa(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seqof1 **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(64,259)
    _out_data = (_seqof1 **)_oss_dec_const_init_alloc(_g, sizeof(_seqof1 *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof1 * _head = NULL;
	_seqof1 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned long count = 0;
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 260)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
	    _head = _cur;
	    for (;;) {
		_seqof1 * _temp = _cur;
		count++;
		if (!(_g->decodingFlags & NOCONSTRAIN) && (count > 4))
		    _oss_dec_error(_g, _sizeConstraint_number, count);
		if (_data_tag != 0x14)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x140000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_temp->value.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, 32);
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPDSName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(65,261)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 16);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPhysicalDeliveryCountryName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CountryName *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(66,262)
    _out_data = (_CountryName *)_oss_dec_const_alloc(_g, sizeof(_CountryName));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0x12: {
	    OSS_CNTX_PUSH(_oss_c, 253)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.x121_dcc_code.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.x121_dcc_code.value, 3);
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 254)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.iso_3166_alpha2_code.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.iso_3166_alpha2_code.value, 2);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPostalCode(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PostalCode *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(67,263)
    _out_data = (_PostalCode *)_oss_dec_const_alloc(_g, sizeof(_PostalCode));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0x12: {
	    OSS_CNTX_PUSH(_oss_c, 264)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.numeric_code.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.numeric_code.value, 16);
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 265)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printable_code.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printable_code.value, 16);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPhysicalDeliveryOfficeName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(68,266)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPhysicalDeliveryOfficeNumber(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(69,267)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dExtensionORAddressComponents(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(70,268)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPhysicalDeliveryPersonalName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(71,269)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _d1PhysicalDeliveryOrganizatio(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(72,270)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _d2ExtensionPhysicalDeliveryAd(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(73,271)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dUnformattedPostalAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _UnformattedPostalAddress *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(74,272)
    _out_data = (_UnformattedPostalAddress *)_oss_dec_const_alloc(_g, sizeof(_UnformattedPostalAddress));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	_out_data->bit_mask = 0;
	for (;;) {
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    case 0x10: {
		OSS_CNTX_PUSH(_oss_c, 273)
		if (_out_data->bit_mask & 0x80000000)
		    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		_out_data->bit_mask |= 0x80000000;
		_out_data->printable_address = NULL;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    _seqof1 * _head = NULL;
		    _seqof1 * _cur;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    unsigned long count = 0;
		    OSS_CNTX_INIT

		    do {
			OSS_CNTX_PUSH(_oss_c, 274)
			if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos != _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			_cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
			_head = _cur;
			for (;;) {
			    _seqof1 * _temp = _cur;
			    count++;
			    if (!(_g->decodingFlags & NOCONSTRAIN) && (count > 6))
				_oss_dec_error(_g, _sizeConstraint_number, count);
			    if (_data_tag != 0x13)
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x130000);
			    OSS_CNTX_SETOCC(count)
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    _temp->value.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, 30);
			    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				if (_bufpos != _end_pos)
				    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
				break;
			    }
			    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				_bufpos++;
			    } else
				if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				    break;
				}
			    _oss_c->_tag_decoded = TRUE;
			    _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
			    _temp->next = _cur;
			}
			_cur->next = NULL;
		    } while (0);
		    _out_data->printable_address = _head;
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		_present_flags |= 0x1;
	    }   break;
	    case 0x14: {
		OSS_CNTX_PUSH(_oss_c, 72)
		if (_out_data->bit_mask & 0x40000000)
		    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		_out_data->bit_mask |= 0x40000000;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->teletex_string.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->teletex_string.value, 180);
		_present_flags |= 0x2;
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!(_present_flags & 0x1)) {
	    _out_data->bit_mask &= ~0x80000000;
	    OSS_MEMSET(_g, &_out_data->printable_address,  sizeof(_out_data->printable_address), 0, sizeof(_out_data->printable_address));
	}
	if (!(_present_flags & 0x2)) {
	    _out_data->bit_mask &= ~0x40000000;
	    OSS_MEMSET(_g, &_out_data->teletex_string,  sizeof(_out_data->teletex_string), 0, sizeof(_out_data->teletex_string));
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dStreetAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(75,275)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPostOfficeBoxAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(76,276)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPosteRestanteAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(77,277)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dUniquePostalName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(78,278)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dLocalPostalAttributes(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PDSParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(79,279)
    _out_data = (_PDSParameter *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
    _d_PDSParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dExtendedNetworkAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ExtendedNetworkAddress *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(80,280)
    _out_data = (_ExtendedNetworkAddress *)_oss_dec_const_alloc(_g, sizeof(_ExtendedNetworkAddress));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0x10: {
	    OSS_CNTX_PUSH(_oss_c, 281)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.e163_4_address = (_seq5 *)_oss_dec_const_alloc(_g, sizeof(_seq5));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		_out_data->u.e163_4_address->bit_mask = 0;
		OSS_CNTX_PUSH(_oss_c, 283)
		if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
		_data_tag = 0x8000;
		_out_data->u.e163_4_address->number.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.e163_4_address->number.value, 15);
		OSS_CNTX_POP(_oss_c)
		if ((size_t)_bufpos < (size_t)_end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
		 {
		    _out_data->u.e163_4_address->bit_mask &= ~0x80000000;
		    OSS_MEMSET(_g, &_out_data->u.e163_4_address->sub_address, sizeof(_out_data->u.e163_4_address->sub_address), 0, sizeof(_out_data->u.e163_4_address->sub_address));
		}
else {
		    _out_data->u.e163_4_address->bit_mask |= 0x80000000;
		    OSS_CNTX_PUSH(_oss_c, 282)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->u.e163_4_address->sub_address.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.e163_4_address->sub_address.value, 40);
		    OSS_CNTX_POP(_oss_c)
		}
		if (_bufpos != _end_pos) {
		    if (_total_len < 0) {
			if (!_oss_c->_tag_decoded)
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			if (_data_tag)
			    _oss_dec_error(_g, _expec_eoc, 0L);
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    } else
			_oss_dec_error(_g, _inconsis_len, 0L);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}   break;
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 284)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.psap_address = (_PresentationAddress *)_oss_dec_const_alloc(_g, sizeof(_PresentationAddress));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.psap_address->bit_mask = 0;
		    if ((size_t)_bufpos < (size_t)_end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8000 || (size_t)_bufpos >= (size_t)_end_pos)
		     {
			_out_data->u.psap_address->bit_mask &= ~0x80000000;
			OSS_MEMSET(_g, &_out_data->u.psap_address->pSelector, sizeof(_out_data->u.psap_address->pSelector), 0, sizeof(_out_data->u.psap_address->pSelector));
		    }
else {
			_out_data->u.psap_address->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 289)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			_data_tag = 0x4;
			_out_data->u.psap_address->pSelector.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.psap_address->pSelector.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
		     {
			_out_data->u.psap_address->bit_mask &= ~0x40000000;
			OSS_MEMSET(_g, &_out_data->u.psap_address->sSelector, sizeof(_out_data->u.psap_address->sSelector), 0, sizeof(_out_data->u.psap_address->sSelector));
		    }
else {
			_out_data->u.psap_address->bit_mask |= 0x40000000;
			OSS_CNTX_PUSH(_oss_c, 288)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			_data_tag = 0x4;
			_out_data->u.psap_address->sSelector.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.psap_address->sSelector.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8002 || (size_t)_bufpos >= (size_t)_end_pos)
		     {
			_out_data->u.psap_address->bit_mask &= ~0x20000000;
			OSS_MEMSET(_g, &_out_data->u.psap_address->tSelector, sizeof(_out_data->u.psap_address->tSelector), 0, sizeof(_out_data->u.psap_address->tSelector));
		    }
else {
			_out_data->u.psap_address->bit_mask |= 0x20000000;
			OSS_CNTX_PUSH(_oss_c, 287)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			_data_tag = 0x4;
			_out_data->u.psap_address->tSelector.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.psap_address->tSelector.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    OSS_CNTX_PUSH(_oss_c, 285)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8003;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
		    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			_seqof1 * _head = NULL;
			_seqof1 * _cur;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			unsigned long count = 0;
#endif
			OSS_CNTX_INIT

			do {
			    OSS_CNTX_PUSH(_oss_c, 286)
			    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				if (_bufpos != _end_pos)
				    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
				break;
			    }
			    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				_bufpos++;
			    } else
				if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				    break;
				}
			    _oss_c->_tag_decoded = TRUE;
			    _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
			    _head = _cur;
			    for (;;) {
				_seqof1 * _temp = _cur;
#if OSSDEBUG > 1
				count++;
#endif
				if (_data_tag != 0x4)
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x40000);
				OSS_CNTX_SETOCC(count)
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_temp->value.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, 0);
				if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_bufpos != _end_pos)
					_oss_dec_error(_g, _inconsis_len, 0L);
#endif
				    break;
				}
				if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				    _bufpos++;
				} else
				    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					break;
				    }
				_oss_c->_tag_decoded = TRUE;
				_cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
				_temp->next = _cur;
			    }
			    _cur->next = NULL;
			} while (0);
			_out_data->u.psap_address->nAddresses = _head;
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				_buflen--;
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTerminalType(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(81,290)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _d3TeletexDomainDefinedAttribu(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _BuiltInDomainDefinedAttributes **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(82,291)
    _out_data = (_BuiltInDomainDefinedAttributes **)_oss_dec_const_init_alloc(_g, sizeof(_BuiltInDomainDefinedAttributes *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_BuiltInDomainDefinedAttributes * _head = NULL;
	_BuiltInDomainDefinedAttributes * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned long count = 0;
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 292)
	    if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos != _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_BuiltInDomainDefinedAttributes *)_oss_dec_const_alloc(_g, sizeof(_BuiltInDomainDefinedAttributes));
	    _head = _cur;
	    for (;;) {
		_BuiltInDomainDefinedAttributes * _temp = _cur;
		count++;
		if (!(_g->decodingFlags & NOCONSTRAIN) && (count > 4))
		    _oss_dec_error(_g, _sizeConstraint_number, count);
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 235)
		    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 20 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x14);
		    _data_tag = 0x14;
		    _temp->value.type.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.type.value, 8);
		    OSS_CNTX_SET(234)
		    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 20 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x14);
		    _data_tag = 0x14;
		    _temp->value.value.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value.value, 128);
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				_buflen--;
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		if ((size_t)_bufpos >= (size_t)_end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos != _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_BuiltInDomainDefinedAttributes *)_oss_dec_const_alloc(_g, sizeof(_BuiltInDomainDefinedAttributes));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAuthPack_OLD(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AuthPack_OLD *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(83,293)
    _out_data = (_AuthPack_OLD *)_oss_dec_const_alloc(_g, sizeof(_AuthPack_OLD));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 294)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 296)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->pkAuthenticator.kdc_name);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_SET(295)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	    _data_tag = 0x8001;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	    _data_tag = 0x1B;
	    _out_data->pkAuthenticator.kdc_realm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->pkAuthenticator.kdc_realm.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_SET(162)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	    _data_tag = 0x8002;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->pkAuthenticator.cusec = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_SET(93)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x83);
	    _data_tag = 0x8003;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
	    _data_tag = 0x18;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->pkAuthenticator.ctime, -1, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_SET(161)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x84);
	    _data_tag = 0x8004;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->pkAuthenticator.nonce = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKERB_REPLY_KEY_PACKAGE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KERB_REPLY_KEY_PACKAGE *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(84,297)
    _out_data = (_KERB_REPLY_KEY_PACKAGE *)_oss_dec_const_alloc(_g, sizeof(_KERB_REPLY_KEY_PACKAGE));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 177)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EncryptionKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->replyKey);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(161)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->nonce = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	while ((size_t)_bufpos < (size_t)_end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    OSS_UNKNOWN_EXT_FOUND(_g);
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPA_FOR_USER_ENC(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_FOR_USER_ENC *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(85,298)
    _out_data = (_PA_FOR_USER_ENC *)_oss_dec_const_alloc(_g, sizeof(_PA_FOR_USER_ENC));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 301)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->userName);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(300)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	_data_tag = 0x1B;
	_out_data->userRealm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->userRealm.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(95)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
	_data_tag = 0x8002;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_Checksum(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->cksum);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(299)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x83);
	_data_tag = 0x8003;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	_data_tag = 0x1B;
	_out_data->auth_package.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->auth_package.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPA_S4U_X509_USER(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_S4U_X509_USER *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(86,302)
    _out_data = (_PA_S4U_X509_USER *)_oss_dec_const_alloc(_g, sizeof(_PA_S4U_X509_USER));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 304)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    _out_data->user_id.bit_mask = 0;
	    OSS_CNTX_PUSH(_oss_c, 8)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->user_id.nonce = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if ((size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8001 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->user_id.bit_mask &= ~0x80000000;
		OSS_MEMSET(_g, &_out_data->user_id.cname, sizeof(_out_data->user_id.cname), 0, sizeof(_out_data->user_id.cname));
	    }
else {
		_out_data->user_id.bit_mask |= 0x80000000;
		OSS_CNTX_PUSH(_oss_c, 12)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
		_data_tag = 0x10;
		_d_PrincipalName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->user_id.cname);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    OSS_CNTX_PUSH(_oss_c, 40)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8002;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 27 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1B);
	    _data_tag = 0x1B;
	    _out_data->user_id.crealm.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->user_id.crealm.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if ((size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8003 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->user_id.bit_mask &= ~0x40000000;
		OSS_MEMSET(_g, &_out_data->user_id.subject_certificate, sizeof(_out_data->user_id.subject_certificate), 0, sizeof(_out_data->user_id.subject_certificate));
	    }
else {
		_out_data->user_id.bit_mask |= 0x40000000;
		OSS_CNTX_PUSH(_oss_c, 306)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
		_data_tag = 0x4;
		_out_data->user_id.subject_certificate.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->user_id.subject_certificate.value, 0);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    if (!_oss_c->_tag_decoded && (size_t)_bufpos < (size_t)_end_pos) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (_data_tag != 0x8004 || (size_t)_bufpos >= (size_t)_end_pos)
	     {
		_out_data->user_id.bit_mask &= ~0x20000000;
		OSS_MEMSET(_g, &_out_data->user_id.options, sizeof(_out_data->user_id.options), 0, sizeof(_out_data->user_id.options));
	    }
else {
		_out_data->user_id.bit_mask |= 0x20000000;
		OSS_CNTX_PUSH(_oss_c, 305)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
		_data_tag = 0x3;
		_out_data->user_id.options.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->user_id.options.value, 0, 0);

		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    while ((size_t)_bufpos < (size_t)_end_pos || _total_len < 0) {
		if (!_oss_c->_tag_decoded) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (!_data_tag)
		    break;
		OSS_UNKNOWN_EXT_FOUND(_g);
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
		_oss_c->_tag_decoded = FALSE;
	    }
	    if (_total_len < 0 && !_data_tag) {
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(303)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_Checksum(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->checksum);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPA_PAC_OPTIONS(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PA_PAC_OPTIONS *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(87,307)
    _out_data = (_PA_PAC_OPTIONS *)_oss_dec_const_alloc(_g, sizeof(_PA_PAC_OPTIONS));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 308)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
	_data_tag = 0x3;
	_out_data->kerberosFlags.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->kerberosFlags.value, 0, 0);

	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKERB_PA_PAC_REQUEST(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KERB_PA_PAC_REQUEST *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(88,309)
    _out_data = (_KERB_PA_PAC_REQUEST *)_oss_dec_const_alloc(_g, sizeof(_KERB_PA_PAC_REQUEST));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 310)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1);
	_data_tag = 0x1;
	_out_data->include_pac = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKERB_LOCAL(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(89,311)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _out_data->length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKERB_AD_RESTRICTION_ENTRY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KERB_AD_RESTRICTION_ENTRY *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(90,312)
    _out_data = (_KERB_AD_RESTRICTION_ENTRY *)_oss_dec_const_alloc(_g, sizeof(_KERB_AD_RESTRICTION_ENTRY));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 314)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->restriction_type = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(313)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->restriction.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->restriction.value, 0);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPA_SUPPORTED_ENCTYPES(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(91,315)
    _out_data = (OSS_INT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    *_out_data = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

void DLL_ENTRY_FDEF _dmMS_SFU_KILE(struct ossGlobal * _g, int * _pdunum, void ** _outbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;

    _oss_c->_oss_context_anchor._state = _decoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_pre(_g, _oss_c->_oss_inbufpos, _oss_c->_oss_inbuflen, NULL);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (*_pdunum < 1 || *_pdunum > 91)
	_oss_dec_error(_g, _pdu_range, *_pdunum);
    *_outbuf = _Decoders[*_pdunum - 1](_g);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_post(_g, 0, *_pdunum, _outbuf);
#endif
}

#if (OSS_TOED_API_LEVEL < 22) || !defined(OSSNOFREEPDU)
#if OSS_TOED_API_LEVEL < 32
#define _oss_dec_free(_g, v)   if (v) _oss_dec_free(_g, v)
#define _oss_free_creal(_g, v) if (v) _oss_free_creal(_g, v)
#endif
static void _f_Ticket(OssGlobal * _g, _Ticket * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->realm.value);
	_f_PrincipalName(_g, &_data_ptr->sname);
	_f_EncryptedData(_g, &_data_ptr->enc_part);
    }
}

static void _f_KDC_REQ_BODY(OssGlobal * _g, _KDC_REQ_BODY * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->kdc_options.value);
	if (_data_ptr->bit_mask & 0x80000000) {
	    _f_PrincipalName(_g, &_data_ptr->cname);
	}
	    _oss_dec_free(_g, _data_ptr->realm.value);
	if (_data_ptr->bit_mask & 0x40000000) {
	    _f_PrincipalName(_g, &_data_ptr->sname);
	}
	_oss_dec_free(_g, _data_ptr->from);
	_oss_dec_free(_g, _data_ptr->till);
	_oss_dec_free(_g, _data_ptr->rtime);
	_f__seqof2(_g, &_data_ptr->etype);
	if (_data_ptr->bit_mask & 0x20000000) {
	    _f_HostAddresses(_g, &_data_ptr->addresses);
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    _f_EncryptedData(_g, &_data_ptr->enc_authorization_data);
	}
	if (_data_ptr->bit_mask & 0x8000000) {
	    _f__seqof3(_g, &_data_ptr->additional_tickets);
	}
    }
}

static void _f__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof1 * _tempa = *_data_ptr;
	    _seqof1 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		    _oss_dec_free(_g, _tempa->value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f_PrincipalName(OssGlobal * _g, _PrincipalName * _data_ptr)
{
    if (_data_ptr) {
	_f__seqof1(_g, &_data_ptr->name_string);
    }
}

static void _f_HostAddress(OssGlobal * _g, _HostAddress * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->address.value);
    }
}

static void _f_HostAddresses(OssGlobal * _g, _HostAddresses ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _HostAddresses * _tempa = *_data_ptr;
	    _HostAddresses * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_HostAddress(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f__seq1(OssGlobal * _g, _seq1 * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->ad_data.value);
    }
}

static void _f_AuthorizationData(OssGlobal * _g, _AuthorizationData ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _AuthorizationData * _tempa = *_data_ptr;
	    _AuthorizationData * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f__seq1(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f_PA_DATA(OssGlobal * _g, _PA_DATA * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->padata_value.value);
    }
}

static void _f_EncryptedData(OssGlobal * _g, _EncryptedData * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->cipher.value);
    }
}

static void _f_EncryptionKey(OssGlobal * _g, _EncryptionKey * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->keyvalue.value);
    }
}

static void _f_Checksum(OssGlobal * _g, _Checksum * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->checksum.value);
    }
}

static void _f__seqof2(OssGlobal * _g, _seqof2 ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof2 * _tempa = *_data_ptr;
	    _seqof2 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f__seqof3(OssGlobal * _g, _seqof3 ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof3 * _tempa = *_data_ptr;
	    _seqof3 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_Ticket(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f__seqof4(OssGlobal * _g, _seqof4 ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof4 * _tempa = *_data_ptr;
	    _seqof4 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_PA_DATA(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f_KDC_REQ(OssGlobal * _g, _KDC_REQ * _data_ptr)
{
    if (_data_ptr) {
	if (_data_ptr->bit_mask & 0x80000000) {
	    _f__seqof4(_g, &_data_ptr->padata);
	}
	_f_KDC_REQ_BODY(_g, &_data_ptr->req_body);
    }
}

static void _f__seqof5(OssGlobal * _g, _seqof4 ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof4 * _tempa = *_data_ptr;
	    _seqof4 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_PA_DATA(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f_KDC_REP(OssGlobal * _g, _KDC_REP * _data_ptr)
{
    if (_data_ptr) {
	if (_data_ptr->bit_mask & 0x80000000) {
	    _f__seqof5(_g, &_data_ptr->padata);
	}
	    _oss_dec_free(_g, _data_ptr->crealm.value);
	_f_PrincipalName(_g, &_data_ptr->cname);
	_f_Ticket(_g, &_data_ptr->ticket);
	_f_EncryptedData(_g, &_data_ptr->enc_part);
    }
}

static void _f__seqof6(OssGlobal * _g, _seqof4 ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof4 * _tempa = *_data_ptr;
	    _seqof4 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_PA_DATA(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f_EncKDCRepPart(OssGlobal * _g, _EncKDCRepPart * _data_ptr)
{
    if (_data_ptr) {
	_f_EncryptionKey(_g, &_data_ptr->key);
	_f_LastReq(_g, &_data_ptr->last_req);
	_oss_dec_free(_g, _data_ptr->key_expiration);
	    _oss_dec_free(_g, _data_ptr->flags.value);
	_oss_dec_free(_g, _data_ptr->authtime);
	_oss_dec_free(_g, _data_ptr->starttime);
	_oss_dec_free(_g, _data_ptr->endtime);
	_oss_dec_free(_g, _data_ptr->renew_till);
	    _oss_dec_free(_g, _data_ptr->srealm.value);
	_f_PrincipalName(_g, &_data_ptr->sname);
	if (_data_ptr->bit_mask & 0x80000000) {
	    _f_HostAddresses(_g, &_data_ptr->caddr);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    _f__seqof6(_g, &_data_ptr->encrypted_pa_data);
	}
    }
}

static void _f__seq2(OssGlobal * _g, _seq2 * _data_ptr)
{
    if (_data_ptr) {
	_oss_dec_free(_g, _data_ptr->lr_value);
    }
}

static void _f_LastReq(OssGlobal * _g, _LastReq ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _LastReq * _tempa = *_data_ptr;
	    _LastReq * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f__seq2(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f_ExternalPrincipalIdentifier(OssGlobal * _g, _ExternalPrincipalIdentifier * _data_ptr)
{
    if (_data_ptr) {
	if (_data_ptr->bit_mask & 0x80000000) {
		_oss_dec_free(_g, _data_ptr->subjectName.value);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
		_oss_dec_free(_g, _data_ptr->issuerAndSerialNumber.value);
	}
	if (_data_ptr->bit_mask & 0x20000000) {
		_oss_dec_free(_g, _data_ptr->subjectKeyIdentifier.value);
	}
    }
}

static void _f_AlgorithmIdentifier(OssGlobal * _g, _AlgorithmIdentifier * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->algorithm.value);
	if (_data_ptr->bit_mask & 0x80000000) {
		_oss_dec_free(_g, _data_ptr->parameters.value);
	}
    }
}

static void _f_SubjectPublicKeyInfo(OssGlobal * _g, _SubjectPublicKeyInfo * _data_ptr)
{
    if (_data_ptr) {
	_f_AlgorithmIdentifier(_g, &_data_ptr->algorithm);
	    _oss_dec_free(_g, _data_ptr->subjectPublicKey.value);
    }
}

static void _f_Name(OssGlobal * _g, _Name * _data_ptr)
{
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
	    _f_RDNSequence(_g, &_data_ptr->u.rdnSequence);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
}

static void _f_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _RDNSequence * _tempa = *_data_ptr;
	    _RDNSequence * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value) {
		    _RelativeDistinguishedName * _temp1a = _tempa->value;
		    _RelativeDistinguishedName * _temp1b;
		    while (_temp1a) {
			_temp1b = _temp1a->next;
			    _oss_dec_free(_g, _temp1a->value.type.value);
			    _oss_dec_free(_g, _temp1a->value.value.value);
			_oss_dec_free(_g, _temp1a);
			_temp1a = _temp1b;
		    }
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f_Time(OssGlobal * _g, _Time * _data_ptr)
{
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
	    _oss_dec_free(_g, _data_ptr->u.utcTime);
	    break;
	case 2:
	    _oss_dec_free(_g, _data_ptr->u.generalTime);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
}

static void _f_Extension(OssGlobal * _g, _Extension * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->extnID.value);
	    _oss_dec_free(_g, _data_ptr->extnValue.value);
    }
}

static void _f_Extensions(OssGlobal * _g, _Extensions ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _Extensions * _tempa = *_data_ptr;
	    _Extensions * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_Extension(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f_PDSParameter(OssGlobal * _g, _PDSParameter * _data_ptr)
{
    if (_data_ptr) {
	if (_data_ptr->bit_mask & 0x80000000) {
		_oss_dec_free(_g, _data_ptr->printable_string.value);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
		_oss_dec_free(_g, _data_ptr->teletex_string.value);
	}
    }
}

static void _fTicket(OssGlobal * _g, void * _data)
{
    _Ticket	*_data_ptr;
    _data_ptr = (_Ticket *)_data;
    _f_Ticket(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fEncTicketPart(OssGlobal * _g, void * _data)
{
    _EncTicketPart	*_data_ptr;
    _data_ptr = (_EncTicketPart *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->flags.value);
	_f_EncryptionKey(_g, &_data_ptr->key);
	    _oss_dec_free(_g, _data_ptr->crealm.value);
	_f_PrincipalName(_g, &_data_ptr->cname);
	    _oss_dec_free(_g, _data_ptr->transited.contents.value);
	_oss_dec_free(_g, _data_ptr->authtime);
	_oss_dec_free(_g, _data_ptr->starttime);
	_oss_dec_free(_g, _data_ptr->endtime);
	_oss_dec_free(_g, _data_ptr->renew_till);
	if (_data_ptr->bit_mask & 0x80000000) {
	    _f_HostAddresses(_g, &_data_ptr->caddr);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    _f_AuthorizationData(_g, &_data_ptr->authorization_data);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAS_REQ(OssGlobal * _g, void * _data)
{
    _KDC_REQ	*_data_ptr;
    _data_ptr = (_KDC_REQ *)_data;
    _f_KDC_REQ(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fTGS_REQ(OssGlobal * _g, void * _data)
{
    _KDC_REQ	*_data_ptr;
    _data_ptr = (_KDC_REQ *)_data;
    _f_KDC_REQ(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fKDC_REQ_BODY(OssGlobal * _g, void * _data)
{
    _KDC_REQ_BODY	*_data_ptr;
    _data_ptr = (_KDC_REQ_BODY *)_data;
    _f_KDC_REQ_BODY(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fAS_REP(OssGlobal * _g, void * _data)
{
    _KDC_REP	*_data_ptr;
    _data_ptr = (_KDC_REP *)_data;
    _f_KDC_REP(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fTGS_REP(OssGlobal * _g, void * _data)
{
    _KDC_REP	*_data_ptr;
    _data_ptr = (_KDC_REP *)_data;
    _f_KDC_REP(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fEncASRepPart(OssGlobal * _g, void * _data)
{
    _EncKDCRepPart	*_data_ptr;
    _data_ptr = (_EncKDCRepPart *)_data;
    _f_EncKDCRepPart(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fEncTGSRepPart(OssGlobal * _g, void * _data)
{
    _EncKDCRepPart	*_data_ptr;
    _data_ptr = (_EncKDCRepPart *)_data;
    _f_EncKDCRepPart(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fAP_REQ(OssGlobal * _g, void * _data)
{
    _AP_REQ	*_data_ptr;
    _data_ptr = (_AP_REQ *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->ap_options.value);
	_f_Ticket(_g, &_data_ptr->ticket);
	_f_EncryptedData(_g, &_data_ptr->authenticator);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAuthenticator(OssGlobal * _g, void * _data)
{
    _Authenticator	*_data_ptr;
    _data_ptr = (_Authenticator *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->crealm.value);
	_f_PrincipalName(_g, &_data_ptr->cname);
	if (_data_ptr->bit_mask & 0x80000000) {
	    _f_Checksum(_g, &_data_ptr->cksum);
	}
	_oss_dec_free(_g, _data_ptr->ctime);
	if (_data_ptr->bit_mask & 0x40000000) {
	    _f_EncryptionKey(_g, &_data_ptr->subkey);
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    _f_AuthorizationData(_g, &_data_ptr->authorization_data);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAP_REP(OssGlobal * _g, void * _data)
{
    _AP_REP	*_data_ptr;
    _data_ptr = (_AP_REP *)_data;
    if (_data_ptr) {
	_f_EncryptedData(_g, &_data_ptr->enc_part);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fEncAPRepPart(OssGlobal * _g, void * _data)
{
    _EncAPRepPart	*_data_ptr;
    _data_ptr = (_EncAPRepPart *)_data;
    if (_data_ptr) {
	_oss_dec_free(_g, _data_ptr->ctime);
	if (_data_ptr->bit_mask & 0x80000000) {
	    _f_EncryptionKey(_g, &_data_ptr->subkey);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fKRB_SAFE(OssGlobal * _g, void * _data)
{
    _KRB_SAFE	*_data_ptr;
    _data_ptr = (_KRB_SAFE *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->safe_body.user_data.value);
	_oss_dec_free(_g, _data_ptr->safe_body.timestamp);
	_f_HostAddress(_g, &_data_ptr->safe_body.s_address);
	if (_data_ptr->safe_body.bit_mask & 0x20000000) {
	    _f_HostAddress(_g, &_data_ptr->safe_body.r_address);
	}
	_f_Checksum(_g, &_data_ptr->cksum);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fKRB_PRIV(OssGlobal * _g, void * _data)
{
    _AP_REP	*_data_ptr;
    _data_ptr = (_AP_REP *)_data;
    if (_data_ptr) {
	_f_EncryptedData(_g, &_data_ptr->enc_part);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fEncKrbPrivPart(OssGlobal * _g, void * _data)
{
    _KRB_SAFE_BODY	*_data_ptr;
    _data_ptr = (_KRB_SAFE_BODY *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->user_data.value);
	_oss_dec_free(_g, _data_ptr->timestamp);
	_f_HostAddress(_g, &_data_ptr->s_address);
	if (_data_ptr->bit_mask & 0x20000000) {
	    _f_HostAddress(_g, &_data_ptr->r_address);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fKRB_CRED(OssGlobal * _g, void * _data)
{
    _KRB_CRED	*_data_ptr;
    _data_ptr = (_KRB_CRED *)_data;
    if (_data_ptr) {
	if (_data_ptr->tickets) {
	    _seqof3 * _tempa = _data_ptr->tickets;
	    _seqof3 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_Ticket(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
	_f_EncryptedData(_g, &_data_ptr->enc_part);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fEncKrbCredPart(OssGlobal * _g, void * _data)
{
    _EncKrbCredPart	*_data_ptr;
    _data_ptr = (_EncKrbCredPart *)_data;
    if (_data_ptr) {
	if (_data_ptr->ticket_info) {
	    _seqof8 * _tempa = _data_ptr->ticket_info;
	    _seqof8 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_EncryptionKey(_g, &_tempa->value.key);
		if (_tempa->value.bit_mask & 0x80000000) {
			_oss_dec_free(_g, _tempa->value.prealm.value);
		}
		if (_tempa->value.bit_mask & 0x40000000) {
		    _f_PrincipalName(_g, &_tempa->value.pname);
		}
		if (_tempa->value.bit_mask & 0x20000000) {
			_oss_dec_free(_g, _tempa->value.flags.value);
		}
		_oss_dec_free(_g, _tempa->value.authtime);
		_oss_dec_free(_g, _tempa->value.starttime);
		_oss_dec_free(_g, _tempa->value.endtime);
		_oss_dec_free(_g, _tempa->value.renew_till);
		if (_tempa->value.bit_mask & 0x10000000) {
			_oss_dec_free(_g, _tempa->value.srealm.value);
		}
		if (_tempa->value.bit_mask & 0x8000000) {
		    _f_PrincipalName(_g, &_tempa->value.sname);
		}
		if (_tempa->value.bit_mask & 0x4000000) {
		    _f_HostAddresses(_g, &_tempa->value.caddr);
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
	_oss_dec_free(_g, _data_ptr->timestamp);
	if (_data_ptr->bit_mask & 0x20000000) {
	    _f_HostAddress(_g, &_data_ptr->s_address);
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    _f_HostAddress(_g, &_data_ptr->r_address);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fKRB_ERROR(OssGlobal * _g, void * _data)
{
    _KRB_ERROR	*_data_ptr;
    _data_ptr = (_KRB_ERROR *)_data;
    if (_data_ptr) {
	_oss_dec_free(_g, _data_ptr->ctime);
	_oss_dec_free(_g, _data_ptr->stime);
	if (_data_ptr->bit_mask & 0x40000000) {
		_oss_dec_free(_g, _data_ptr->crealm.value);
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    _f_PrincipalName(_g, &_data_ptr->cname);
	}
	    _oss_dec_free(_g, _data_ptr->realm.value);
	_f_PrincipalName(_g, &_data_ptr->sname);
	if (_data_ptr->bit_mask & 0x10000000) {
		_oss_dec_free(_g, _data_ptr->e_text.value);
	}
	if (_data_ptr->bit_mask & 0x8000000) {
		_oss_dec_free(_g, _data_ptr->e_data.value);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fMETHOD_DATA(OssGlobal * _g, void * _data)
{
    _seqof4	**_data_ptr;
    _data_ptr = (_seqof4 **)_data;
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof4 * _tempa = *_data_ptr;
	    _seqof4 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_PA_DATA(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTYPED_DATA(OssGlobal * _g, void * _data)
{
    _TYPED_DATA	**_data_ptr;
    _data_ptr = (_TYPED_DATA **)_data;
    if (_data_ptr) {
	if (*_data_ptr) {
	    _TYPED_DATA * _tempa = *_data_ptr;
	    _TYPED_DATA * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.bit_mask & 0x80000000) {
			_oss_dec_free(_g, _tempa->value.data_value.value);
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPA_ENC_TIMESTAMP(OssGlobal * _g, void * _data)
{
    _EncryptedData	*_data_ptr;
    _data_ptr = (_EncryptedData *)_data;
    _f_EncryptedData(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fPA_ENC_TS_ENC(OssGlobal * _g, void * _data)
{
    _PA_ENC_TS_ENC	*_data_ptr;
    _data_ptr = (_PA_ENC_TS_ENC *)_data;
    if (_data_ptr) {
	_oss_dec_free(_g, _data_ptr->patimestamp);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fETYPE_INFO(OssGlobal * _g, void * _data)
{
    _ETYPE_INFO	**_data_ptr;
    _data_ptr = (_ETYPE_INFO **)_data;
    if (_data_ptr) {
	if (*_data_ptr) {
	    _ETYPE_INFO * _tempa = *_data_ptr;
	    _ETYPE_INFO * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.bit_mask & 0x80000000) {
			_oss_dec_free(_g, _tempa->value.salt.value);
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fETYPE_INFO2(OssGlobal * _g, void * _data)
{
    _ETYPE_INFO2	**_data_ptr;
    _data_ptr = (_ETYPE_INFO2 **)_data;
    if (_data_ptr) {
	if (*_data_ptr) {
	    _ETYPE_INFO2 * _tempa = *_data_ptr;
	    _ETYPE_INFO2 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.bit_mask & 0x80000000) {
			_oss_dec_free(_g, _tempa->value.salt.value);
		}
		if (_tempa->value.bit_mask & 0x40000000) {
			_oss_dec_free(_g, _tempa->value.s2kparams.value);
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAD_IF_RELEVANT(OssGlobal * _g, void * _data)
{
    _AuthorizationData	**_data_ptr;
    _data_ptr = (_AuthorizationData **)_data;
    _f_AuthorizationData(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fAD_KDCIssued(OssGlobal * _g, void * _data)
{
    _AD_KDCIssued	*_data_ptr;
    _data_ptr = (_AD_KDCIssued *)_data;
    if (_data_ptr) {
	_f_Checksum(_g, &_data_ptr->ad_checksum);
	if (_data_ptr->bit_mask & 0x80000000) {
		_oss_dec_free(_g, _data_ptr->i_realm.value);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    _f_PrincipalName(_g, &_data_ptr->i_sname);
	}
	_f_AuthorizationData(_g, &_data_ptr->elements);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAD_AND_OR(OssGlobal * _g, void * _data)
{
    _AD_AND_OR	*_data_ptr;
    _data_ptr = (_AD_AND_OR *)_data;
    if (_data_ptr) {
	_f_AuthorizationData(_g, &_data_ptr->elements);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAD_MANDATORY_FOR_KDC(OssGlobal * _g, void * _data)
{
    _AuthorizationData	**_data_ptr;
    _data_ptr = (_AuthorizationData **)_data;
    _f_AuthorizationData(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fChangePasswdData(OssGlobal * _g, void * _data)
{
    _ChangePasswdData	*_data_ptr;
    _data_ptr = (_ChangePasswdData *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->newpasswd.value);
	if (_data_ptr->bit_mask & 0x80000000) {
	    _f_PrincipalName(_g, &_data_ptr->targname);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
		_oss_dec_free(_g, _data_ptr->targrealm.value);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPA_PK_AS_REQ(OssGlobal * _g, void * _data)
{
    _PA_PK_AS_REQ	*_data_ptr;
    _data_ptr = (_PA_PK_AS_REQ *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->signedAuthPack.value);
	if (_data_ptr->bit_mask & 0x80000000) {
	    if (_data_ptr->trustedCertifiers) {
		_seqof9 * _tempa = _data_ptr->trustedCertifiers;
		_seqof9 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _f_ExternalPrincipalIdentifier(_g, &_tempa->value);
		    _oss_dec_free(_g, _tempa);
		    _tempa = _tempb;
		}
	    }
	}
	if (_data_ptr->bit_mask & 0x40000000) {
		_oss_dec_free(_g, _data_ptr->kdcPkId.value);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAuthPack(OssGlobal * _g, void * _data)
{
    _AuthPack	*_data_ptr;
    _data_ptr = (_AuthPack *)_data;
    if (_data_ptr) {
	_oss_dec_free(_g, _data_ptr->pkAuthenticator.ctime);
	if (_data_ptr->pkAuthenticator.bit_mask & 0x80000000) {
		_oss_dec_free(_g, _data_ptr->pkAuthenticator.paChecksum.value);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    _f_SubjectPublicKeyInfo(_g, &_data_ptr->clientPublicValue);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_data_ptr->supportedCMSTypes) {
		_seqof10 * _tempa = _data_ptr->supportedCMSTypes;
		_seqof10 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _f_AlgorithmIdentifier(_g, &_tempa->value);
		    _oss_dec_free(_g, _tempa);
		    _tempa = _tempb;
		}
	    }
	}
	if (_data_ptr->bit_mask & 0x20000000) {
		_oss_dec_free(_g, _data_ptr->clientDHNonce.value);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTD_TRUSTED_CERTIFIERS(OssGlobal * _g, void * _data)
{
    _seqof9	**_data_ptr;
    _data_ptr = (_seqof9 **)_data;
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof9 * _tempa = *_data_ptr;
	    _seqof9 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_ExternalPrincipalIdentifier(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTD_INVALID_CERTIFICATES(OssGlobal * _g, void * _data)
{
    _seqof9	**_data_ptr;
    _data_ptr = (_seqof9 **)_data;
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof9 * _tempa = *_data_ptr;
	    _seqof9 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_ExternalPrincipalIdentifier(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fKRB5PrincipalName(OssGlobal * _g, void * _data)
{
    _KRB5PrincipalName	*_data_ptr;
    _data_ptr = (_KRB5PrincipalName *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->realm.value);
	_f_PrincipalName(_g, &_data_ptr->principalName);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAD_INITIAL_VERIFIED_CAS(OssGlobal * _g, void * _data)
{
    _seqof9	**_data_ptr;
    _data_ptr = (_seqof9 **)_data;
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof9 * _tempa = *_data_ptr;
	    _seqof9 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_ExternalPrincipalIdentifier(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPA_PK_AS_REP(OssGlobal * _g, void * _data)
{
    _PA_PK_AS_REP	*_data_ptr;
    _data_ptr = (_PA_PK_AS_REP *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
	    if (_data_ptr->u.dhInfo) {
		    _oss_dec_free(_g, _data_ptr->u.dhInfo->dhSignedData.value);
		if (_data_ptr->u.dhInfo->bit_mask & 0x80000000) {
			_oss_dec_free(_g, _data_ptr->u.dhInfo->serverDHNonce.value);
		}
	    }
	    _oss_dec_free(_g, _data_ptr->u.dhInfo);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.encKeyPack.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fKDCDHKeyInfo(OssGlobal * _g, void * _data)
{
    _KDCDHKeyInfo	*_data_ptr;
    _data_ptr = (_KDCDHKeyInfo *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->subjectPublicKey.value);
	_oss_dec_free(_g, _data_ptr->dhKeyExpiration);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fReplyKeyPack(OssGlobal * _g, void * _data)
{
    _ReplyKeyPack	*_data_ptr;
    _data_ptr = (_ReplyKeyPack *)_data;
    if (_data_ptr) {
	_f_EncryptionKey(_g, &_data_ptr->replyKey);
	_f_Checksum(_g, &_data_ptr->asChecksum);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTD_DH_PARAMETERS(OssGlobal * _g, void * _data)
{
    _seqof10	**_data_ptr;
    _data_ptr = (_seqof10 **)_data;
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof10 * _tempa = *_data_ptr;
	    _seqof10 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_AlgorithmIdentifier(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAttribute(OssGlobal * _g, void * _data)
{
    _Attribute	*_data_ptr;
    _data_ptr = (_Attribute *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->type.value);
	if (_data_ptr->values) {
	    _seqof1 * _tempa = _data_ptr->values;
	    _seqof1 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		    _oss_dec_free(_g, _tempa->value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520name(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.teletexString.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.printableString.value);
	    break;
	case 3:
		_oss_dec_free(_g, _data_ptr->u.universalString.value);
	    break;
	case 4:
		_oss_dec_free(_g, _data_ptr->u.utf8String.value);
	    break;
	case 5:
		_oss_dec_free(_g, _data_ptr->u.bmpString.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520CommonName(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.teletexString.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.printableString.value);
	    break;
	case 3:
		_oss_dec_free(_g, _data_ptr->u.universalString.value);
	    break;
	case 4:
		_oss_dec_free(_g, _data_ptr->u.utf8String.value);
	    break;
	case 5:
		_oss_dec_free(_g, _data_ptr->u.bmpString.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520LocalityName(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.teletexString.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.printableString.value);
	    break;
	case 3:
		_oss_dec_free(_g, _data_ptr->u.universalString.value);
	    break;
	case 4:
		_oss_dec_free(_g, _data_ptr->u.utf8String.value);
	    break;
	case 5:
		_oss_dec_free(_g, _data_ptr->u.bmpString.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520StateOrProvinceName(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.teletexString.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.printableString.value);
	    break;
	case 3:
		_oss_dec_free(_g, _data_ptr->u.universalString.value);
	    break;
	case 4:
		_oss_dec_free(_g, _data_ptr->u.utf8String.value);
	    break;
	case 5:
		_oss_dec_free(_g, _data_ptr->u.bmpString.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520OrganizationName(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.teletexString.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.printableString.value);
	    break;
	case 3:
		_oss_dec_free(_g, _data_ptr->u.universalString.value);
	    break;
	case 4:
		_oss_dec_free(_g, _data_ptr->u.utf8String.value);
	    break;
	case 5:
		_oss_dec_free(_g, _data_ptr->u.bmpString.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520OrganizationalUnitName(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.teletexString.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.printableString.value);
	    break;
	case 3:
		_oss_dec_free(_g, _data_ptr->u.universalString.value);
	    break;
	case 4:
		_oss_dec_free(_g, _data_ptr->u.utf8String.value);
	    break;
	case 5:
		_oss_dec_free(_g, _data_ptr->u.bmpString.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520Title(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.teletexString.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.printableString.value);
	    break;
	case 3:
		_oss_dec_free(_g, _data_ptr->u.universalString.value);
	    break;
	case 4:
		_oss_dec_free(_g, _data_ptr->u.utf8String.value);
	    break;
	case 5:
		_oss_dec_free(_g, _data_ptr->u.bmpString.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520dnQualifier(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520countryName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520SerialNumber(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fX520Pseudonym(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.teletexString.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.printableString.value);
	    break;
	case 3:
		_oss_dec_free(_g, _data_ptr->u.universalString.value);
	    break;
	case 4:
		_oss_dec_free(_g, _data_ptr->u.utf8String.value);
	    break;
	case 5:
		_oss_dec_free(_g, _data_ptr->u.bmpString.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fDomainComponent(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fEmailAddress(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fDistinguishedName(OssGlobal * _g, void * _data)
{
    _RDNSequence	**_data_ptr;
    _data_ptr = (_RDNSequence **)_data;
    _f_RDNSequence(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fDirectoryString(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.teletexString.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.printableString.value);
	    break;
	case 3:
		_oss_dec_free(_g, _data_ptr->u.universalString.value);
	    break;
	case 4:
		_oss_dec_free(_g, _data_ptr->u.utf8String.value);
	    break;
	case 5:
		_oss_dec_free(_g, _data_ptr->u.bmpString.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCertificate(OssGlobal * _g, void * _data)
{
    _Certificate	*_data_ptr;
    _data_ptr = (_Certificate *)_data;
    if (_data_ptr) {
	_f_AlgorithmIdentifier(_g, &_data_ptr->tbsCertificate.signature);
	_f_Name(_g, &_data_ptr->tbsCertificate.issuer);
	_f_Time(_g, &_data_ptr->tbsCertificate.validity.notBefore);
	_f_Time(_g, &_data_ptr->tbsCertificate.validity.notAfter);
	_f_Name(_g, &_data_ptr->tbsCertificate.subject);
	_f_SubjectPublicKeyInfo(_g, &_data_ptr->tbsCertificate.subjectPublicKeyInfo);
	if (_data_ptr->tbsCertificate.bit_mask & 0x40000000) {
		_oss_dec_free(_g, _data_ptr->tbsCertificate.issuerUniqueID.value);
	}
	if (_data_ptr->tbsCertificate.bit_mask & 0x20000000) {
		_oss_dec_free(_g, _data_ptr->tbsCertificate.subjectUniqueID.value);
	}
	if (_data_ptr->tbsCertificate.bit_mask & 0x10000000) {
	    _f_Extensions(_g, &_data_ptr->tbsCertificate.extensions);
	}
	_f_AlgorithmIdentifier(_g, &_data_ptr->signatureAlgorithm);
	    _oss_dec_free(_g, _data_ptr->signature.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCertificateList(OssGlobal * _g, void * _data)
{
    _CertificateList	*_data_ptr;
    _data_ptr = (_CertificateList *)_data;
    if (_data_ptr) {
	_f_AlgorithmIdentifier(_g, &_data_ptr->tbsCertList.signature);
	_f_Name(_g, &_data_ptr->tbsCertList.issuer);
	_f_Time(_g, &_data_ptr->tbsCertList.thisUpdate);
	if (_data_ptr->tbsCertList.bit_mask & 0x40000000) {
	    _f_Time(_g, &_data_ptr->tbsCertList.nextUpdate);
	}
	if (_data_ptr->tbsCertList.bit_mask & 0x20000000) {
	    if (_data_ptr->tbsCertList.revokedCertificates) {
		_seqof11 * _tempa = _data_ptr->tbsCertList.revokedCertificates;
		_seqof11 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _f_Time(_g, &_tempa->value.revocationDate);
		    if (_tempa->value.bit_mask & 0x80000000) {
			_f_Extensions(_g, &_tempa->value.crlEntryExtensions);
		    }
		    _oss_dec_free(_g, _tempa);
		    _tempa = _tempb;
		}
	    }
	}
	if (_data_ptr->tbsCertList.bit_mask & 0x10000000) {
	    _f_Extensions(_g, &_data_ptr->tbsCertList.crlExtensions);
	}
	_f_AlgorithmIdentifier(_g, &_data_ptr->signatureAlgorithm);
	    _oss_dec_free(_g, _data_ptr->signature.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fORAddress(OssGlobal * _g, void * _data)
{
    _ORAddress	*_data_ptr;
    _data_ptr = (_ORAddress *)_data;
    if (_data_ptr) {
	if (_data_ptr->built_in_standard_attributes.bit_mask & 0x80000000) {
	    switch (_data_ptr->built_in_standard_attributes.country_name.choice) {
	    case 1:
		    _oss_dec_free(_g, _data_ptr->built_in_standard_attributes.country_name.u.x121_dcc_code.value);
		break;
	    case 2:
		    _oss_dec_free(_g, _data_ptr->built_in_standard_attributes.country_name.u.iso_3166_alpha2_code.value);
		break;
	    default:
		/* Ignore for now */	;
	    }
	}
	if (_data_ptr->built_in_standard_attributes.bit_mask & 0x40000000) {
	    switch (_data_ptr->built_in_standard_attributes.administration_domain_name.choice) {
	    case 1:
		    _oss_dec_free(_g, _data_ptr->built_in_standard_attributes.administration_domain_name.u.numeric.value);
		break;
	    case 2:
		    _oss_dec_free(_g, _data_ptr->built_in_standard_attributes.administration_domain_name.u.printable.value);
		break;
	    default:
		/* Ignore for now */	;
	    }
	}
	if (_data_ptr->built_in_standard_attributes.bit_mask & 0x20000000) {
		_oss_dec_free(_g, _data_ptr->built_in_standard_attributes.network_address.value);
	}
	if (_data_ptr->built_in_standard_attributes.bit_mask & 0x10000000) {
		_oss_dec_free(_g, _data_ptr->built_in_standard_attributes.terminal_identifier.value);
	}
	if (_data_ptr->built_in_standard_attributes.bit_mask & 0x8000000) {
	    switch (_data_ptr->built_in_standard_attributes.private_domain_name.choice) {
	    case 1:
		    _oss_dec_free(_g, _data_ptr->built_in_standard_attributes.private_domain_name.u.numeric.value);
		break;
	    case 2:
		    _oss_dec_free(_g, _data_ptr->built_in_standard_attributes.private_domain_name.u.printable.value);
		break;
	    default:
		/* Ignore for now */	;
	    }
	}
	if (_data_ptr->built_in_standard_attributes.bit_mask & 0x4000000) {
		_oss_dec_free(_g, _data_ptr->built_in_standard_attributes.organization_name.value);
	}
	if (_data_ptr->built_in_standard_attributes.bit_mask & 0x2000000) {
		_oss_dec_free(_g, _data_ptr->built_in_standard_attributes.numeric_user_identifier.value);
	}
	if (_data_ptr->built_in_standard_attributes.bit_mask & 0x1000000) {
		_oss_dec_free(_g, _data_ptr->built_in_standard_attributes.personal_name.surname.value);
	    if (_data_ptr->built_in_standard_attributes.personal_name.bit_mask & 0x80000000) {
		    _oss_dec_free(_g, _data_ptr->built_in_standard_attributes.personal_name.given_name.value);
	    }
	    if (_data_ptr->built_in_standard_attributes.personal_name.bit_mask & 0x40000000) {
		    _oss_dec_free(_g, _data_ptr->built_in_standard_attributes.personal_name.initials.value);
	    }
	    if (_data_ptr->built_in_standard_attributes.personal_name.bit_mask & 0x20000000) {
		    _oss_dec_free(_g, _data_ptr->built_in_standard_attributes.personal_name.generation_qualifier.value);
	    }
	}
	if (_data_ptr->built_in_standard_attributes.bit_mask & 0x800000) {
	    if (_data_ptr->built_in_standard_attributes.organizational_unit_names) {
		_seqof1 * _tempa = _data_ptr->built_in_standard_attributes.organizational_unit_names;
		_seqof1 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
			_oss_dec_free(_g, _tempa->value.value);
		    _oss_dec_free(_g, _tempa);
		    _tempa = _tempb;
		}
	    }
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    if (_data_ptr->built_in_domain_defined_attributes) {
		_BuiltInDomainDefinedAttributes * _tempa = _data_ptr->built_in_domain_defined_attributes;
		_BuiltInDomainDefinedAttributes * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
			_oss_dec_free(_g, _tempa->value.type.value);
			_oss_dec_free(_g, _tempa->value.value.value);
		    _oss_dec_free(_g, _tempa);
		    _tempa = _tempb;
		}
	    }
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_data_ptr->extension_attributes) {
		_ExtensionAttributes * _tempa = _data_ptr->extension_attributes;
		_ExtensionAttributes * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
			_oss_dec_free(_g, _tempa->value.extension_attribute_value.value);
		    _oss_dec_free(_g, _tempa);
		    _tempa = _tempb;
		}
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCommonName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTeletexCommonName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTeletexOrganizationName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTeletexPersonalName(OssGlobal * _g, void * _data)
{
    _PersonalName	*_data_ptr;
    _data_ptr = (_PersonalName *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->surname.value);
	if (_data_ptr->bit_mask & 0x80000000) {
		_oss_dec_free(_g, _data_ptr->given_name.value);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
		_oss_dec_free(_g, _data_ptr->initials.value);
	}
	if (_data_ptr->bit_mask & 0x20000000) {
		_oss_dec_free(_g, _data_ptr->generation_qualifier.value);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _f0TeletexOrganizationalUnitNa(OssGlobal * _g, void * _data)
{
    _seqof1	**_data_ptr;
    _data_ptr = (_seqof1 **)_data;
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof1 * _tempa = *_data_ptr;
	    _seqof1 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		    _oss_dec_free(_g, _tempa->value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPDSName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPhysicalDeliveryCountryName(OssGlobal * _g, void * _data)
{
    _CountryName	*_data_ptr;
    _data_ptr = (_CountryName *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.x121_dcc_code.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.iso_3166_alpha2_code.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPostalCode(OssGlobal * _g, void * _data)
{
    _PostalCode	*_data_ptr;
    _data_ptr = (_PostalCode *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
		_oss_dec_free(_g, _data_ptr->u.numeric_code.value);
	    break;
	case 2:
		_oss_dec_free(_g, _data_ptr->u.printable_code.value);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPhysicalDeliveryOfficeName(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fPhysicalDeliveryOfficeNumber(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fExtensionORAddressComponents(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fPhysicalDeliveryPersonalName(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _f1PhysicalDeliveryOrganizatio(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _f2ExtensionPhysicalDeliveryAd(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fUnformattedPostalAddress(OssGlobal * _g, void * _data)
{
    _UnformattedPostalAddress	*_data_ptr;
    _data_ptr = (_UnformattedPostalAddress *)_data;
    if (_data_ptr) {
	if (_data_ptr->bit_mask & 0x80000000) {
	    if (_data_ptr->printable_address) {
		_seqof1 * _tempa = _data_ptr->printable_address;
		_seqof1 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
			_oss_dec_free(_g, _tempa->value.value);
		    _oss_dec_free(_g, _tempa);
		    _tempa = _tempb;
		}
	    }
	}
	if (_data_ptr->bit_mask & 0x40000000) {
		_oss_dec_free(_g, _data_ptr->teletex_string.value);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fStreetAddress(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fPostOfficeBoxAddress(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fPosteRestanteAddress(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fUniquePostalName(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fLocalPostalAttributes(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _f_PDSParameter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fExtendedNetworkAddress(OssGlobal * _g, void * _data)
{
    _ExtendedNetworkAddress	*_data_ptr;
    _data_ptr = (_ExtendedNetworkAddress *)_data;
    if (_data_ptr) {
	switch (_data_ptr->choice) {
	case 1:
	    if (_data_ptr->u.e163_4_address) {
		    _oss_dec_free(_g, _data_ptr->u.e163_4_address->number.value);
		if (_data_ptr->u.e163_4_address->bit_mask & 0x80000000) {
			_oss_dec_free(_g, _data_ptr->u.e163_4_address->sub_address.value);
		}
	    }
	    _oss_dec_free(_g, _data_ptr->u.e163_4_address);
	    break;
	case 2:
	    if (_data_ptr->u.psap_address) {
		if (_data_ptr->u.psap_address->bit_mask & 0x80000000) {
			_oss_dec_free(_g, _data_ptr->u.psap_address->pSelector.value);
		}
		if (_data_ptr->u.psap_address->bit_mask & 0x40000000) {
			_oss_dec_free(_g, _data_ptr->u.psap_address->sSelector.value);
		}
		if (_data_ptr->u.psap_address->bit_mask & 0x20000000) {
			_oss_dec_free(_g, _data_ptr->u.psap_address->tSelector.value);
		}
		if (_data_ptr->u.psap_address->nAddresses) {
		    _seqof1 * _tempa = _data_ptr->u.psap_address->nAddresses;
		    _seqof1 * _tempb;
		    while (_tempa) {
			_tempb = _tempa->next;
			    _oss_dec_free(_g, _tempa->value.value);
			_oss_dec_free(_g, _tempa);
			_tempa = _tempb;
		    }
		}
	    }
	    _oss_dec_free(_g, _data_ptr->u.psap_address);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTerminalType(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f3TeletexDomainDefinedAttribu(OssGlobal * _g, void * _data)
{
    _BuiltInDomainDefinedAttributes	**_data_ptr;
    _data_ptr = (_BuiltInDomainDefinedAttributes **)_data;
    if (_data_ptr) {
	if (*_data_ptr) {
	    _BuiltInDomainDefinedAttributes * _tempa = *_data_ptr;
	    _BuiltInDomainDefinedAttributes * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		    _oss_dec_free(_g, _tempa->value.type.value);
		    _oss_dec_free(_g, _tempa->value.value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAuthPack_OLD(OssGlobal * _g, void * _data)
{
    _AuthPack_OLD	*_data_ptr;
    _data_ptr = (_AuthPack_OLD *)_data;
    if (_data_ptr) {
	_f_PrincipalName(_g, &_data_ptr->pkAuthenticator.kdc_name);
	    _oss_dec_free(_g, _data_ptr->pkAuthenticator.kdc_realm.value);
	_oss_dec_free(_g, _data_ptr->pkAuthenticator.ctime);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fKERB_REPLY_KEY_PACKAGE(OssGlobal * _g, void * _data)
{
    _KERB_REPLY_KEY_PACKAGE	*_data_ptr;
    _data_ptr = (_KERB_REPLY_KEY_PACKAGE *)_data;
    if (_data_ptr) {
	_f_EncryptionKey(_g, &_data_ptr->replyKey);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPA_FOR_USER_ENC(OssGlobal * _g, void * _data)
{
    _PA_FOR_USER_ENC	*_data_ptr;
    _data_ptr = (_PA_FOR_USER_ENC *)_data;
    if (_data_ptr) {
	_f_PrincipalName(_g, &_data_ptr->userName);
	    _oss_dec_free(_g, _data_ptr->userRealm.value);
	_f_Checksum(_g, &_data_ptr->cksum);
	    _oss_dec_free(_g, _data_ptr->auth_package.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPA_S4U_X509_USER(OssGlobal * _g, void * _data)
{
    _PA_S4U_X509_USER	*_data_ptr;
    _data_ptr = (_PA_S4U_X509_USER *)_data;
    if (_data_ptr) {
	if (_data_ptr->user_id.bit_mask & 0x80000000) {
	    _f_PrincipalName(_g, &_data_ptr->user_id.cname);
	}
	    _oss_dec_free(_g, _data_ptr->user_id.crealm.value);
	if (_data_ptr->user_id.bit_mask & 0x40000000) {
		_oss_dec_free(_g, _data_ptr->user_id.subject_certificate.value);
	}
	if (_data_ptr->user_id.bit_mask & 0x20000000) {
		_oss_dec_free(_g, _data_ptr->user_id.options.value);
	}
	_f_Checksum(_g, &_data_ptr->checksum);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPA_PAC_OPTIONS(OssGlobal * _g, void * _data)
{
    _PA_PAC_OPTIONS	*_data_ptr;
    _data_ptr = (_PA_PAC_OPTIONS *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->kerberosFlags.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fKERB_PA_PAC_REQUEST(OssGlobal * _g, void * _data)
{
    _KERB_PA_PAC_REQUEST	*_data_ptr;
    _data_ptr = (_KERB_PA_PAC_REQUEST *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fKERB_LOCAL(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fKERB_AD_RESTRICTION_ENTRY(OssGlobal * _g, void * _data)
{
    _KERB_AD_RESTRICTION_ENTRY	*_data_ptr;
    _data_ptr = (_KERB_AD_RESTRICTION_ENTRY *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->restriction.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPA_SUPPORTED_ENCTYPES(OssGlobal * _g, void * _data)
{
    OSS_INT32	*_data_ptr;
    _data_ptr = (OSS_INT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

int DLL_ENTRY_FDEF _fmMS_SFU_KILE(struct ossGlobal * _g, int _pdunum, void * _data)
{
    if (_pdunum < 1 || _pdunum > 91)
	return PDU_RANGE;
    else
	_FreePDU[_pdunum - 1](_g, _data);

    return PDU_FREED;
}

#endif
#ifdef OSSPRINT
static void _p_Ticket(OssGlobal * _g, _Ticket * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "tkt-vno ");
	{
	    ULONG_LONG value = _data_ptr->tkt_vno;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "realm ");
	_oss_prt_char(_g, (char *)_data_ptr->realm.value, _data_ptr->realm.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "sname ");
	_p_PrincipalName(_g, &_data_ptr->sname);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "enc-part ");
	_p_EncryptedData(_g, &_data_ptr->enc_part);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_KDC_REQ_BODY(OssGlobal * _g, _KDC_REQ_BODY * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "kdc-options ");
	_oss_prt_bit(_g, _data_ptr->kdc_options.value, _data_ptr->kdc_options.length);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "cname ");
	    _p_PrincipalName(_g, &_data_ptr->cname);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "realm ");
	_oss_prt_char(_g, (char *)_data_ptr->realm.value, _data_ptr->realm.length);
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "sname ");
	    _p_PrincipalName(_g, &_data_ptr->sname);
	}
	if (_data_ptr->from) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "from ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->from == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->from);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "till ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->till == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->till);
	if (_data_ptr->rtime) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "rtime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->rtime == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->rtime);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "nonce ");
	{
	    ULONG_LONG value = _data_ptr->nonce;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "etype ");
	_p__seqof2(_g, &_data_ptr->etype);
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "addresses ");
	    _p_HostAddresses(_g, &_data_ptr->addresses);
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "enc-authorization-data ");
	    _p_EncryptedData(_g, &_data_ptr->enc_authorization_data);
	}
	if (_data_ptr->bit_mask & 0x8000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "additional-tickets ");
	    _p__seqof3(_g, &_data_ptr->additional_tickets);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof1 * _tempa = *_data_ptr;
	_seqof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _oss_prt_char(_g, (char *)_tempa->value.value, _tempa->value.length);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_PrincipalName(OssGlobal * _g, _PrincipalName * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "name-type ");
	{
	    LONG_LONG value = _data_ptr->name_type;
	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "name-string ");
	_p__seqof1(_g, &_data_ptr->name_string);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_HostAddress(OssGlobal * _g, _HostAddress * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "addr-type ");
	{
	    LONG_LONG value = _data_ptr->addr_type;
	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "address ");
	_oss_prt_oct(_g, _data_ptr->address.value, _data_ptr->address.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_HostAddresses(OssGlobal * _g, _HostAddresses ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_HostAddresses * _tempa = *_data_ptr;
	_HostAddresses * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_HostAddress(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__seq1(OssGlobal * _g, _seq1 * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "ad-type ");
	{
	    LONG_LONG value = _data_ptr->ad_type;
	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "ad-data ");
	_oss_prt_oct(_g, _data_ptr->ad_data.value, _data_ptr->ad_data.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_AuthorizationData(OssGlobal * _g, _AuthorizationData ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_AuthorizationData * _tempa = *_data_ptr;
	_AuthorizationData * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p__seq1(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_PA_DATA(OssGlobal * _g, _PA_DATA * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "padata-type ");
	{
	    LONG_LONG value = _data_ptr->padata_type;
	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "padata-value ");
	_oss_prt_oct(_g, _data_ptr->padata_value.value, _data_ptr->padata_value.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_EncryptedData(OssGlobal * _g, _EncryptedData * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "etype ");
	{
	    LONG_LONG value = _data_ptr->etype;
	    ossPrint(_g, LLONG_FMT, value);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "kvno ");
	    {
		ULONG_LONG value = _data_ptr->kvno;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "cipher ");
	_oss_prt_oct(_g, _data_ptr->cipher.value, _data_ptr->cipher.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_EncryptionKey(OssGlobal * _g, _EncryptionKey * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "keytype ");
	{
	    LONG_LONG value = _data_ptr->keytype;
	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "keyvalue ");
	_oss_prt_oct(_g, _data_ptr->keyvalue.value, _data_ptr->keyvalue.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Checksum(OssGlobal * _g, _Checksum * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "cksumtype ");
	{
	    LONG_LONG value = _data_ptr->cksumtype;
	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "checksum ");
	_oss_prt_oct(_g, _data_ptr->checksum.value, _data_ptr->checksum.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__seqof2(OssGlobal * _g, _seqof2 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof2 * _tempa = *_data_ptr;
	_seqof2 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    {
		LONG_LONG value = _tempa->value;
		ossPrint(_g, LLONG_FMT, value);
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__seqof3(OssGlobal * _g, _seqof3 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof3 * _tempa = *_data_ptr;
	_seqof3 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_Ticket(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__seqof4(OssGlobal * _g, _seqof4 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof4 * _tempa = *_data_ptr;
	_seqof4 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_PA_DATA(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_KDC_REQ(OssGlobal * _g, _KDC_REQ * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "pvno ");
	{
	    ULONG_LONG value = _data_ptr->pvno;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "msg-type ");
	{
	    ULONG_LONG value = _data_ptr->msg_type;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "padata ");
	    _p__seqof4(_g, &_data_ptr->padata);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "req-body ");
	_p_KDC_REQ_BODY(_g, &_data_ptr->req_body);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__seqof5(OssGlobal * _g, _seqof4 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof4 * _tempa = *_data_ptr;
	_seqof4 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_PA_DATA(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_KDC_REP(OssGlobal * _g, _KDC_REP * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "pvno ");
	{
	    ULONG_LONG value = _data_ptr->pvno;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "msg-type ");
	{
	    ULONG_LONG value = _data_ptr->msg_type;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "padata ");
	    _p__seqof5(_g, &_data_ptr->padata);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "crealm ");
	_oss_prt_char(_g, (char *)_data_ptr->crealm.value, _data_ptr->crealm.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "cname ");
	_p_PrincipalName(_g, &_data_ptr->cname);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "ticket ");
	_p_Ticket(_g, &_data_ptr->ticket);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "enc-part ");
	_p_EncryptedData(_g, &_data_ptr->enc_part);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__seqof6(OssGlobal * _g, _seqof4 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof4 * _tempa = *_data_ptr;
	_seqof4 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_PA_DATA(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_EncKDCRepPart(OssGlobal * _g, _EncKDCRepPart * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "key ");
	_p_EncryptionKey(_g, &_data_ptr->key);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "last-req ");
	_p_LastReq(_g, &_data_ptr->last_req);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "nonce ");
	{
	    ULONG_LONG value = _data_ptr->nonce;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	if (_data_ptr->key_expiration) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "key-expiration ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->key_expiration == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->key_expiration);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "flags ");
	_oss_prt_bit(_g, _data_ptr->flags.value, _data_ptr->flags.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "authtime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->authtime == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->authtime);
	if (_data_ptr->starttime) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "starttime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->starttime == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->starttime);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "endtime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->endtime == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->endtime);
	if (_data_ptr->renew_till) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "renew-till ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->renew_till == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->renew_till);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "srealm ");
	_oss_prt_char(_g, (char *)_data_ptr->srealm.value, _data_ptr->srealm.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "sname ");
	_p_PrincipalName(_g, &_data_ptr->sname);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "caddr ");
	    _p_HostAddresses(_g, &_data_ptr->caddr);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "encrypted-pa-data ");
	    _p__seqof6(_g, &_data_ptr->encrypted_pa_data);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__seq2(OssGlobal * _g, _seq2 * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "lr-type ");
	{
	    LONG_LONG value = _data_ptr->lr_type;
	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "lr-value ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->lr_value == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->lr_value);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_LastReq(OssGlobal * _g, _LastReq ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_LastReq * _tempa = *_data_ptr;
	_LastReq * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p__seq2(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_ExternalPrincipalIdentifier(OssGlobal * _g, _ExternalPrincipalIdentifier * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "subjectName ");
	    _oss_prt_oct(_g, _data_ptr->subjectName.value, _data_ptr->subjectName.length);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "issuerAndSerialNumber ");
	    _oss_prt_oct(_g, _data_ptr->issuerAndSerialNumber.value, _data_ptr->issuerAndSerialNumber.length);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "subjectKeyIdentifier ");
	    _oss_prt_oct(_g, _data_ptr->subjectKeyIdentifier.value, _data_ptr->subjectKeyIdentifier.length);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_AlgorithmIdentifier(OssGlobal * _g, _AlgorithmIdentifier * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "algorithm ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->algorithm.length;
	    _e.value = _data_ptr->algorithm.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "parameters ");
	    _oss_prt_oct(_g, _data_ptr->parameters.value, _data_ptr->parameters.length);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_SubjectPublicKeyInfo(OssGlobal * _g, _SubjectPublicKeyInfo * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "algorithm ");
	_p_AlgorithmIdentifier(_g, &_data_ptr->algorithm);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "subjectPublicKey ");
	_oss_prt_bit(_g, _data_ptr->subjectPublicKey.value, _data_ptr->subjectPublicKey.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Name(OssGlobal * _g, _Name * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "rdnSequence : ");
	_p_RDNSequence(_g, &_data_ptr->u.rdnSequence);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

}

static void _p_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_RDNSequence * _tempa = *_data_ptr;
	_RDNSequence * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_tempa->value) {
		_RelativeDistinguishedName * _temp1a = _tempa->value;
		_RelativeDistinguishedName * _temp1b;
		while (_temp1a) {
		    _temp1b = _temp1a->next;
		    {
			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			_oss_indent(_g, 0);
			ossPrint(_g, "type ");
			{
			    OssBuf _val;
			    OssEncodedOID _e;
			    _val.length = 0;
			    _val.value = NULL;
			    _e.length = (unsigned short)_temp1a->value.type.length;
			    _e.value = _temp1a->value.type.value;
			    ossEncodedOidToAsnVal(_g, &_e, &_val);
			    if (_val.length) {
				ossPrint(_g, "%.*s", (int)_val.length, _val.value);
				_oss_dec_free(_g, _val.value);
			    } else
				_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
			}
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "value ");
			_oss_prt_oct(_g, _temp1a->value.value.value, _temp1a->value.value.length);
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		    _temp1a = _temp1b;
		    if (_temp1a)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_Time(OssGlobal * _g, _Time * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "utcTime : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.utcTime == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->u.utcTime);
	break;
    case 2:
	ossPrint(_g, "generalTime : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.generalTime == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->u.generalTime);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

}

static void _p_Extension(OssGlobal * _g, _Extension * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "extnID ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->extnID.length;
	    _e.value = _data_ptr->extnID.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "critical ");
	    ossPrint(_g, _data_ptr->critical ? "TRUE" : "FALSE");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "extnValue ");
	_oss_prt_oct(_g, _data_ptr->extnValue.value, _data_ptr->extnValue.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Extensions(OssGlobal * _g, _Extensions ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_Extensions * _tempa = *_data_ptr;
	_Extensions * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_Extension(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_PDSParameter(OssGlobal * _g, _PDSParameter * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "printable-string ");
	    _oss_prt_char(_g, (char *)_data_ptr->printable_string.value, _data_ptr->printable_string.length);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "teletex-string ");
	    _oss_prt_char(_g, (char *)_data_ptr->teletex_string.value, _data_ptr->teletex_string.length);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static int _pTicket(OssGlobal * _g, void * _data)
{
    _Ticket	*_data_ptr;
    _data_ptr = (_Ticket *)_data;
    _p_Ticket(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pEncTicketPart(OssGlobal * _g, void * _data)
{
    _EncTicketPart	*_data_ptr;
    _data_ptr = (_EncTicketPart *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "flags ");
	_oss_prt_bit(_g, _data_ptr->flags.value, _data_ptr->flags.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "key ");
	_p_EncryptionKey(_g, &_data_ptr->key);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "crealm ");
	_oss_prt_char(_g, (char *)_data_ptr->crealm.value, _data_ptr->crealm.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "cname ");
	_p_PrincipalName(_g, &_data_ptr->cname);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "transited ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "tr-type ");
	    {
		LONG_LONG value = _data_ptr->transited.tr_type;
		ossPrint(_g, LLONG_FMT, value);
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "contents ");
	    _oss_prt_oct(_g, _data_ptr->transited.contents.value, _data_ptr->transited.contents.length);
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "authtime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->authtime == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->authtime);
	if (_data_ptr->starttime) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "starttime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->starttime == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->starttime);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "endtime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->endtime == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->endtime);
	if (_data_ptr->renew_till) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "renew-till ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->renew_till == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->renew_till);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "caddr ");
	    _p_HostAddresses(_g, &_data_ptr->caddr);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "authorization-data ");
	    _p_AuthorizationData(_g, &_data_ptr->authorization_data);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pAS_REQ(OssGlobal * _g, void * _data)
{
    _KDC_REQ	*_data_ptr;
    _data_ptr = (_KDC_REQ *)_data;
    _p_KDC_REQ(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pTGS_REQ(OssGlobal * _g, void * _data)
{
    _KDC_REQ	*_data_ptr;
    _data_ptr = (_KDC_REQ *)_data;
    _p_KDC_REQ(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pKDC_REQ_BODY(OssGlobal * _g, void * _data)
{
    _KDC_REQ_BODY	*_data_ptr;
    _data_ptr = (_KDC_REQ_BODY *)_data;
    _p_KDC_REQ_BODY(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pAS_REP(OssGlobal * _g, void * _data)
{
    _KDC_REP	*_data_ptr;
    _data_ptr = (_KDC_REP *)_data;
    _p_KDC_REP(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pTGS_REP(OssGlobal * _g, void * _data)
{
    _KDC_REP	*_data_ptr;
    _data_ptr = (_KDC_REP *)_data;
    _p_KDC_REP(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pEncASRepPart(OssGlobal * _g, void * _data)
{
    _EncKDCRepPart	*_data_ptr;
    _data_ptr = (_EncKDCRepPart *)_data;
    _p_EncKDCRepPart(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pEncTGSRepPart(OssGlobal * _g, void * _data)
{
    _EncKDCRepPart	*_data_ptr;
    _data_ptr = (_EncKDCRepPart *)_data;
    _p_EncKDCRepPart(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pAP_REQ(OssGlobal * _g, void * _data)
{
    _AP_REQ	*_data_ptr;
    _data_ptr = (_AP_REQ *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "pvno ");
	{
	    ULONG_LONG value = _data_ptr->pvno;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "msg-type ");
	{
	    ULONG_LONG value = _data_ptr->msg_type;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "ap-options ");
	_oss_prt_bit(_g, _data_ptr->ap_options.value, _data_ptr->ap_options.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "ticket ");
	_p_Ticket(_g, &_data_ptr->ticket);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "authenticator ");
	_p_EncryptedData(_g, &_data_ptr->authenticator);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pAuthenticator(OssGlobal * _g, void * _data)
{
    _Authenticator	*_data_ptr;
    _data_ptr = (_Authenticator *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "authenticator-vno ");
	{
	    ULONG_LONG value = _data_ptr->authenticator_vno;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "crealm ");
	_oss_prt_char(_g, (char *)_data_ptr->crealm.value, _data_ptr->crealm.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "cname ");
	_p_PrincipalName(_g, &_data_ptr->cname);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "cksum ");
	    _p_Checksum(_g, &_data_ptr->cksum);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "cusec ");
	{
	    ULONG_LONG value = _data_ptr->cusec;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "ctime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->ctime == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->ctime);
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "subkey ");
	    _p_EncryptionKey(_g, &_data_ptr->subkey);
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "seq-number ");
	    {
		ULONG_LONG value = _data_ptr->seq_number;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "authorization-data ");
	    _p_AuthorizationData(_g, &_data_ptr->authorization_data);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pAP_REP(OssGlobal * _g, void * _data)
{
    _AP_REP	*_data_ptr;
    _data_ptr = (_AP_REP *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "pvno ");
	{
	    ULONG_LONG value = _data_ptr->pvno;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "msg-type ");
	{
	    ULONG_LONG value = _data_ptr->msg_type;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "enc-part ");
	_p_EncryptedData(_g, &_data_ptr->enc_part);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pEncAPRepPart(OssGlobal * _g, void * _data)
{
    _EncAPRepPart	*_data_ptr;
    _data_ptr = (_EncAPRepPart *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "ctime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->ctime == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->ctime);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "cusec ");
	{
	    ULONG_LONG value = _data_ptr->cusec;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "subkey ");
	    _p_EncryptionKey(_g, &_data_ptr->subkey);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "seq-number ");
	    {
		ULONG_LONG value = _data_ptr->seq_number;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pKRB_SAFE(OssGlobal * _g, void * _data)
{
    _KRB_SAFE	*_data_ptr;
    _data_ptr = (_KRB_SAFE *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "pvno ");
	{
	    ULONG_LONG value = _data_ptr->pvno;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "msg-type ");
	{
	    ULONG_LONG value = _data_ptr->msg_type;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "safe-body ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "user-data ");
	    _oss_prt_oct(_g, _data_ptr->safe_body.user_data.value, _data_ptr->safe_body.user_data.length);
	    if (_data_ptr->safe_body.timestamp) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "timestamp ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_data_ptr->safe_body.timestamp == NULL)
#if OSS_TOED_API_LEVEL >= 41
		    _oss_prt_null_ptr(_g);
#else
		    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
		else
#endif
		    _oss_prt_nchar(_g, (char *)_data_ptr->safe_body.timestamp);
	    }
	    if (_data_ptr->safe_body.bit_mask & 0x80000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "usec ");
		{
		    ULONG_LONG value = _data_ptr->safe_body.usec;
		    ossPrint(_g, ULLONG_FMT, value);
		}
	    }
	    if (_data_ptr->safe_body.bit_mask & 0x40000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "seq-number ");
		{
		    ULONG_LONG value = _data_ptr->safe_body.seq_number;
		    ossPrint(_g, ULLONG_FMT, value);
		}
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "s-address ");
	    _p_HostAddress(_g, &_data_ptr->safe_body.s_address);
	    if (_data_ptr->safe_body.bit_mask & 0x20000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "r-address ");
		_p_HostAddress(_g, &_data_ptr->safe_body.r_address);
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "cksum ");
	_p_Checksum(_g, &_data_ptr->cksum);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pKRB_PRIV(OssGlobal * _g, void * _data)
{
    _AP_REP	*_data_ptr;
    _data_ptr = (_AP_REP *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "pvno ");
	{
	    ULONG_LONG value = _data_ptr->pvno;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "msg-type ");
	{
	    ULONG_LONG value = _data_ptr->msg_type;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "enc-part ");
	_p_EncryptedData(_g, &_data_ptr->enc_part);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pEncKrbPrivPart(OssGlobal * _g, void * _data)
{
    _KRB_SAFE_BODY	*_data_ptr;
    _data_ptr = (_KRB_SAFE_BODY *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "user-data ");
	_oss_prt_oct(_g, _data_ptr->user_data.value, _data_ptr->user_data.length);
	if (_data_ptr->timestamp) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "timestamp ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->timestamp == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->timestamp);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "usec ");
	    {
		ULONG_LONG value = _data_ptr->usec;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "seq-number ");
	    {
		ULONG_LONG value = _data_ptr->seq_number;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "s-address ");
	_p_HostAddress(_g, &_data_ptr->s_address);
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "r-address ");
	    _p_HostAddress(_g, &_data_ptr->r_address);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pKRB_CRED(OssGlobal * _g, void * _data)
{
    _KRB_CRED	*_data_ptr;
    _data_ptr = (_KRB_CRED *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "pvno ");
	{
	    ULONG_LONG value = _data_ptr->pvno;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "msg-type ");
	{
	    ULONG_LONG value = _data_ptr->msg_type;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "tickets ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->tickets) {
	    _seqof3 * _tempa = _data_ptr->tickets;
	    _seqof3 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_p_Ticket(_g, &_tempa->value);
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "enc-part ");
	_p_EncryptedData(_g, &_data_ptr->enc_part);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pEncKrbCredPart(OssGlobal * _g, void * _data)
{
    _EncKrbCredPart	*_data_ptr;
    _data_ptr = (_EncKrbCredPart *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "ticket-info ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->ticket_info) {
	    _seqof8 * _tempa = _data_ptr->ticket_info;
	    _seqof8 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		{
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "key ");
		    _p_EncryptionKey(_g, &_tempa->value.key);
		    if (_tempa->value.bit_mask & 0x80000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "prealm ");
			_oss_prt_char(_g, (char *)_tempa->value.prealm.value, _tempa->value.prealm.length);
		    }
		    if (_tempa->value.bit_mask & 0x40000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "pname ");
			_p_PrincipalName(_g, &_tempa->value.pname);
		    }
		    if (_tempa->value.bit_mask & 0x20000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "flags ");
			_oss_prt_bit(_g, _tempa->value.flags.value, _tempa->value.flags.length);
		    }
		    if (_tempa->value.authtime) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "authtime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_tempa->value.authtime == NULL)
#if OSS_TOED_API_LEVEL >= 41
			    _oss_prt_null_ptr(_g);
#else
			    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
			else
#endif
			    _oss_prt_nchar(_g, (char *)_tempa->value.authtime);
		    }
		    if (_tempa->value.starttime) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "starttime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_tempa->value.starttime == NULL)
#if OSS_TOED_API_LEVEL >= 41
			    _oss_prt_null_ptr(_g);
#else
			    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
			else
#endif
			    _oss_prt_nchar(_g, (char *)_tempa->value.starttime);
		    }
		    if (_tempa->value.endtime) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "endtime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_tempa->value.endtime == NULL)
#if OSS_TOED_API_LEVEL >= 41
			    _oss_prt_null_ptr(_g);
#else
			    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
			else
#endif
			    _oss_prt_nchar(_g, (char *)_tempa->value.endtime);
		    }
		    if (_tempa->value.renew_till) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "renew-till ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_tempa->value.renew_till == NULL)
#if OSS_TOED_API_LEVEL >= 41
			    _oss_prt_null_ptr(_g);
#else
			    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
			else
#endif
			    _oss_prt_nchar(_g, (char *)_tempa->value.renew_till);
		    }
		    if (_tempa->value.bit_mask & 0x10000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "srealm ");
			_oss_prt_char(_g, (char *)_tempa->value.srealm.value, _tempa->value.srealm.length);
		    }
		    if (_tempa->value.bit_mask & 0x8000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "sname ");
			_p_PrincipalName(_g, &_tempa->value.sname);
		    }
		    if (_tempa->value.bit_mask & 0x4000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "caddr ");
			_p_HostAddresses(_g, &_tempa->value.caddr);
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		}
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "nonce ");
	    {
		ULONG_LONG value = _data_ptr->nonce;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	if (_data_ptr->timestamp) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "timestamp ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->timestamp == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->timestamp);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "usec ");
	    {
		ULONG_LONG value = _data_ptr->usec;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "s-address ");
	    _p_HostAddress(_g, &_data_ptr->s_address);
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "r-address ");
	    _p_HostAddress(_g, &_data_ptr->r_address);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pKRB_ERROR(OssGlobal * _g, void * _data)
{
    _KRB_ERROR	*_data_ptr;
    _data_ptr = (_KRB_ERROR *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "pvno ");
	{
	    ULONG_LONG value = _data_ptr->pvno;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "msg-type ");
	{
	    ULONG_LONG value = _data_ptr->msg_type;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	if (_data_ptr->ctime) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "ctime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->ctime == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->ctime);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "cusec ");
	    {
		ULONG_LONG value = _data_ptr->cusec;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "stime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->stime == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->stime);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "susec ");
	{
	    ULONG_LONG value = _data_ptr->susec;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "error-code ");
	{
	    LONG_LONG value = _data_ptr->error_code;
	    ossPrint(_g, LLONG_FMT, value);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "crealm ");
	    _oss_prt_char(_g, (char *)_data_ptr->crealm.value, _data_ptr->crealm.length);
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "cname ");
	    _p_PrincipalName(_g, &_data_ptr->cname);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "realm ");
	_oss_prt_char(_g, (char *)_data_ptr->realm.value, _data_ptr->realm.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "sname ");
	_p_PrincipalName(_g, &_data_ptr->sname);
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "e-text ");
	    _oss_prt_char(_g, (char *)_data_ptr->e_text.value, _data_ptr->e_text.length);
	}
	if (_data_ptr->bit_mask & 0x8000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "e-data ");
	    _oss_prt_oct(_g, _data_ptr->e_data.value, _data_ptr->e_data.length);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pMETHOD_DATA(OssGlobal * _g, void * _data)
{
    _seqof4	**_data_ptr;
    _data_ptr = (_seqof4 **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof4 * _tempa = *_data_ptr;
	_seqof4 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_PA_DATA(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pTYPED_DATA(OssGlobal * _g, void * _data)
{
    _TYPED_DATA	**_data_ptr;
    _data_ptr = (_TYPED_DATA **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_TYPED_DATA * _tempa = *_data_ptr;
	_TYPED_DATA * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "data-type ");
		{
		    LONG_LONG value = _tempa->value.data_type;
		    ossPrint(_g, LLONG_FMT, value);
		}
		if (_tempa->value.bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "data-value ");
		    _oss_prt_oct(_g, _tempa->value.data_value.value, _tempa->value.data_value.length);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pPA_ENC_TIMESTAMP(OssGlobal * _g, void * _data)
{
    _EncryptedData	*_data_ptr;
    _data_ptr = (_EncryptedData *)_data;
    _p_EncryptedData(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pPA_ENC_TS_ENC(OssGlobal * _g, void * _data)
{
    _PA_ENC_TS_ENC	*_data_ptr;
    _data_ptr = (_PA_ENC_TS_ENC *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "patimestamp ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->patimestamp == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->patimestamp);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "pausec ");
	    {
		ULONG_LONG value = _data_ptr->pausec;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pETYPE_INFO(OssGlobal * _g, void * _data)
{
    _ETYPE_INFO	**_data_ptr;
    _data_ptr = (_ETYPE_INFO **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_ETYPE_INFO * _tempa = *_data_ptr;
	_ETYPE_INFO * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "etype ");
		{
		    LONG_LONG value = _tempa->value.etype;
		    ossPrint(_g, LLONG_FMT, value);
		}
		if (_tempa->value.bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "salt ");
		    _oss_prt_oct(_g, _tempa->value.salt.value, _tempa->value.salt.length);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pETYPE_INFO2(OssGlobal * _g, void * _data)
{
    _ETYPE_INFO2	**_data_ptr;
    _data_ptr = (_ETYPE_INFO2 **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_ETYPE_INFO2 * _tempa = *_data_ptr;
	_ETYPE_INFO2 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "etype ");
		{
		    LONG_LONG value = _tempa->value.etype;
		    ossPrint(_g, LLONG_FMT, value);
		}
		if (_tempa->value.bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "salt ");
		    _oss_prt_char(_g, (char *)_tempa->value.salt.value, _tempa->value.salt.length);
		}
		if (_tempa->value.bit_mask & 0x40000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "s2kparams ");
		    _oss_prt_oct(_g, _tempa->value.s2kparams.value, _tempa->value.s2kparams.length);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pAD_IF_RELEVANT(OssGlobal * _g, void * _data)
{
    _AuthorizationData	**_data_ptr;
    _data_ptr = (_AuthorizationData **)_data;
    _p_AuthorizationData(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pAD_KDCIssued(OssGlobal * _g, void * _data)
{
    _AD_KDCIssued	*_data_ptr;
    _data_ptr = (_AD_KDCIssued *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "ad-checksum ");
	_p_Checksum(_g, &_data_ptr->ad_checksum);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "i-realm ");
	    _oss_prt_char(_g, (char *)_data_ptr->i_realm.value, _data_ptr->i_realm.length);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "i-sname ");
	    _p_PrincipalName(_g, &_data_ptr->i_sname);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "elements ");
	_p_AuthorizationData(_g, &_data_ptr->elements);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pAD_AND_OR(OssGlobal * _g, void * _data)
{
    _AD_AND_OR	*_data_ptr;
    _data_ptr = (_AD_AND_OR *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "condition-count ");
	{
	    LONG_LONG value = _data_ptr->condition_count;
	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "elements ");
	_p_AuthorizationData(_g, &_data_ptr->elements);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pAD_MANDATORY_FOR_KDC(OssGlobal * _g, void * _data)
{
    _AuthorizationData	**_data_ptr;
    _data_ptr = (_AuthorizationData **)_data;
    _p_AuthorizationData(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pChangePasswdData(OssGlobal * _g, void * _data)
{
    _ChangePasswdData	*_data_ptr;
    _data_ptr = (_ChangePasswdData *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "newpasswd ");
	_oss_prt_oct(_g, _data_ptr->newpasswd.value, _data_ptr->newpasswd.length);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "targname ");
	    _p_PrincipalName(_g, &_data_ptr->targname);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "targrealm ");
	    _oss_prt_char(_g, (char *)_data_ptr->targrealm.value, _data_ptr->targrealm.length);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pPA_PK_AS_REQ(OssGlobal * _g, void * _data)
{
    _PA_PK_AS_REQ	*_data_ptr;
    _data_ptr = (_PA_PK_AS_REQ *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "signedAuthPack ");
	_oss_prt_oct(_g, _data_ptr->signedAuthPack.value, _data_ptr->signedAuthPack.length);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "trustedCertifiers ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->trustedCertifiers) {
		_seqof9 * _tempa = _data_ptr->trustedCertifiers;
		_seqof9 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _p_ExternalPrincipalIdentifier(_g, &_tempa->value);
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "kdcPkId ");
	    _oss_prt_oct(_g, _data_ptr->kdcPkId.value, _data_ptr->kdcPkId.length);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pAuthPack(OssGlobal * _g, void * _data)
{
    _AuthPack	*_data_ptr;
    _data_ptr = (_AuthPack *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "pkAuthenticator ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "cusec ");
	    {
		ULONG_LONG value = _data_ptr->pkAuthenticator.cusec;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "ctime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->pkAuthenticator.ctime == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->pkAuthenticator.ctime);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "nonce ");
	    {
		ULONG_LONG value = _data_ptr->pkAuthenticator.nonce;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	    if (_data_ptr->pkAuthenticator.bit_mask & 0x80000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "paChecksum ");
		_oss_prt_oct(_g, _data_ptr->pkAuthenticator.paChecksum.value, _data_ptr->pkAuthenticator.paChecksum.length);
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "clientPublicValue ");
	    _p_SubjectPublicKeyInfo(_g, &_data_ptr->clientPublicValue);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "supportedCMSTypes ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->supportedCMSTypes) {
		_seqof10 * _tempa = _data_ptr->supportedCMSTypes;
		_seqof10 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _p_AlgorithmIdentifier(_g, &_tempa->value);
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "clientDHNonce ");
	    _oss_prt_oct(_g, _data_ptr->clientDHNonce.value, _data_ptr->clientDHNonce.length);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pTD_TRUSTED_CERTIFIERS(OssGlobal * _g, void * _data)
{
    _seqof9	**_data_ptr;
    _data_ptr = (_seqof9 **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof9 * _tempa = *_data_ptr;
	_seqof9 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_ExternalPrincipalIdentifier(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pTD_INVALID_CERTIFICATES(OssGlobal * _g, void * _data)
{
    _seqof9	**_data_ptr;
    _data_ptr = (_seqof9 **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof9 * _tempa = *_data_ptr;
	_seqof9 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_ExternalPrincipalIdentifier(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pKRB5PrincipalName(OssGlobal * _g, void * _data)
{
    _KRB5PrincipalName	*_data_ptr;
    _data_ptr = (_KRB5PrincipalName *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "realm ");
	_oss_prt_char(_g, (char *)_data_ptr->realm.value, _data_ptr->realm.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "principalName ");
	_p_PrincipalName(_g, &_data_ptr->principalName);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pAD_INITIAL_VERIFIED_CAS(OssGlobal * _g, void * _data)
{
    _seqof9	**_data_ptr;
    _data_ptr = (_seqof9 **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof9 * _tempa = *_data_ptr;
	_seqof9 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_ExternalPrincipalIdentifier(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pPA_PK_AS_REP(OssGlobal * _g, void * _data)
{
    _PA_PK_AS_REP	*_data_ptr;
    _data_ptr = (_PA_PK_AS_REP *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "dhInfo : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.dhInfo == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "dhSignedData ");
		_oss_prt_oct(_g, _data_ptr->u.dhInfo->dhSignedData.value, _data_ptr->u.dhInfo->dhSignedData.length);
		if (_data_ptr->u.dhInfo->bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "serverDHNonce ");
		    _oss_prt_oct(_g, _data_ptr->u.dhInfo->serverDHNonce.value, _data_ptr->u.dhInfo->serverDHNonce.length);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 2:
	ossPrint(_g, "encKeyPack : ");
	_oss_prt_oct(_g, _data_ptr->u.encKeyPack.value, _data_ptr->u.encKeyPack.length);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pKDCDHKeyInfo(OssGlobal * _g, void * _data)
{
    _KDCDHKeyInfo	*_data_ptr;
    _data_ptr = (_KDCDHKeyInfo *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "subjectPublicKey ");
	_oss_prt_bit(_g, _data_ptr->subjectPublicKey.value, _data_ptr->subjectPublicKey.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "nonce ");
	{
	    ULONG_LONG value = _data_ptr->nonce;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	if (_data_ptr->dhKeyExpiration) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "dhKeyExpiration ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->dhKeyExpiration == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->dhKeyExpiration);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pReplyKeyPack(OssGlobal * _g, void * _data)
{
    _ReplyKeyPack	*_data_ptr;
    _data_ptr = (_ReplyKeyPack *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "replyKey ");
	_p_EncryptionKey(_g, &_data_ptr->replyKey);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "asChecksum ");
	_p_Checksum(_g, &_data_ptr->asChecksum);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pTD_DH_PARAMETERS(OssGlobal * _g, void * _data)
{
    _seqof10	**_data_ptr;
    _data_ptr = (_seqof10 **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof10 * _tempa = *_data_ptr;
	_seqof10 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_AlgorithmIdentifier(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pAttribute(OssGlobal * _g, void * _data)
{
    _Attribute	*_data_ptr;
    _data_ptr = (_Attribute *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "type ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->type.length;
	    _e.value = _data_ptr->type.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "values ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->values) {
	    _seqof1 * _tempa = _data_ptr->values;
	    _seqof1 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_indent(_g, 0);
		_oss_prt_oct(_g, _tempa->value.value, _tempa->value.length);
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pX520name(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "teletexString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.teletexString.value, _data_ptr->u.teletexString.length);
	break;
    case 2:
	ossPrint(_g, "printableString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printableString.value, _data_ptr->u.printableString.length);
	break;
    case 3:
	ossPrint(_g, "universalString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.universalString.value, _data_ptr->u.universalString.length, 4);
	break;
    case 4:
	ossPrint(_g, "utf8String : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.utf8String.value, _data_ptr->u.utf8String.length, 1);
	break;
    case 5:
	ossPrint(_g, "bmpString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.bmpString.value, _data_ptr->u.bmpString.length, 2);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pX520CommonName(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "teletexString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.teletexString.value, _data_ptr->u.teletexString.length);
	break;
    case 2:
	ossPrint(_g, "printableString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printableString.value, _data_ptr->u.printableString.length);
	break;
    case 3:
	ossPrint(_g, "universalString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.universalString.value, _data_ptr->u.universalString.length, 4);
	break;
    case 4:
	ossPrint(_g, "utf8String : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.utf8String.value, _data_ptr->u.utf8String.length, 1);
	break;
    case 5:
	ossPrint(_g, "bmpString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.bmpString.value, _data_ptr->u.bmpString.length, 2);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pX520LocalityName(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "teletexString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.teletexString.value, _data_ptr->u.teletexString.length);
	break;
    case 2:
	ossPrint(_g, "printableString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printableString.value, _data_ptr->u.printableString.length);
	break;
    case 3:
	ossPrint(_g, "universalString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.universalString.value, _data_ptr->u.universalString.length, 4);
	break;
    case 4:
	ossPrint(_g, "utf8String : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.utf8String.value, _data_ptr->u.utf8String.length, 1);
	break;
    case 5:
	ossPrint(_g, "bmpString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.bmpString.value, _data_ptr->u.bmpString.length, 2);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pX520StateOrProvinceName(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "teletexString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.teletexString.value, _data_ptr->u.teletexString.length);
	break;
    case 2:
	ossPrint(_g, "printableString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printableString.value, _data_ptr->u.printableString.length);
	break;
    case 3:
	ossPrint(_g, "universalString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.universalString.value, _data_ptr->u.universalString.length, 4);
	break;
    case 4:
	ossPrint(_g, "utf8String : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.utf8String.value, _data_ptr->u.utf8String.length, 1);
	break;
    case 5:
	ossPrint(_g, "bmpString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.bmpString.value, _data_ptr->u.bmpString.length, 2);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pX520OrganizationName(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "teletexString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.teletexString.value, _data_ptr->u.teletexString.length);
	break;
    case 2:
	ossPrint(_g, "printableString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printableString.value, _data_ptr->u.printableString.length);
	break;
    case 3:
	ossPrint(_g, "universalString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.universalString.value, _data_ptr->u.universalString.length, 4);
	break;
    case 4:
	ossPrint(_g, "utf8String : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.utf8String.value, _data_ptr->u.utf8String.length, 1);
	break;
    case 5:
	ossPrint(_g, "bmpString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.bmpString.value, _data_ptr->u.bmpString.length, 2);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pX520OrganizationalUnitName(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "teletexString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.teletexString.value, _data_ptr->u.teletexString.length);
	break;
    case 2:
	ossPrint(_g, "printableString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printableString.value, _data_ptr->u.printableString.length);
	break;
    case 3:
	ossPrint(_g, "universalString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.universalString.value, _data_ptr->u.universalString.length, 4);
	break;
    case 4:
	ossPrint(_g, "utf8String : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.utf8String.value, _data_ptr->u.utf8String.length, 1);
	break;
    case 5:
	ossPrint(_g, "bmpString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.bmpString.value, _data_ptr->u.bmpString.length, 2);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pX520Title(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "teletexString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.teletexString.value, _data_ptr->u.teletexString.length);
	break;
    case 2:
	ossPrint(_g, "printableString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printableString.value, _data_ptr->u.printableString.length);
	break;
    case 3:
	ossPrint(_g, "universalString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.universalString.value, _data_ptr->u.universalString.length, 4);
	break;
    case 4:
	ossPrint(_g, "utf8String : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.utf8String.value, _data_ptr->u.utf8String.length, 1);
	break;
    case 5:
	ossPrint(_g, "bmpString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.bmpString.value, _data_ptr->u.bmpString.length, 2);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pX520dnQualifier(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pX520countryName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pX520SerialNumber(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pX520Pseudonym(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "teletexString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.teletexString.value, _data_ptr->u.teletexString.length);
	break;
    case 2:
	ossPrint(_g, "printableString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printableString.value, _data_ptr->u.printableString.length);
	break;
    case 3:
	ossPrint(_g, "universalString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.universalString.value, _data_ptr->u.universalString.length, 4);
	break;
    case 4:
	ossPrint(_g, "utf8String : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.utf8String.value, _data_ptr->u.utf8String.length, 1);
	break;
    case 5:
	ossPrint(_g, "bmpString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.bmpString.value, _data_ptr->u.bmpString.length, 2);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pDomainComponent(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pEmailAddress(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pDistinguishedName(OssGlobal * _g, void * _data)
{
    _RDNSequence	**_data_ptr;
    _data_ptr = (_RDNSequence **)_data;
    _p_RDNSequence(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pDirectoryString(OssGlobal * _g, void * _data)
{
    _X520name	*_data_ptr;
    _data_ptr = (_X520name *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "teletexString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.teletexString.value, _data_ptr->u.teletexString.length);
	break;
    case 2:
	ossPrint(_g, "printableString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printableString.value, _data_ptr->u.printableString.length);
	break;
    case 3:
	ossPrint(_g, "universalString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.universalString.value, _data_ptr->u.universalString.length, 4);
	break;
    case 4:
	ossPrint(_g, "utf8String : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.utf8String.value, _data_ptr->u.utf8String.length, 1);
	break;
    case 5:
	ossPrint(_g, "bmpString : ");
		_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.bmpString.value, _data_ptr->u.bmpString.length, 2);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pCertificate(OssGlobal * _g, void * _data)
{
    _Certificate	*_data_ptr;
    _data_ptr = (_Certificate *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "tbsCertificate ");
	{
	    short _comma = 0;

	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->tbsCertificate.bit_mask & 0x80000000) {
		_oss_indent(_g, 0);
		ossPrint(_g, "version ");
		{
		    LONG_LONG value = _data_ptr->tbsCertificate.version;
		    ossPrint(_g, LLONG_FMT, value);
		}
		_comma = 1;
	    }
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "serialNumber ");
	    {
		LONG_LONG value = _data_ptr->tbsCertificate.serialNumber;
		ossPrint(_g, LLONG_FMT, value);
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "signature ");
	    _p_AlgorithmIdentifier(_g, &_data_ptr->tbsCertificate.signature);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "issuer ");
	    _p_Name(_g, &_data_ptr->tbsCertificate.issuer);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "validity ");
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "notBefore ");
		_p_Time(_g, &_data_ptr->tbsCertificate.validity.notBefore);
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "notAfter ");
		_p_Time(_g, &_data_ptr->tbsCertificate.validity.notAfter);
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "subject ");
	    _p_Name(_g, &_data_ptr->tbsCertificate.subject);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "subjectPublicKeyInfo ");
	    _p_SubjectPublicKeyInfo(_g, &_data_ptr->tbsCertificate.subjectPublicKeyInfo);
	    if (_data_ptr->tbsCertificate.bit_mask & 0x40000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "issuerUniqueID ");
		_oss_prt_bit(_g, _data_ptr->tbsCertificate.issuerUniqueID.value, _data_ptr->tbsCertificate.issuerUniqueID.length);
	    }
	    if (_data_ptr->tbsCertificate.bit_mask & 0x20000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "subjectUniqueID ");
		_oss_prt_bit(_g, _data_ptr->tbsCertificate.subjectUniqueID.value, _data_ptr->tbsCertificate.subjectUniqueID.length);
	    }
	    if (_data_ptr->tbsCertificate.bit_mask & 0x10000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "extensions ");
		_p_Extensions(_g, &_data_ptr->tbsCertificate.extensions);
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "signatureAlgorithm ");
	_p_AlgorithmIdentifier(_g, &_data_ptr->signatureAlgorithm);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "signature ");
	_oss_prt_bit(_g, _data_ptr->signature.value, _data_ptr->signature.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCertificateList(OssGlobal * _g, void * _data)
{
    _CertificateList	*_data_ptr;
    _data_ptr = (_CertificateList *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "tbsCertList ");
	{
	    short _comma = 0;

	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->tbsCertList.bit_mask & 0x80000000) {
		_oss_indent(_g, 0);
		ossPrint(_g, "version ");
		{
		    LONG_LONG value = _data_ptr->tbsCertList.version;
		    ossPrint(_g, LLONG_FMT, value);
		}
		_comma = 1;
	    }
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "signature ");
	    _p_AlgorithmIdentifier(_g, &_data_ptr->tbsCertList.signature);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "issuer ");
	    _p_Name(_g, &_data_ptr->tbsCertList.issuer);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "thisUpdate ");
	    _p_Time(_g, &_data_ptr->tbsCertList.thisUpdate);
	    if (_data_ptr->tbsCertList.bit_mask & 0x40000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "nextUpdate ");
		_p_Time(_g, &_data_ptr->tbsCertList.nextUpdate);
	    }
	    if (_data_ptr->tbsCertList.bit_mask & 0x20000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "revokedCertificates ");
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->tbsCertList.revokedCertificates) {
		    _seqof11 * _tempa = _data_ptr->tbsCertList.revokedCertificates;
		    _seqof11 * _tempb;
		    while (_tempa) {
			_tempb = _tempa->next;
			{
			    _oss_indent(_g, 1);
			    ossPrint(_g, "{");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "userCertificate ");
			    {
				LONG_LONG value = _tempa->value.userCertificate;
				ossPrint(_g, LLONG_FMT, value);
			    }
			    ossPrint(_g, ",");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "revocationDate ");
			    _p_Time(_g, &_tempa->value.revocationDate);
			    if (_tempa->value.bit_mask & 0x80000000) {
				ossPrint(_g, ",");
				_oss_indent(_g, 0);
				ossPrint(_g, "crlEntryExtensions ");
				_p_Extensions(_g, &_tempa->value.crlEntryExtensions);
			    }
			    _oss_indent(_g, -1);
			    ossPrint(_g, "}");
			}
			_tempa = _tempb;
			if (_tempa)
			    ossPrint(_g, ",");
		    }
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    if (_data_ptr->tbsCertList.bit_mask & 0x10000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "crlExtensions ");
		_p_Extensions(_g, &_data_ptr->tbsCertList.crlExtensions);
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "signatureAlgorithm ");
	_p_AlgorithmIdentifier(_g, &_data_ptr->signatureAlgorithm);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "signature ");
	_oss_prt_bit(_g, _data_ptr->signature.value, _data_ptr->signature.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pORAddress(OssGlobal * _g, void * _data)
{
    _ORAddress	*_data_ptr;
    _data_ptr = (_ORAddress *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "built-in-standard-attributes ");
	{
	    short _comma = 0;

	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->built_in_standard_attributes.bit_mask & 0x80000000) {
		_oss_indent(_g, 0);
		ossPrint(_g, "country-name ");
		switch (_data_ptr->built_in_standard_attributes.country_name.choice) {
		case 1:
		    ossPrint(_g, "x121-dcc-code : ");
		    _oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.country_name.u.x121_dcc_code.value, _data_ptr->built_in_standard_attributes.country_name.u.x121_dcc_code.length);
		    break;
		case 2:
		    ossPrint(_g, "iso-3166-alpha2-code : ");
		    _oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.country_name.u.iso_3166_alpha2_code.value, _data_ptr->built_in_standard_attributes.country_name.u.iso_3166_alpha2_code.length);
		    break;
		default:
#if OSS_TOED_API_LEVEL >= 41
		    _oss_prt_bad_alt(_g, _data_ptr->built_in_standard_attributes.country_name.choice);
#else
		    ossPrint(_g, "<unknown choice>");
#endif
		}
		_comma = 1;
	    }
	    if (_data_ptr->built_in_standard_attributes.bit_mask & 0x40000000) {
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "administration-domain-name ");
		switch (_data_ptr->built_in_standard_attributes.administration_domain_name.choice) {
		case 1:
		    ossPrint(_g, "numeric : ");
		    _oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.administration_domain_name.u.numeric.value, _data_ptr->built_in_standard_attributes.administration_domain_name.u.numeric.length);
		    break;
		case 2:
		    ossPrint(_g, "printable : ");
		    _oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.administration_domain_name.u.printable.value, _data_ptr->built_in_standard_attributes.administration_domain_name.u.printable.length);
		    break;
		default:
#if OSS_TOED_API_LEVEL >= 41
		    _oss_prt_bad_alt(_g, _data_ptr->built_in_standard_attributes.administration_domain_name.choice);
#else
		    ossPrint(_g, "<unknown choice>");
#endif
		}
		_comma = 1;
	    }
	    if (_data_ptr->built_in_standard_attributes.bit_mask & 0x20000000) {
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "network-address ");
		_oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.network_address.value, _data_ptr->built_in_standard_attributes.network_address.length);
		_comma = 1;
	    }
	    if (_data_ptr->built_in_standard_attributes.bit_mask & 0x10000000) {
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "terminal-identifier ");
		_oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.terminal_identifier.value, _data_ptr->built_in_standard_attributes.terminal_identifier.length);
		_comma = 1;
	    }
	    if (_data_ptr->built_in_standard_attributes.bit_mask & 0x8000000) {
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "private-domain-name ");
		switch (_data_ptr->built_in_standard_attributes.private_domain_name.choice) {
		case 1:
		    ossPrint(_g, "numeric : ");
		    _oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.private_domain_name.u.numeric.value, _data_ptr->built_in_standard_attributes.private_domain_name.u.numeric.length);
		    break;
		case 2:
		    ossPrint(_g, "printable : ");
		    _oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.private_domain_name.u.printable.value, _data_ptr->built_in_standard_attributes.private_domain_name.u.printable.length);
		    break;
		default:
#if OSS_TOED_API_LEVEL >= 41
		    _oss_prt_bad_alt(_g, _data_ptr->built_in_standard_attributes.private_domain_name.choice);
#else
		    ossPrint(_g, "<unknown choice>");
#endif
		}
		_comma = 1;
	    }
	    if (_data_ptr->built_in_standard_attributes.bit_mask & 0x4000000) {
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "organization-name ");
		_oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.organization_name.value, _data_ptr->built_in_standard_attributes.organization_name.length);
		_comma = 1;
	    }
	    if (_data_ptr->built_in_standard_attributes.bit_mask & 0x2000000) {
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "numeric-user-identifier ");
		_oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.numeric_user_identifier.value, _data_ptr->built_in_standard_attributes.numeric_user_identifier.length);
		_comma = 1;
	    }
	    if (_data_ptr->built_in_standard_attributes.bit_mask & 0x1000000) {
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "personal-name ");
		{
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "surname ");
		    _oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.personal_name.surname.value, _data_ptr->built_in_standard_attributes.personal_name.surname.length);
		    if (_data_ptr->built_in_standard_attributes.personal_name.bit_mask & 0x80000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "given-name ");
			_oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.personal_name.given_name.value, _data_ptr->built_in_standard_attributes.personal_name.given_name.length);
		    }
		    if (_data_ptr->built_in_standard_attributes.personal_name.bit_mask & 0x40000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "initials ");
			_oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.personal_name.initials.value, _data_ptr->built_in_standard_attributes.personal_name.initials.length);
		    }
		    if (_data_ptr->built_in_standard_attributes.personal_name.bit_mask & 0x20000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "generation-qualifier ");
			_oss_prt_char(_g, (char *)_data_ptr->built_in_standard_attributes.personal_name.generation_qualifier.value, _data_ptr->built_in_standard_attributes.personal_name.generation_qualifier.length);
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		}
		_comma = 1;
	    }
	    if (_data_ptr->built_in_standard_attributes.bit_mask & 0x800000) {
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "organizational-unit-names ");
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->built_in_standard_attributes.organizational_unit_names) {
		    _seqof1 * _tempa = _data_ptr->built_in_standard_attributes.organizational_unit_names;
		    _seqof1 * _tempb;
		    while (_tempa) {
			_tempb = _tempa->next;
			_oss_indent(_g, 0);
			_oss_prt_char(_g, (char *)_tempa->value.value, _tempa->value.length);
			_tempa = _tempb;
			if (_tempa)
			    ossPrint(_g, ",");
		    }
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
		_comma = 1;
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "built-in-domain-defined-attributes ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->built_in_domain_defined_attributes) {
		_BuiltInDomainDefinedAttributes * _tempa = _data_ptr->built_in_domain_defined_attributes;
		_BuiltInDomainDefinedAttributes * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    {
			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			_oss_indent(_g, 0);
			ossPrint(_g, "type ");
			_oss_prt_char(_g, (char *)_tempa->value.type.value, _tempa->value.type.length);
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "value ");
			_oss_prt_char(_g, (char *)_tempa->value.value.value, _tempa->value.value.length);
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "extension-attributes ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->extension_attributes) {
		_ExtensionAttributes * _tempa = _data_ptr->extension_attributes;
		_ExtensionAttributes * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    {
			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			_oss_indent(_g, 0);
			ossPrint(_g, "extension-attribute-type ");
			{
			    ULONG_LONG value = _tempa->value.extension_attribute_type;
			    ossPrint(_g, ULLONG_FMT, value);
			}
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "extension-attribute-value ");
			_oss_prt_oct(_g, _tempa->value.extension_attribute_value.value, _tempa->value.extension_attribute_value.length);
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCommonName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pTeletexCommonName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pTeletexOrganizationName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pTeletexPersonalName(OssGlobal * _g, void * _data)
{
    _PersonalName	*_data_ptr;
    _data_ptr = (_PersonalName *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "surname ");
	_oss_prt_char(_g, (char *)_data_ptr->surname.value, _data_ptr->surname.length);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "given-name ");
	    _oss_prt_char(_g, (char *)_data_ptr->given_name.value, _data_ptr->given_name.length);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "initials ");
	    _oss_prt_char(_g, (char *)_data_ptr->initials.value, _data_ptr->initials.length);
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "generation-qualifier ");
	    _oss_prt_char(_g, (char *)_data_ptr->generation_qualifier.value, _data_ptr->generation_qualifier.length);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _p0TeletexOrganizationalUnitNa(OssGlobal * _g, void * _data)
{
    _seqof1	**_data_ptr;
    _data_ptr = (_seqof1 **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof1 * _tempa = *_data_ptr;
	_seqof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _oss_prt_char(_g, (char *)_tempa->value.value, _tempa->value.length);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pPDSName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pPhysicalDeliveryCountryName(OssGlobal * _g, void * _data)
{
    _CountryName	*_data_ptr;
    _data_ptr = (_CountryName *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "x121-dcc-code : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.x121_dcc_code.value, _data_ptr->u.x121_dcc_code.length);
	break;
    case 2:
	ossPrint(_g, "iso-3166-alpha2-code : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.iso_3166_alpha2_code.value, _data_ptr->u.iso_3166_alpha2_code.length);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pPostalCode(OssGlobal * _g, void * _data)
{
    _PostalCode	*_data_ptr;
    _data_ptr = (_PostalCode *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "numeric-code : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.numeric_code.value, _data_ptr->u.numeric_code.length);
	break;
    case 2:
	ossPrint(_g, "printable-code : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printable_code.value, _data_ptr->u.printable_code.length);
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pPhysicalDeliveryOfficeName(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pPhysicalDeliveryOfficeNumber(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pExtensionORAddressComponents(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pPhysicalDeliveryPersonalName(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _p1PhysicalDeliveryOrganizatio(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _p2ExtensionPhysicalDeliveryAd(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pUnformattedPostalAddress(OssGlobal * _g, void * _data)
{
    _UnformattedPostalAddress	*_data_ptr;
    _data_ptr = (_UnformattedPostalAddress *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "printable-address ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->printable_address) {
		_seqof1 * _tempa = _data_ptr->printable_address;
		_seqof1 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_indent(_g, 0);
		    _oss_prt_char(_g, (char *)_tempa->value.value, _tempa->value.length);
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "teletex-string ");
	    _oss_prt_char(_g, (char *)_data_ptr->teletex_string.value, _data_ptr->teletex_string.length);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pStreetAddress(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pPostOfficeBoxAddress(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pPosteRestanteAddress(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pUniquePostalName(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pLocalPostalAttributes(OssGlobal * _g, void * _data)
{
    _PDSParameter	*_data_ptr;
    _data_ptr = (_PDSParameter *)_data;
    _p_PDSParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pExtendedNetworkAddress(OssGlobal * _g, void * _data)
{
    _ExtendedNetworkAddress	*_data_ptr;
    _data_ptr = (_ExtendedNetworkAddress *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "e163-4-address : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.e163_4_address == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "number ");
		_oss_prt_char(_g, (char *)_data_ptr->u.e163_4_address->number.value, _data_ptr->u.e163_4_address->number.length);
		if (_data_ptr->u.e163_4_address->bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "sub-address ");
		    _oss_prt_char(_g, (char *)_data_ptr->u.e163_4_address->sub_address.value, _data_ptr->u.e163_4_address->sub_address.length);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 2:
	ossPrint(_g, "psap-address : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.psap_address == NULL)
#if OSS_TOED_API_LEVEL >= 41
	    _oss_prt_null_ptr(_g);
#else
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.psap_address->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "pSelector ");
		    _oss_prt_oct(_g, _data_ptr->u.psap_address->pSelector.value, _data_ptr->u.psap_address->pSelector.length);
		    _comma = 1;
		}
		if (_data_ptr->u.psap_address->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "sSelector ");
		    _oss_prt_oct(_g, _data_ptr->u.psap_address->sSelector.value, _data_ptr->u.psap_address->sSelector.length);
		    _comma = 1;
		}
		if (_data_ptr->u.psap_address->bit_mask & 0x20000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "tSelector ");
		    _oss_prt_oct(_g, _data_ptr->u.psap_address->tSelector.value, _data_ptr->u.psap_address->tSelector.length);
		    _comma = 1;
		}
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "nAddresses ");
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.psap_address->nAddresses) {
		    _seqof1 * _tempa = _data_ptr->u.psap_address->nAddresses;
		    _seqof1 * _tempb;
		    while (_tempa) {
			_tempb = _tempa->next;
			_oss_indent(_g, 0);
			_oss_prt_oct(_g, _tempa->value.value, _tempa->value.length);
			_tempa = _tempb;
			if (_tempa)
			    ossPrint(_g, ",");
		    }
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    default:
#if OSS_TOED_API_LEVEL >= 41
	_oss_prt_bad_alt(_g, _data_ptr->choice);
#else
	ossPrint(_g, "<unknown choice>");
#endif
    }

    return PDU_PRINTED;
}

static int _pTerminalType(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p3TeletexDomainDefinedAttribu(OssGlobal * _g, void * _data)
{
    _BuiltInDomainDefinedAttributes	**_data_ptr;
    _data_ptr = (_BuiltInDomainDefinedAttributes **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_BuiltInDomainDefinedAttributes * _tempa = *_data_ptr;
	_BuiltInDomainDefinedAttributes * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "type ");
		_oss_prt_char(_g, (char *)_tempa->value.type.value, _tempa->value.type.length);
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "value ");
		_oss_prt_char(_g, (char *)_tempa->value.value.value, _tempa->value.value.length);
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pAuthPack_OLD(OssGlobal * _g, void * _data)
{
    _AuthPack_OLD	*_data_ptr;
    _data_ptr = (_AuthPack_OLD *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "pkAuthenticator ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "kdc-name ");
	    _p_PrincipalName(_g, &_data_ptr->pkAuthenticator.kdc_name);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "kdc-realm ");
	    _oss_prt_char(_g, (char *)_data_ptr->pkAuthenticator.kdc_realm.value, _data_ptr->pkAuthenticator.kdc_realm.length);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "cusec ");
	    {
		LONG_LONG value = _data_ptr->pkAuthenticator.cusec;
		ossPrint(_g, LLONG_FMT, value);
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "ctime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->pkAuthenticator.ctime == NULL)
#if OSS_TOED_API_LEVEL >= 41
		_oss_prt_null_ptr(_g);
#else
		ossPrint(_g, "<<<<<<NULL>>>>>>");
#endif
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->pkAuthenticator.ctime);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "nonce ");
	    {
		LONG_LONG value = _data_ptr->pkAuthenticator.nonce;
		ossPrint(_g, LLONG_FMT, value);
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pKERB_REPLY_KEY_PACKAGE(OssGlobal * _g, void * _data)
{
    _KERB_REPLY_KEY_PACKAGE	*_data_ptr;
    _data_ptr = (_KERB_REPLY_KEY_PACKAGE *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "replyKey ");
	_p_EncryptionKey(_g, &_data_ptr->replyKey);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "nonce ");
	{
	    LONG_LONG value = _data_ptr->nonce;
	    ossPrint(_g, LLONG_FMT, value);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pPA_FOR_USER_ENC(OssGlobal * _g, void * _data)
{
    _PA_FOR_USER_ENC	*_data_ptr;
    _data_ptr = (_PA_FOR_USER_ENC *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "userName ");
	_p_PrincipalName(_g, &_data_ptr->userName);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "userRealm ");
	_oss_prt_char(_g, (char *)_data_ptr->userRealm.value, _data_ptr->userRealm.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "cksum ");
	_p_Checksum(_g, &_data_ptr->cksum);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "auth-package ");
	_oss_prt_char(_g, (char *)_data_ptr->auth_package.value, _data_ptr->auth_package.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pPA_S4U_X509_USER(OssGlobal * _g, void * _data)
{
    _PA_S4U_X509_USER	*_data_ptr;
    _data_ptr = (_PA_S4U_X509_USER *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "user-id ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "nonce ");
	    {
		ULONG_LONG value = _data_ptr->user_id.nonce;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	    if (_data_ptr->user_id.bit_mask & 0x80000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "cname ");
		_p_PrincipalName(_g, &_data_ptr->user_id.cname);
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "crealm ");
	    _oss_prt_char(_g, (char *)_data_ptr->user_id.crealm.value, _data_ptr->user_id.crealm.length);
	    if (_data_ptr->user_id.bit_mask & 0x40000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "subject-certificate ");
		_oss_prt_oct(_g, _data_ptr->user_id.subject_certificate.value, _data_ptr->user_id.subject_certificate.length);
	    }
	    if (_data_ptr->user_id.bit_mask & 0x20000000) {
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "options ");
		_oss_prt_bit(_g, _data_ptr->user_id.options.value, _data_ptr->user_id.options.length);
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "checksum ");
	_p_Checksum(_g, &_data_ptr->checksum);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pPA_PAC_OPTIONS(OssGlobal * _g, void * _data)
{
    _PA_PAC_OPTIONS	*_data_ptr;
    _data_ptr = (_PA_PAC_OPTIONS *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "--1-- ");
	_oss_prt_bit(_g, _data_ptr->kerberosFlags.value, _data_ptr->kerberosFlags.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pKERB_PA_PAC_REQUEST(OssGlobal * _g, void * _data)
{
    _KERB_PA_PAC_REQUEST	*_data_ptr;
    _data_ptr = (_KERB_PA_PAC_REQUEST *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "include-pac ");
	ossPrint(_g, _data_ptr->include_pac ? "TRUE" : "FALSE");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pKERB_LOCAL(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pKERB_AD_RESTRICTION_ENTRY(OssGlobal * _g, void * _data)
{
    _KERB_AD_RESTRICTION_ENTRY	*_data_ptr;
    _data_ptr = (_KERB_AD_RESTRICTION_ENTRY *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "restriction-type ");
	{
	    LONG_LONG value = _data_ptr->restriction_type;
	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "restriction ");
	_oss_prt_oct(_g, _data_ptr->restriction.value, _data_ptr->restriction.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pPA_SUPPORTED_ENCTYPES(OssGlobal * _g, void * _data)
{
    OSS_INT32	*_data_ptr;
    _data_ptr = (OSS_INT32 *)_data;
    {
	LONG_LONG value = *_data_ptr;
	ossPrint(_g, LLONG_FMT, value);
    }

    return PDU_PRINTED;
}

int DLL_ENTRY_FDEF _pmMS_SFU_KILE(struct ossGlobal * _g, int _pdunum, void * _data)
{
    int _rc = _pdunum < 0;

    if (_rc)
	_pdunum = -_pdunum;
    if (_pdunum < 1 || _pdunum > 91 || !_PrintPDU[_pdunum - 1]._pf)
	return PDU_RANGE;
    else {
	if (_rc) {
	    ossPrint(_g, "%s : ", _PrintPDU[_pdunum - 1]._name);
	    _rc = _PrintPDU[_pdunum - 1]._pf(_g, _data);
	} else {
	    ossPrint(_g, "value %s ::= ", _PrintPDU[_pdunum - 1]._name);
	    _rc = _PrintPDU[_pdunum - 1]._pf(_g, _data);
	    ossPrint(_g, "\n");
	}
    }

    return _rc;
}

#endif

#ifdef OSS_COPY_VALUE
#define _oss_c ((_EncDecGlobals*)_g->encDecVar)

static _Ticket  * _cpTicket(OssGlobal * _g, _Ticket  * psVal, _Ticket  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Ticket  *)_oss_dec_const_alloc(_g, sizeof(_Ticket ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).realm), &((*pdVal).realm), sizeof(((*pdVal).realm).length), sizeof(((*pdVal).realm).value[0]), (unsigned int)((char *)&((*psVal).realm).value - (char *)&((*psVal).realm)));
    }
    {
	_cpPrincipalName(_g, &((*psVal).sname), &((*pdVal).sname));
    }
    {
	_cpEncryptedData(_g, &((*psVal).enc_part), &((*pdVal).enc_part));
    }
    return pdVal;
}


static _KDC_REQ_BODY  * _cpKDC_REQ_BODY(OssGlobal * _g, _KDC_REQ_BODY  * psVal, _KDC_REQ_BODY  * pdVal)
{
    if (!pdVal) {
	pdVal = (_KDC_REQ_BODY  *)_oss_dec_const_alloc(_g, sizeof(_KDC_REQ_BODY ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).kdc_options), &((*pdVal).kdc_options), sizeof(((*pdVal).kdc_options).length), -1L, (unsigned int)((char *)&((*psVal).kdc_options).value - (char *)&((*psVal).kdc_options)));
    }
    if ((*psVal).bit_mask & 0x80000000) {
	_cpPrincipalName(_g, &((*psVal).cname), &((*pdVal).cname));
    }
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).realm), &((*pdVal).realm), sizeof(((*pdVal).realm).length), sizeof(((*pdVal).realm).value[0]), (unsigned int)((char *)&((*psVal).realm).value - (char *)&((*psVal).realm)));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_cpPrincipalName(_g, &((*psVal).sname), &((*pdVal).sname));
    }
    if ((*psVal).from) {
	size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).from, OSS_MAX_STR) + 1);

	(*pdVal).from = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	OSS_STRCPY(_g, (*pdVal).from, (long)len_1, (*psVal).from);
    }
    {
	size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).till, OSS_MAX_STR) + 1);

	(*pdVal).till = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	OSS_STRCPY(_g, (*pdVal).till, (long)len_1, (*psVal).till);
    }
    if ((*psVal).rtime) {
	size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).rtime, OSS_MAX_STR) + 1);

	(*pdVal).rtime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	OSS_STRCPY(_g, (*pdVal).rtime, (long)len_1, (*psVal).rtime);
    }
    {
	_oss_cpy_link_obj(_g, (void**)(&((*psVal).etype)), (void**)(&((*pdVal).etype)), sizeof(_seqof2));
    }
    if ((*psVal).bit_mask & 0x20000000) {
	_cpHostAddresses(_g, &((*psVal).addresses), &((*pdVal).addresses));
    }
    if ((*psVal).bit_mask & 0x10000000) {
	_cpEncryptedData(_g, &((*psVal).enc_authorization_data), &((*pdVal).enc_authorization_data));
    }
    if ((*psVal).bit_mask & 0x8000000) {
	_cp_seqof3(_g, &((*psVal).additional_tickets), &((*pdVal).additional_tickets));
    }
    return pdVal;
}


static _seqof1 * * _cp_seqof1(OssGlobal * _g, _seqof1 * * psVal, _seqof1 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seqof1 * *)_oss_dec_const_alloc(_g, sizeof(_seqof1 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_seqof1 *  s_oss_tmp_1 = *psVal;
	_seqof1 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
	do {
	    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof1), s_oss_tmp_1, sizeof(_seqof1));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value), sizeof((d_oss_tmp_1->value).length), sizeof((d_oss_tmp_1->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_1->value).value - (char *)&(s_oss_tmp_1->value)));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _PrincipalName  * _cpPrincipalName(OssGlobal * _g, _PrincipalName  * psVal, _PrincipalName  * pdVal)
{
    if (!pdVal) {
	pdVal = (_PrincipalName  *)_oss_dec_const_alloc(_g, sizeof(_PrincipalName ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_cp_seqof1(_g, &((*psVal).name_string), &((*pdVal).name_string));
    }
    return pdVal;
}


static _HostAddress  * _cpHostAddress(OssGlobal * _g, _HostAddress  * psVal, _HostAddress  * pdVal)
{
    if (!pdVal) {
	pdVal = (_HostAddress  *)_oss_dec_const_alloc(_g, sizeof(_HostAddress ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).address), &((*pdVal).address), sizeof(((*pdVal).address).length), sizeof(((*pdVal).address).value[0]), (unsigned int)((char *)&((*psVal).address).value - (char *)&((*psVal).address)));
    }
    return pdVal;
}


static _HostAddresses * * _cpHostAddresses(OssGlobal * _g, _HostAddresses * * psVal, _HostAddresses * * pdVal)
{
    if (!pdVal) {
	pdVal = (_HostAddresses * *)_oss_dec_const_alloc(_g, sizeof(_HostAddresses *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_HostAddresses *  s_oss_tmp_1 = *psVal;
	_HostAddresses *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_HostAddresses *)_oss_dec_getmem_internal(_g, sizeof(_HostAddresses));
	do {
	    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_HostAddresses), s_oss_tmp_1, sizeof(_HostAddresses));
	    {
		_cpHostAddress(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_HostAddresses *)_oss_dec_getmem_internal(_g, sizeof(_HostAddresses));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _seq1  * _cp_seq1(OssGlobal * _g, _seq1  * psVal, _seq1  * pdVal)
{
    if (!pdVal) {
	pdVal = (_seq1  *)_oss_dec_const_alloc(_g, sizeof(_seq1 ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).ad_data), &((*pdVal).ad_data), sizeof(((*pdVal).ad_data).length), sizeof(((*pdVal).ad_data).value[0]), (unsigned int)((char *)&((*psVal).ad_data).value - (char *)&((*psVal).ad_data)));
    }
    return pdVal;
}


static _AuthorizationData * * _cpAuthorizationData(OssGlobal * _g, _AuthorizationData * * psVal, _AuthorizationData * * pdVal)
{
    if (!pdVal) {
	pdVal = (_AuthorizationData * *)_oss_dec_const_alloc(_g, sizeof(_AuthorizationData *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_AuthorizationData *  s_oss_tmp_1 = *psVal;
	_AuthorizationData *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_AuthorizationData *)_oss_dec_getmem_internal(_g, sizeof(_AuthorizationData));
	do {
	    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_AuthorizationData), s_oss_tmp_1, sizeof(_AuthorizationData));
	    {
		_cp_seq1(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_AuthorizationData *)_oss_dec_getmem_internal(_g, sizeof(_AuthorizationData));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _PA_DATA  * _cpPA_DATA(OssGlobal * _g, _PA_DATA  * psVal, _PA_DATA  * pdVal)
{
    if (!pdVal) {
	pdVal = (_PA_DATA  *)_oss_dec_const_alloc(_g, sizeof(_PA_DATA ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).padata_value), &((*pdVal).padata_value), sizeof(((*pdVal).padata_value).length), sizeof(((*pdVal).padata_value).value[0]), (unsigned int)((char *)&((*psVal).padata_value).value - (char *)&((*psVal).padata_value)));
    }
    return pdVal;
}


static _EncryptedData  * _cpEncryptedData(OssGlobal * _g, _EncryptedData  * psVal, _EncryptedData  * pdVal)
{
    if (!pdVal) {
	pdVal = (_EncryptedData  *)_oss_dec_const_alloc(_g, sizeof(_EncryptedData ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).cipher), &((*pdVal).cipher), sizeof(((*pdVal).cipher).length), sizeof(((*pdVal).cipher).value[0]), (unsigned int)((char *)&((*psVal).cipher).value - (char *)&((*psVal).cipher)));
    }
    return pdVal;
}


static _EncryptionKey  * _cpEncryptionKey(OssGlobal * _g, _EncryptionKey  * psVal, _EncryptionKey  * pdVal)
{
    if (!pdVal) {
	pdVal = (_EncryptionKey  *)_oss_dec_const_alloc(_g, sizeof(_EncryptionKey ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).keyvalue), &((*pdVal).keyvalue), sizeof(((*pdVal).keyvalue).length), sizeof(((*pdVal).keyvalue).value[0]), (unsigned int)((char *)&((*psVal).keyvalue).value - (char *)&((*psVal).keyvalue)));
    }
    return pdVal;
}


static _Checksum  * _cpChecksum(OssGlobal * _g, _Checksum  * psVal, _Checksum  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Checksum  *)_oss_dec_const_alloc(_g, sizeof(_Checksum ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).checksum), &((*pdVal).checksum), sizeof(((*pdVal).checksum).length), sizeof(((*pdVal).checksum).value[0]), (unsigned int)((char *)&((*psVal).checksum).value - (char *)&((*psVal).checksum)));
    }
    return pdVal;
}


static _seqof3 * * _cp_seqof3(OssGlobal * _g, _seqof3 * * psVal, _seqof3 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seqof3 * *)_oss_dec_const_alloc(_g, sizeof(_seqof3 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_seqof3 *  s_oss_tmp_1 = *psVal;
	_seqof3 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_seqof3 *)_oss_dec_getmem_internal(_g, sizeof(_seqof3));
	do {
	    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof3), s_oss_tmp_1, sizeof(_seqof3));
	    {
		_cpTicket(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_seqof3 *)_oss_dec_getmem_internal(_g, sizeof(_seqof3));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _seqof4 * * _cp_seqof4(OssGlobal * _g, _seqof4 * * psVal, _seqof4 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seqof4 * *)_oss_dec_const_alloc(_g, sizeof(_seqof4 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_seqof4 *  s_oss_tmp_1 = *psVal;
	_seqof4 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_seqof4 *)_oss_dec_getmem_internal(_g, sizeof(_seqof4));
	do {
	    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof4), s_oss_tmp_1, sizeof(_seqof4));
	    {
		_cpPA_DATA(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_seqof4 *)_oss_dec_getmem_internal(_g, sizeof(_seqof4));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _KDC_REQ  * _cpKDC_REQ(OssGlobal * _g, _KDC_REQ  * psVal, _KDC_REQ  * pdVal)
{
    if (!pdVal) {
	pdVal = (_KDC_REQ  *)_oss_dec_const_alloc(_g, sizeof(_KDC_REQ ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_cp_seqof4(_g, &((*psVal).padata), &((*pdVal).padata));
    }
    {
	_cpKDC_REQ_BODY(_g, &((*psVal).req_body), &((*pdVal).req_body));
    }
    return pdVal;
}


static _seqof4 * * _cp_seqof5(OssGlobal * _g, _seqof4 * * psVal, _seqof4 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seqof4 * *)_oss_dec_const_alloc(_g, sizeof(_seqof4 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_seqof4 *  s_oss_tmp_1 = *psVal;
	_seqof4 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_seqof4 *)_oss_dec_getmem_internal(_g, sizeof(_seqof4));
	do {
	    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof4), s_oss_tmp_1, sizeof(_seqof4));
	    {
		_cpPA_DATA(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_seqof4 *)_oss_dec_getmem_internal(_g, sizeof(_seqof4));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _KDC_REP  * _cpKDC_REP(OssGlobal * _g, _KDC_REP  * psVal, _KDC_REP  * pdVal)
{
    if (!pdVal) {
	pdVal = (_KDC_REP  *)_oss_dec_const_alloc(_g, sizeof(_KDC_REP ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_cp_seqof5(_g, &((*psVal).padata), &((*pdVal).padata));
    }
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).crealm), &((*pdVal).crealm), sizeof(((*pdVal).crealm).length), sizeof(((*pdVal).crealm).value[0]), (unsigned int)((char *)&((*psVal).crealm).value - (char *)&((*psVal).crealm)));
    }
    {
	_cpPrincipalName(_g, &((*psVal).cname), &((*pdVal).cname));
    }
    {
	_cpTicket(_g, &((*psVal).ticket), &((*pdVal).ticket));
    }
    {
	_cpEncryptedData(_g, &((*psVal).enc_part), &((*pdVal).enc_part));
    }
    return pdVal;
}


static _seqof4 * * _cp_seqof6(OssGlobal * _g, _seqof4 * * psVal, _seqof4 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seqof4 * *)_oss_dec_const_alloc(_g, sizeof(_seqof4 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_seqof4 *  s_oss_tmp_1 = *psVal;
	_seqof4 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_seqof4 *)_oss_dec_getmem_internal(_g, sizeof(_seqof4));
	do {
	    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof4), s_oss_tmp_1, sizeof(_seqof4));
	    {
		_cpPA_DATA(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_seqof4 *)_oss_dec_getmem_internal(_g, sizeof(_seqof4));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _EncKDCRepPart  * _cpEncKDCRepPart(OssGlobal * _g, _EncKDCRepPart  * psVal, _EncKDCRepPart  * pdVal)
{
    if (!pdVal) {
	pdVal = (_EncKDCRepPart  *)_oss_dec_const_alloc(_g, sizeof(_EncKDCRepPart ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_cpEncryptionKey(_g, &((*psVal).key), &((*pdVal).key));
    }
    {
	_cpLastReq(_g, &((*psVal).last_req), &((*pdVal).last_req));
    }
    if ((*psVal).key_expiration) {
	size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).key_expiration, OSS_MAX_STR) + 1);

	(*pdVal).key_expiration = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	OSS_STRCPY(_g, (*pdVal).key_expiration, (long)len_1, (*psVal).key_expiration);
    }
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).flags), &((*pdVal).flags), sizeof(((*pdVal).flags).length), -1L, (unsigned int)((char *)&((*psVal).flags).value - (char *)&((*psVal).flags)));
    }
    {
	size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).authtime, OSS_MAX_STR) + 1);

	(*pdVal).authtime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	OSS_STRCPY(_g, (*pdVal).authtime, (long)len_1, (*psVal).authtime);
    }
    if ((*psVal).starttime) {
	size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).starttime, OSS_MAX_STR) + 1);

	(*pdVal).starttime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	OSS_STRCPY(_g, (*pdVal).starttime, (long)len_1, (*psVal).starttime);
    }
    {
	size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).endtime, OSS_MAX_STR) + 1);

	(*pdVal).endtime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	OSS_STRCPY(_g, (*pdVal).endtime, (long)len_1, (*psVal).endtime);
    }
    if ((*psVal).renew_till) {
	size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).renew_till, OSS_MAX_STR) + 1);

	(*pdVal).renew_till = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	OSS_STRCPY(_g, (*pdVal).renew_till, (long)len_1, (*psVal).renew_till);
    }
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).srealm), &((*pdVal).srealm), sizeof(((*pdVal).srealm).length), sizeof(((*pdVal).srealm).value[0]), (unsigned int)((char *)&((*psVal).srealm).value - (char *)&((*psVal).srealm)));
    }
    {
	_cpPrincipalName(_g, &((*psVal).sname), &((*pdVal).sname));
    }
    if ((*psVal).bit_mask & 0x80000000) {
	_cpHostAddresses(_g, &((*psVal).caddr), &((*pdVal).caddr));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_cp_seqof6(_g, &((*psVal).encrypted_pa_data), &((*pdVal).encrypted_pa_data));
    }
    return pdVal;
}


static _seq2  * _cp_seq2(OssGlobal * _g, _seq2  * psVal, _seq2  * pdVal)
{
    if (!pdVal) {
	pdVal = (_seq2  *)_oss_dec_const_alloc(_g, sizeof(_seq2 ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).lr_value, OSS_MAX_STR) + 1);

	(*pdVal).lr_value = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	OSS_STRCPY(_g, (*pdVal).lr_value, (long)len_1, (*psVal).lr_value);
    }
    return pdVal;
}


static _LastReq * * _cpLastReq(OssGlobal * _g, _LastReq * * psVal, _LastReq * * pdVal)
{
    if (!pdVal) {
	pdVal = (_LastReq * *)_oss_dec_const_alloc(_g, sizeof(_LastReq *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_LastReq *  s_oss_tmp_1 = *psVal;
	_LastReq *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_LastReq *)_oss_dec_getmem_internal(_g, sizeof(_LastReq));
	do {
	    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_LastReq), s_oss_tmp_1, sizeof(_LastReq));
	    {
		_cp_seq2(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_LastReq *)_oss_dec_getmem_internal(_g, sizeof(_LastReq));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _ExternalPrincipalIdentifier  * _cpExternalPrincipalIdentifier(OssGlobal * _g, _ExternalPrincipalIdentifier  * psVal, _ExternalPrincipalIdentifier  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ExternalPrincipalIdentifier  *)_oss_dec_const_alloc(_g, sizeof(_ExternalPrincipalIdentifier ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).subjectName), &((*pdVal).subjectName), sizeof(((*pdVal).subjectName).length), sizeof(((*pdVal).subjectName).value[0]), (unsigned int)((char *)&((*psVal).subjectName).value - (char *)&((*psVal).subjectName)));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).issuerAndSerialNumber), &((*pdVal).issuerAndSerialNumber), sizeof(((*pdVal).issuerAndSerialNumber).length), sizeof(((*pdVal).issuerAndSerialNumber).value[0]), (unsigned int)((char *)&((*psVal).issuerAndSerialNumber).value - (char *)&((*psVal).issuerAndSerialNumber)));
    }
    if ((*psVal).bit_mask & 0x20000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).subjectKeyIdentifier), &((*pdVal).subjectKeyIdentifier), sizeof(((*pdVal).subjectKeyIdentifier).length), sizeof(((*pdVal).subjectKeyIdentifier).value[0]), (unsigned int)((char *)&((*psVal).subjectKeyIdentifier).value - (char *)&((*psVal).subjectKeyIdentifier)));
    }
    return pdVal;
}


static _AlgorithmIdentifier  * _cpAlgorithmIdentifier(OssGlobal * _g, _AlgorithmIdentifier  * psVal, _AlgorithmIdentifier  * pdVal)
{
    if (!pdVal) {
	pdVal = (_AlgorithmIdentifier  *)_oss_dec_const_alloc(_g, sizeof(_AlgorithmIdentifier ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).algorithm), &((*pdVal).algorithm), sizeof(((*pdVal).algorithm).length), sizeof(((*pdVal).algorithm).value[0]), (unsigned int)((char *)&((*psVal).algorithm).value - (char *)&((*psVal).algorithm)));
    }
    if ((*psVal).bit_mask & 0x80000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).parameters), &((*pdVal).parameters), sizeof(((*pdVal).parameters).length), sizeof(((*pdVal).parameters).value[0]), (unsigned int)((char *)&((*psVal).parameters).value - (char *)&((*psVal).parameters)));
    }
    return pdVal;
}


static _SubjectPublicKeyInfo  * _cpSubjectPublicKeyInfo(OssGlobal * _g, _SubjectPublicKeyInfo  * psVal, _SubjectPublicKeyInfo  * pdVal)
{
    if (!pdVal) {
	pdVal = (_SubjectPublicKeyInfo  *)_oss_dec_const_alloc(_g, sizeof(_SubjectPublicKeyInfo ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_cpAlgorithmIdentifier(_g, &((*psVal).algorithm), &((*pdVal).algorithm));
    }
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).subjectPublicKey), &((*pdVal).subjectPublicKey), sizeof(((*pdVal).subjectPublicKey).length), -1L, (unsigned int)((char *)&((*psVal).subjectPublicKey).value - (char *)&((*psVal).subjectPublicKey)));
    }
    return pdVal;
}


static _Name  * _cpName(OssGlobal * _g, _Name  * psVal, _Name  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Name  *)_oss_dec_const_alloc(_g, sizeof(_Name ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _cpRDNSequence(_g, &((*psVal).u.rdnSequence), &((*pdVal).u.rdnSequence));
	}   break;
	default:;
    }
    return pdVal;
}


static _RDNSequence * * _cpRDNSequence(OssGlobal * _g, _RDNSequence * * psVal, _RDNSequence * * pdVal)
{
    if (!pdVal) {
	pdVal = (_RDNSequence * *)_oss_dec_const_alloc(_g, sizeof(_RDNSequence *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_RDNSequence *  s_oss_tmp_1 = *psVal;
	_RDNSequence *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_RDNSequence *)_oss_dec_getmem_internal(_g, sizeof(_RDNSequence));
	do {
	    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_RDNSequence), s_oss_tmp_1, sizeof(_RDNSequence));
	    {
		d_oss_tmp_1->value = NULL;
		if (s_oss_tmp_1->value) {
		    _RelativeDistinguishedName *  s_oss_tmp_2 = s_oss_tmp_1->value;
		    _RelativeDistinguishedName *  d_oss_tmp_2;

		    d_oss_tmp_1->value = d_oss_tmp_2 = (_RelativeDistinguishedName *)_oss_dec_getmem_internal(_g, sizeof(_RelativeDistinguishedName));
		    do {
			OSS_MEMCPY(_g, d_oss_tmp_2,  sizeof(_RelativeDistinguishedName), s_oss_tmp_2, sizeof(_RelativeDistinguishedName));
			{
			    {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).type), &((d_oss_tmp_2->value).type), sizeof(((d_oss_tmp_2->value).type).length), sizeof(((d_oss_tmp_2->value).type).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).type).value - (char *)&((s_oss_tmp_2->value).type)));
			    }
			    {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).value), &((d_oss_tmp_2->value).value), sizeof(((d_oss_tmp_2->value).value).length), sizeof(((d_oss_tmp_2->value).value).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).value).value - (char *)&((s_oss_tmp_2->value).value)));
			    }
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_RelativeDistinguishedName *)_oss_dec_getmem_internal(_g, sizeof(_RelativeDistinguishedName));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_RDNSequence *)_oss_dec_getmem_internal(_g, sizeof(_RDNSequence));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _Time  * _cpTime(OssGlobal * _g, _Time  * psVal, _Time  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Time  *)_oss_dec_const_alloc(_g, sizeof(_Time ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).u.utcTime, OSS_MAX_STR) + 1);

	    (*pdVal).u.utcTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	    OSS_STRCPY(_g, (*pdVal).u.utcTime, (long)len_1, (*psVal).u.utcTime);
	}   break;
	case 2: {
	    size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*psVal).u.generalTime, OSS_MAX_STR) + 1);

	    (*pdVal).u.generalTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	    OSS_STRCPY(_g, (*pdVal).u.generalTime, (long)len_1, (*psVal).u.generalTime);
	}   break;
	default:;
    }
    return pdVal;
}


static _Extension  * _cpExtension(OssGlobal * _g, _Extension  * psVal, _Extension  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Extension  *)_oss_dec_const_alloc(_g, sizeof(_Extension ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).extnID), &((*pdVal).extnID), sizeof(((*pdVal).extnID).length), sizeof(((*pdVal).extnID).value[0]), (unsigned int)((char *)&((*psVal).extnID).value - (char *)&((*psVal).extnID)));
    }
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).extnValue), &((*pdVal).extnValue), sizeof(((*pdVal).extnValue).length), sizeof(((*pdVal).extnValue).value[0]), (unsigned int)((char *)&((*psVal).extnValue).value - (char *)&((*psVal).extnValue)));
    }
    return pdVal;
}


static _Extensions * * _cpExtensions(OssGlobal * _g, _Extensions * * psVal, _Extensions * * pdVal)
{
    if (!pdVal) {
	pdVal = (_Extensions * *)_oss_dec_const_alloc(_g, sizeof(_Extensions *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_Extensions *  s_oss_tmp_1 = *psVal;
	_Extensions *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_Extensions *)_oss_dec_getmem_internal(_g, sizeof(_Extensions));
	do {
	    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_Extensions), s_oss_tmp_1, sizeof(_Extensions));
	    {
		_cpExtension(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_Extensions *)_oss_dec_getmem_internal(_g, sizeof(_Extensions));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _PDSParameter  * _cpPDSParameter(OssGlobal * _g, _PDSParameter  * psVal, _PDSParameter  * pdVal)
{
    if (!pdVal) {
	pdVal = (_PDSParameter  *)_oss_dec_const_alloc(_g, sizeof(_PDSParameter ));
    }
    OSS_MEMCPY(_g, pdVal, sizeof(*pdVal), psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).printable_string), &((*pdVal).printable_string), sizeof(((*pdVal).printable_string).length), sizeof(((*pdVal).printable_string).value[0]), (unsigned int)((char *)&((*psVal).printable_string).value - (char *)&((*psVal).printable_string)));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).teletex_string), &((*pdVal).teletex_string), sizeof(((*pdVal).teletex_string).length), sizeof(((*pdVal).teletex_string).value[0]), (unsigned int)((char *)&((*psVal).teletex_string).value - (char *)&((*psVal).teletex_string)));
    }
    return pdVal;
}


int DLL_ENTRY_FDEF _CPMS_SFU_KILE(struct ossGlobal * _g, int pduNum, void * src, void ** pdst)
{
    int res = 0;
    void *pdVal = NULL;

    if (pduNum <= 0 || pduNum > 92)
	return PDU_RANGE;
    switch (pduNum) {
	case 1: {
	    pdVal = _cpTicket(_g, (_Ticket  *)src, (_Ticket  *)pdVal);
	} break;
	case 2: {
	    pdVal = (_EncTicketPart  *)_oss_dec_const_alloc(_g, sizeof(_EncTicketPart ));
	    OSS_MEMCPY(_g, (_EncTicketPart  *)pdVal, sizeof(*(_EncTicketPart  *)pdVal), (_EncTicketPart  *)src, sizeof(*(_EncTicketPart  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_EncTicketPart  *)src).flags), &((*(_EncTicketPart  *)pdVal).flags), sizeof(((*(_EncTicketPart  *)pdVal).flags).length), -1L, (unsigned int)((char *)&((*(_EncTicketPart  *)src).flags).value - (char *)&((*(_EncTicketPart  *)src).flags)));
	    }
	    {
		_cpEncryptionKey(_g, &((*(_EncTicketPart  *)src).key), &((*(_EncTicketPart  *)pdVal).key));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_EncTicketPart  *)src).crealm), &((*(_EncTicketPart  *)pdVal).crealm), sizeof(((*(_EncTicketPart  *)pdVal).crealm).length), sizeof(((*(_EncTicketPart  *)pdVal).crealm).value[0]), (unsigned int)((char *)&((*(_EncTicketPart  *)src).crealm).value - (char *)&((*(_EncTicketPart  *)src).crealm)));
	    }
	    {
		_cpPrincipalName(_g, &((*(_EncTicketPart  *)src).cname), &((*(_EncTicketPart  *)pdVal).cname));
	    }
	    {
		{
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_EncTicketPart  *)src).transited).contents), &(((*(_EncTicketPart  *)pdVal).transited).contents), sizeof((((*(_EncTicketPart  *)pdVal).transited).contents).length), sizeof((((*(_EncTicketPart  *)pdVal).transited).contents).value[0]), (unsigned int)((char *)&(((*(_EncTicketPart  *)src).transited).contents).value - (char *)&(((*(_EncTicketPart  *)src).transited).contents)));
		}
	    }
	    {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_EncTicketPart  *)src).authtime, OSS_MAX_STR) + 1);

		(*(_EncTicketPart  *)pdVal).authtime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_EncTicketPart  *)pdVal).authtime, (long)len_1, (*(_EncTicketPart  *)src).authtime);
	    }
	    if ((*(_EncTicketPart  *)src).starttime) {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_EncTicketPart  *)src).starttime, OSS_MAX_STR) + 1);

		(*(_EncTicketPart  *)pdVal).starttime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_EncTicketPart  *)pdVal).starttime, (long)len_1, (*(_EncTicketPart  *)src).starttime);
	    }
	    {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_EncTicketPart  *)src).endtime, OSS_MAX_STR) + 1);

		(*(_EncTicketPart  *)pdVal).endtime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_EncTicketPart  *)pdVal).endtime, (long)len_1, (*(_EncTicketPart  *)src).endtime);
	    }
	    if ((*(_EncTicketPart  *)src).renew_till) {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_EncTicketPart  *)src).renew_till, OSS_MAX_STR) + 1);

		(*(_EncTicketPart  *)pdVal).renew_till = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_EncTicketPart  *)pdVal).renew_till, (long)len_1, (*(_EncTicketPart  *)src).renew_till);
	    }
	    if ((*(_EncTicketPart  *)src).bit_mask & 0x80000000) {
		_cpHostAddresses(_g, &((*(_EncTicketPart  *)src).caddr), &((*(_EncTicketPart  *)pdVal).caddr));
	    }
	    if ((*(_EncTicketPart  *)src).bit_mask & 0x40000000) {
		_cpAuthorizationData(_g, &((*(_EncTicketPart  *)src).authorization_data), &((*(_EncTicketPart  *)pdVal).authorization_data));
	    }
	} break;
	case 3: {
	    pdVal = _cpKDC_REQ(_g, (_KDC_REQ  *)src, (_KDC_REQ  *)pdVal);
	} break;
	case 4: {
	    pdVal = _cpKDC_REQ(_g, (_KDC_REQ  *)src, (_KDC_REQ  *)pdVal);
	} break;
	case 5: {
	    pdVal = _cpKDC_REQ_BODY(_g, (_KDC_REQ_BODY  *)src, (_KDC_REQ_BODY  *)pdVal);
	} break;
	case 6: {
	    pdVal = _cpKDC_REP(_g, (_KDC_REP  *)src, (_KDC_REP  *)pdVal);
	} break;
	case 7: {
	    pdVal = _cpKDC_REP(_g, (_KDC_REP  *)src, (_KDC_REP  *)pdVal);
	} break;
	case 8: {
	    pdVal = _cpEncKDCRepPart(_g, (_EncKDCRepPart  *)src, (_EncKDCRepPart  *)pdVal);
	} break;
	case 9: {
	    pdVal = _cpEncKDCRepPart(_g, (_EncKDCRepPart  *)src, (_EncKDCRepPart  *)pdVal);
	} break;
	case 10: {
	    pdVal = (_AP_REQ  *)_oss_dec_const_alloc(_g, sizeof(_AP_REQ ));
	    OSS_MEMCPY(_g, (_AP_REQ  *)pdVal, sizeof(*(_AP_REQ  *)pdVal), (_AP_REQ  *)src, sizeof(*(_AP_REQ  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_AP_REQ  *)src).ap_options), &((*(_AP_REQ  *)pdVal).ap_options), sizeof(((*(_AP_REQ  *)pdVal).ap_options).length), -1L, (unsigned int)((char *)&((*(_AP_REQ  *)src).ap_options).value - (char *)&((*(_AP_REQ  *)src).ap_options)));
	    }
	    {
		_cpTicket(_g, &((*(_AP_REQ  *)src).ticket), &((*(_AP_REQ  *)pdVal).ticket));
	    }
	    {
		_cpEncryptedData(_g, &((*(_AP_REQ  *)src).authenticator), &((*(_AP_REQ  *)pdVal).authenticator));
	    }
	} break;
	case 11: {
	    pdVal = (_Authenticator  *)_oss_dec_const_alloc(_g, sizeof(_Authenticator ));
	    OSS_MEMCPY(_g, (_Authenticator  *)pdVal, sizeof(*(_Authenticator  *)pdVal), (_Authenticator  *)src, sizeof(*(_Authenticator  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_Authenticator  *)src).crealm), &((*(_Authenticator  *)pdVal).crealm), sizeof(((*(_Authenticator  *)pdVal).crealm).length), sizeof(((*(_Authenticator  *)pdVal).crealm).value[0]), (unsigned int)((char *)&((*(_Authenticator  *)src).crealm).value - (char *)&((*(_Authenticator  *)src).crealm)));
	    }
	    {
		_cpPrincipalName(_g, &((*(_Authenticator  *)src).cname), &((*(_Authenticator  *)pdVal).cname));
	    }
	    if ((*(_Authenticator  *)src).bit_mask & 0x80000000) {
		_cpChecksum(_g, &((*(_Authenticator  *)src).cksum), &((*(_Authenticator  *)pdVal).cksum));
	    }
	    {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_Authenticator  *)src).ctime, OSS_MAX_STR) + 1);

		(*(_Authenticator  *)pdVal).ctime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_Authenticator  *)pdVal).ctime, (long)len_1, (*(_Authenticator  *)src).ctime);
	    }
	    if ((*(_Authenticator  *)src).bit_mask & 0x40000000) {
		_cpEncryptionKey(_g, &((*(_Authenticator  *)src).subkey), &((*(_Authenticator  *)pdVal).subkey));
	    }
	    if ((*(_Authenticator  *)src).bit_mask & 0x10000000) {
		_cpAuthorizationData(_g, &((*(_Authenticator  *)src).authorization_data), &((*(_Authenticator  *)pdVal).authorization_data));
	    }
	} break;
	case 12: {
	    pdVal = (_AP_REP  *)_oss_dec_const_alloc(_g, sizeof(_AP_REP ));
	    OSS_MEMCPY(_g, (_AP_REP  *)pdVal, sizeof(*(_AP_REP  *)pdVal), (_AP_REP  *)src, sizeof(*(_AP_REP  *)pdVal));
	    {
		_cpEncryptedData(_g, &((*(_AP_REP  *)src).enc_part), &((*(_AP_REP  *)pdVal).enc_part));
	    }
	} break;
	case 13: {
	    pdVal = (_EncAPRepPart  *)_oss_dec_const_alloc(_g, sizeof(_EncAPRepPart ));
	    OSS_MEMCPY(_g, (_EncAPRepPart  *)pdVal, sizeof(*(_EncAPRepPart  *)pdVal), (_EncAPRepPart  *)src, sizeof(*(_EncAPRepPart  *)pdVal));
	    {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_EncAPRepPart  *)src).ctime, OSS_MAX_STR) + 1);

		(*(_EncAPRepPart  *)pdVal).ctime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_EncAPRepPart  *)pdVal).ctime, (long)len_1, (*(_EncAPRepPart  *)src).ctime);
	    }
	    if ((*(_EncAPRepPart  *)src).bit_mask & 0x80000000) {
		_cpEncryptionKey(_g, &((*(_EncAPRepPart  *)src).subkey), &((*(_EncAPRepPart  *)pdVal).subkey));
	    }
	} break;
	case 14: {
	    pdVal = (_KRB_SAFE  *)_oss_dec_const_alloc(_g, sizeof(_KRB_SAFE ));
	    OSS_MEMCPY(_g, (_KRB_SAFE  *)pdVal, sizeof(*(_KRB_SAFE  *)pdVal), (_KRB_SAFE  *)src, sizeof(*(_KRB_SAFE  *)pdVal));
	    {
		{
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_KRB_SAFE  *)src).safe_body).user_data), &(((*(_KRB_SAFE  *)pdVal).safe_body).user_data), sizeof((((*(_KRB_SAFE  *)pdVal).safe_body).user_data).length), sizeof((((*(_KRB_SAFE  *)pdVal).safe_body).user_data).value[0]), (unsigned int)((char *)&(((*(_KRB_SAFE  *)src).safe_body).user_data).value - (char *)&(((*(_KRB_SAFE  *)src).safe_body).user_data)));
		}
		if (((*(_KRB_SAFE  *)src).safe_body).timestamp) {
		    size_t  len_2 = (size_t)sizeof(char) * (OSS_STRNLEN(((*(_KRB_SAFE  *)src).safe_body).timestamp, OSS_MAX_STR) + 1);

		    ((*(_KRB_SAFE  *)pdVal).safe_body).timestamp = (char * )_oss_dec_getmem_internal(_g, (long)len_2);
		    OSS_STRCPY(_g, ((*(_KRB_SAFE  *)pdVal).safe_body).timestamp, (long)len_2, ((*(_KRB_SAFE  *)src).safe_body).timestamp);
		}
		{
		    _cpHostAddress(_g, &(((*(_KRB_SAFE  *)src).safe_body).s_address), &(((*(_KRB_SAFE  *)pdVal).safe_body).s_address));
		}
		if (((*(_KRB_SAFE  *)src).safe_body).bit_mask & 0x20000000) {
		    _cpHostAddress(_g, &(((*(_KRB_SAFE  *)src).safe_body).r_address), &(((*(_KRB_SAFE  *)pdVal).safe_body).r_address));
		}
	    }
	    {
		_cpChecksum(_g, &((*(_KRB_SAFE  *)src).cksum), &((*(_KRB_SAFE  *)pdVal).cksum));
	    }
	} break;
	case 15: {
	    pdVal = (_AP_REP  *)_oss_dec_const_alloc(_g, sizeof(_AP_REP ));
	    OSS_MEMCPY(_g, (_AP_REP  *)pdVal, sizeof(*(_AP_REP  *)pdVal), (_AP_REP  *)src, sizeof(*(_AP_REP  *)pdVal));
	    {
		_cpEncryptedData(_g, &((*(_AP_REP  *)src).enc_part), &((*(_AP_REP  *)pdVal).enc_part));
	    }
	} break;
	case 16: {
	    pdVal = (_KRB_SAFE_BODY  *)_oss_dec_const_alloc(_g, sizeof(_KRB_SAFE_BODY ));
	    OSS_MEMCPY(_g, (_KRB_SAFE_BODY  *)pdVal, sizeof(*(_KRB_SAFE_BODY  *)pdVal), (_KRB_SAFE_BODY  *)src, sizeof(*(_KRB_SAFE_BODY  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_KRB_SAFE_BODY  *)src).user_data), &((*(_KRB_SAFE_BODY  *)pdVal).user_data), sizeof(((*(_KRB_SAFE_BODY  *)pdVal).user_data).length), sizeof(((*(_KRB_SAFE_BODY  *)pdVal).user_data).value[0]), (unsigned int)((char *)&((*(_KRB_SAFE_BODY  *)src).user_data).value - (char *)&((*(_KRB_SAFE_BODY  *)src).user_data)));
	    }
	    if ((*(_KRB_SAFE_BODY  *)src).timestamp) {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_KRB_SAFE_BODY  *)src).timestamp, OSS_MAX_STR) + 1);

		(*(_KRB_SAFE_BODY  *)pdVal).timestamp = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_KRB_SAFE_BODY  *)pdVal).timestamp, (long)len_1, (*(_KRB_SAFE_BODY  *)src).timestamp);
	    }
	    {
		_cpHostAddress(_g, &((*(_KRB_SAFE_BODY  *)src).s_address), &((*(_KRB_SAFE_BODY  *)pdVal).s_address));
	    }
	    if ((*(_KRB_SAFE_BODY  *)src).bit_mask & 0x20000000) {
		_cpHostAddress(_g, &((*(_KRB_SAFE_BODY  *)src).r_address), &((*(_KRB_SAFE_BODY  *)pdVal).r_address));
	    }
	} break;
	case 17: {
	    pdVal = (_KRB_CRED  *)_oss_dec_const_alloc(_g, sizeof(_KRB_CRED ));
	    OSS_MEMCPY(_g, (_KRB_CRED  *)pdVal, sizeof(*(_KRB_CRED  *)pdVal), (_KRB_CRED  *)src, sizeof(*(_KRB_CRED  *)pdVal));
	    {
		(*(_KRB_CRED  *)pdVal).tickets = NULL;
		if ((*(_KRB_CRED  *)src).tickets) {
		    _seqof3 *  s_oss_tmp_2 = (*(_KRB_CRED  *)src).tickets;
		    _seqof3 *  d_oss_tmp_2;

		    (*(_KRB_CRED  *)pdVal).tickets = d_oss_tmp_2 = (_seqof3 *)_oss_dec_getmem_internal(_g, sizeof(_seqof3));
		    do {
			OSS_MEMCPY(_g, d_oss_tmp_2,  sizeof(_seqof3), s_oss_tmp_2, sizeof(_seqof3));
			{
			    _cpTicket(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof3 *)_oss_dec_getmem_internal(_g, sizeof(_seqof3));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    {
		_cpEncryptedData(_g, &((*(_KRB_CRED  *)src).enc_part), &((*(_KRB_CRED  *)pdVal).enc_part));
	    }
	} break;
	case 18: {
	    pdVal = (_EncKrbCredPart  *)_oss_dec_const_alloc(_g, sizeof(_EncKrbCredPart ));
	    OSS_MEMCPY(_g, (_EncKrbCredPart  *)pdVal, sizeof(*(_EncKrbCredPart  *)pdVal), (_EncKrbCredPart  *)src, sizeof(*(_EncKrbCredPart  *)pdVal));
	    {
		(*(_EncKrbCredPart  *)pdVal).ticket_info = NULL;
		if ((*(_EncKrbCredPart  *)src).ticket_info) {
		    _seqof8 *  s_oss_tmp_2 = (*(_EncKrbCredPart  *)src).ticket_info;
		    _seqof8 *  d_oss_tmp_2;

		    (*(_EncKrbCredPart  *)pdVal).ticket_info = d_oss_tmp_2 = (_seqof8 *)_oss_dec_getmem_internal(_g, sizeof(_seqof8));
		    do {
			OSS_MEMCPY(_g, d_oss_tmp_2,  sizeof(_seqof8), s_oss_tmp_2, sizeof(_seqof8));
			{
			    {
				_cpEncryptionKey(_g, &((s_oss_tmp_2->value).key), &((d_oss_tmp_2->value).key));
			    }
			    if ((s_oss_tmp_2->value).bit_mask & 0x80000000) {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).prealm), &((d_oss_tmp_2->value).prealm), sizeof(((d_oss_tmp_2->value).prealm).length), sizeof(((d_oss_tmp_2->value).prealm).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).prealm).value - (char *)&((s_oss_tmp_2->value).prealm)));
			    }
			    if ((s_oss_tmp_2->value).bit_mask & 0x40000000) {
				_cpPrincipalName(_g, &((s_oss_tmp_2->value).pname), &((d_oss_tmp_2->value).pname));
			    }
			    if ((s_oss_tmp_2->value).bit_mask & 0x20000000) {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).flags), &((d_oss_tmp_2->value).flags), sizeof(((d_oss_tmp_2->value).flags).length), -1L, (unsigned int)((char *)&((s_oss_tmp_2->value).flags).value - (char *)&((s_oss_tmp_2->value).flags)));
			    }
			    if ((s_oss_tmp_2->value).authtime) {
				char *  * src_3 = &((s_oss_tmp_2->value).authtime);
				char *  * dst_3 = &((d_oss_tmp_2->value).authtime);
				size_t  len_3 = (size_t)sizeof(char) * (OSS_STRNLEN(*src_3, OSS_MAX_STR) + 1);

				*dst_3 = (char * )_oss_dec_getmem_internal(_g, (long)len_3);
				OSS_STRCPY(_g, *dst_3, (long)len_3, *src_3);
			    }
			    if ((s_oss_tmp_2->value).starttime) {
				char *  * src_3 = &((s_oss_tmp_2->value).starttime);
				char *  * dst_3 = &((d_oss_tmp_2->value).starttime);
				size_t  len_3 = (size_t)sizeof(char) * (OSS_STRNLEN(*src_3, OSS_MAX_STR) + 1);

				*dst_3 = (char * )_oss_dec_getmem_internal(_g, (long)len_3);
				OSS_STRCPY(_g, *dst_3, (long)len_3, *src_3);
			    }
			    if ((s_oss_tmp_2->value).endtime) {
				char *  * src_3 = &((s_oss_tmp_2->value).endtime);
				char *  * dst_3 = &((d_oss_tmp_2->value).endtime);
				size_t  len_3 = (size_t)sizeof(char) * (OSS_STRNLEN(*src_3, OSS_MAX_STR) + 1);

				*dst_3 = (char * )_oss_dec_getmem_internal(_g, (long)len_3);
				OSS_STRCPY(_g, *dst_3, (long)len_3, *src_3);
			    }
			    if ((s_oss_tmp_2->value).renew_till) {
				char *  * src_3 = &((s_oss_tmp_2->value).renew_till);
				char *  * dst_3 = &((d_oss_tmp_2->value).renew_till);
				size_t  len_3 = (size_t)sizeof(char) * (OSS_STRNLEN(*src_3, OSS_MAX_STR) + 1);

				*dst_3 = (char * )_oss_dec_getmem_internal(_g, (long)len_3);
				OSS_STRCPY(_g, *dst_3, (long)len_3, *src_3);
			    }
			    if ((s_oss_tmp_2->value).bit_mask & 0x10000000) {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).srealm), &((d_oss_tmp_2->value).srealm), sizeof(((d_oss_tmp_2->value).srealm).length), sizeof(((d_oss_tmp_2->value).srealm).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).srealm).value - (char *)&((s_oss_tmp_2->value).srealm)));
			    }
			    if ((s_oss_tmp_2->value).bit_mask & 0x8000000) {
				_cpPrincipalName(_g, &((s_oss_tmp_2->value).sname), &((d_oss_tmp_2->value).sname));
			    }
			    if ((s_oss_tmp_2->value).bit_mask & 0x4000000) {
				_cpHostAddresses(_g, &((s_oss_tmp_2->value).caddr), &((d_oss_tmp_2->value).caddr));
			    }
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof8 *)_oss_dec_getmem_internal(_g, sizeof(_seqof8));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_EncKrbCredPart  *)src).timestamp) {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_EncKrbCredPart  *)src).timestamp, OSS_MAX_STR) + 1);

		(*(_EncKrbCredPart  *)pdVal).timestamp = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_EncKrbCredPart  *)pdVal).timestamp, (long)len_1, (*(_EncKrbCredPart  *)src).timestamp);
	    }
	    if ((*(_EncKrbCredPart  *)src).bit_mask & 0x20000000) {
		_cpHostAddress(_g, &((*(_EncKrbCredPart  *)src).s_address), &((*(_EncKrbCredPart  *)pdVal).s_address));
	    }
	    if ((*(_EncKrbCredPart  *)src).bit_mask & 0x10000000) {
		_cpHostAddress(_g, &((*(_EncKrbCredPart  *)src).r_address), &((*(_EncKrbCredPart  *)pdVal).r_address));
	    }
	} break;
	case 19: {
	    pdVal = (_KRB_ERROR  *)_oss_dec_const_alloc(_g, sizeof(_KRB_ERROR ));
	    OSS_MEMCPY(_g, (_KRB_ERROR  *)pdVal, sizeof(*(_KRB_ERROR  *)pdVal), (_KRB_ERROR  *)src, sizeof(*(_KRB_ERROR  *)pdVal));
	    if ((*(_KRB_ERROR  *)src).ctime) {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_KRB_ERROR  *)src).ctime, OSS_MAX_STR) + 1);

		(*(_KRB_ERROR  *)pdVal).ctime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_KRB_ERROR  *)pdVal).ctime, (long)len_1, (*(_KRB_ERROR  *)src).ctime);
	    }
	    {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_KRB_ERROR  *)src).stime, OSS_MAX_STR) + 1);

		(*(_KRB_ERROR  *)pdVal).stime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_KRB_ERROR  *)pdVal).stime, (long)len_1, (*(_KRB_ERROR  *)src).stime);
	    }
	    if ((*(_KRB_ERROR  *)src).bit_mask & 0x40000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_KRB_ERROR  *)src).crealm), &((*(_KRB_ERROR  *)pdVal).crealm), sizeof(((*(_KRB_ERROR  *)pdVal).crealm).length), sizeof(((*(_KRB_ERROR  *)pdVal).crealm).value[0]), (unsigned int)((char *)&((*(_KRB_ERROR  *)src).crealm).value - (char *)&((*(_KRB_ERROR  *)src).crealm)));
	    }
	    if ((*(_KRB_ERROR  *)src).bit_mask & 0x20000000) {
		_cpPrincipalName(_g, &((*(_KRB_ERROR  *)src).cname), &((*(_KRB_ERROR  *)pdVal).cname));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_KRB_ERROR  *)src).realm), &((*(_KRB_ERROR  *)pdVal).realm), sizeof(((*(_KRB_ERROR  *)pdVal).realm).length), sizeof(((*(_KRB_ERROR  *)pdVal).realm).value[0]), (unsigned int)((char *)&((*(_KRB_ERROR  *)src).realm).value - (char *)&((*(_KRB_ERROR  *)src).realm)));
	    }
	    {
		_cpPrincipalName(_g, &((*(_KRB_ERROR  *)src).sname), &((*(_KRB_ERROR  *)pdVal).sname));
	    }
	    if ((*(_KRB_ERROR  *)src).bit_mask & 0x10000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_KRB_ERROR  *)src).e_text), &((*(_KRB_ERROR  *)pdVal).e_text), sizeof(((*(_KRB_ERROR  *)pdVal).e_text).length), sizeof(((*(_KRB_ERROR  *)pdVal).e_text).value[0]), (unsigned int)((char *)&((*(_KRB_ERROR  *)src).e_text).value - (char *)&((*(_KRB_ERROR  *)src).e_text)));
	    }
	    if ((*(_KRB_ERROR  *)src).bit_mask & 0x8000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_KRB_ERROR  *)src).e_data), &((*(_KRB_ERROR  *)pdVal).e_data), sizeof(((*(_KRB_ERROR  *)pdVal).e_data).length), sizeof(((*(_KRB_ERROR  *)pdVal).e_data).value[0]), (unsigned int)((char *)&((*(_KRB_ERROR  *)src).e_data).value - (char *)&((*(_KRB_ERROR  *)src).e_data)));
	    }
	} break;
	case 20: {
	    pdVal = (_seqof4 * *)_oss_dec_const_alloc(_g, sizeof(_seqof4 *));
	    *(_seqof4 * *)pdVal = NULL;
	    if (*(_seqof4 * *)src) {
		_seqof4 *  s_oss_tmp_1 = *(_seqof4 * *)src;
		_seqof4 *  d_oss_tmp_1;

		*(_seqof4 * *)pdVal = d_oss_tmp_1 = (_seqof4 *)_oss_dec_getmem_internal(_g, sizeof(_seqof4));
		do {
		    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof4), s_oss_tmp_1, sizeof(_seqof4));
		    {
			_cpPA_DATA(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_seqof4 *)_oss_dec_getmem_internal(_g, sizeof(_seqof4));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 21: {
	    pdVal = (_TYPED_DATA * *)_oss_dec_const_alloc(_g, sizeof(_TYPED_DATA *));
	    *(_TYPED_DATA * *)pdVal = NULL;
	    if (*(_TYPED_DATA * *)src) {
		_TYPED_DATA *  s_oss_tmp_1 = *(_TYPED_DATA * *)src;
		_TYPED_DATA *  d_oss_tmp_1;

		*(_TYPED_DATA * *)pdVal = d_oss_tmp_1 = (_TYPED_DATA *)_oss_dec_getmem_internal(_g, sizeof(_TYPED_DATA));
		do {
		    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_TYPED_DATA), s_oss_tmp_1, sizeof(_TYPED_DATA));
		    {
			if ((s_oss_tmp_1->value).bit_mask & 0x80000000) {
			    _oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).data_value), &((d_oss_tmp_1->value).data_value), sizeof(((d_oss_tmp_1->value).data_value).length), sizeof(((d_oss_tmp_1->value).data_value).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).data_value).value - (char *)&((s_oss_tmp_1->value).data_value)));
			}
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_TYPED_DATA *)_oss_dec_getmem_internal(_g, sizeof(_TYPED_DATA));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 22: {
	    pdVal = _cpEncryptedData(_g, (_EncryptedData  *)src, (_EncryptedData  *)pdVal);
	} break;
	case 23: {
	    pdVal = (_PA_ENC_TS_ENC  *)_oss_dec_const_alloc(_g, sizeof(_PA_ENC_TS_ENC ));
	    OSS_MEMCPY(_g, (_PA_ENC_TS_ENC  *)pdVal, sizeof(*(_PA_ENC_TS_ENC  *)pdVal), (_PA_ENC_TS_ENC  *)src, sizeof(*(_PA_ENC_TS_ENC  *)pdVal));
	    {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_PA_ENC_TS_ENC  *)src).patimestamp, OSS_MAX_STR) + 1);

		(*(_PA_ENC_TS_ENC  *)pdVal).patimestamp = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_PA_ENC_TS_ENC  *)pdVal).patimestamp, (long)len_1, (*(_PA_ENC_TS_ENC  *)src).patimestamp);
	    }
	} break;
	case 24: {
	    pdVal = (_ETYPE_INFO * *)_oss_dec_const_alloc(_g, sizeof(_ETYPE_INFO *));
	    *(_ETYPE_INFO * *)pdVal = NULL;
	    if (*(_ETYPE_INFO * *)src) {
		_ETYPE_INFO *  s_oss_tmp_1 = *(_ETYPE_INFO * *)src;
		_ETYPE_INFO *  d_oss_tmp_1;

		*(_ETYPE_INFO * *)pdVal = d_oss_tmp_1 = (_ETYPE_INFO *)_oss_dec_getmem_internal(_g, sizeof(_ETYPE_INFO));
		do {
		    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_ETYPE_INFO), s_oss_tmp_1, sizeof(_ETYPE_INFO));
		    {
			if ((s_oss_tmp_1->value).bit_mask & 0x80000000) {
			    _oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).salt), &((d_oss_tmp_1->value).salt), sizeof(((d_oss_tmp_1->value).salt).length), sizeof(((d_oss_tmp_1->value).salt).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).salt).value - (char *)&((s_oss_tmp_1->value).salt)));
			}
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_ETYPE_INFO *)_oss_dec_getmem_internal(_g, sizeof(_ETYPE_INFO));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 25: {
	    pdVal = (_ETYPE_INFO2 * *)_oss_dec_const_alloc(_g, sizeof(_ETYPE_INFO2 *));
	    *(_ETYPE_INFO2 * *)pdVal = NULL;
	    if (*(_ETYPE_INFO2 * *)src) {
		_ETYPE_INFO2 *  s_oss_tmp_1 = *(_ETYPE_INFO2 * *)src;
		_ETYPE_INFO2 *  d_oss_tmp_1;

		*(_ETYPE_INFO2 * *)pdVal = d_oss_tmp_1 = (_ETYPE_INFO2 *)_oss_dec_getmem_internal(_g, sizeof(_ETYPE_INFO2));
		do {
		    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_ETYPE_INFO2), s_oss_tmp_1, sizeof(_ETYPE_INFO2));
		    {
			if ((s_oss_tmp_1->value).bit_mask & 0x80000000) {
			    _oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).salt), &((d_oss_tmp_1->value).salt), sizeof(((d_oss_tmp_1->value).salt).length), sizeof(((d_oss_tmp_1->value).salt).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).salt).value - (char *)&((s_oss_tmp_1->value).salt)));
			}
			if ((s_oss_tmp_1->value).bit_mask & 0x40000000) {
			    _oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).s2kparams), &((d_oss_tmp_1->value).s2kparams), sizeof(((d_oss_tmp_1->value).s2kparams).length), sizeof(((d_oss_tmp_1->value).s2kparams).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).s2kparams).value - (char *)&((s_oss_tmp_1->value).s2kparams)));
			}
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_ETYPE_INFO2 *)_oss_dec_getmem_internal(_g, sizeof(_ETYPE_INFO2));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 26: {
	    pdVal = _cpAuthorizationData(_g, (_AuthorizationData * *)src, (_AuthorizationData * *)pdVal);
	} break;
	case 27: {
	    pdVal = (_AD_KDCIssued  *)_oss_dec_const_alloc(_g, sizeof(_AD_KDCIssued ));
	    OSS_MEMCPY(_g, (_AD_KDCIssued  *)pdVal, sizeof(*(_AD_KDCIssued  *)pdVal), (_AD_KDCIssued  *)src, sizeof(*(_AD_KDCIssued  *)pdVal));
	    {
		_cpChecksum(_g, &((*(_AD_KDCIssued  *)src).ad_checksum), &((*(_AD_KDCIssued  *)pdVal).ad_checksum));
	    }
	    if ((*(_AD_KDCIssued  *)src).bit_mask & 0x80000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_AD_KDCIssued  *)src).i_realm), &((*(_AD_KDCIssued  *)pdVal).i_realm), sizeof(((*(_AD_KDCIssued  *)pdVal).i_realm).length), sizeof(((*(_AD_KDCIssued  *)pdVal).i_realm).value[0]), (unsigned int)((char *)&((*(_AD_KDCIssued  *)src).i_realm).value - (char *)&((*(_AD_KDCIssued  *)src).i_realm)));
	    }
	    if ((*(_AD_KDCIssued  *)src).bit_mask & 0x40000000) {
		_cpPrincipalName(_g, &((*(_AD_KDCIssued  *)src).i_sname), &((*(_AD_KDCIssued  *)pdVal).i_sname));
	    }
	    {
		_cpAuthorizationData(_g, &((*(_AD_KDCIssued  *)src).elements), &((*(_AD_KDCIssued  *)pdVal).elements));
	    }
	} break;
	case 28: {
	    pdVal = (_AD_AND_OR  *)_oss_dec_const_alloc(_g, sizeof(_AD_AND_OR ));
	    OSS_MEMCPY(_g, (_AD_AND_OR  *)pdVal, sizeof(*(_AD_AND_OR  *)pdVal), (_AD_AND_OR  *)src, sizeof(*(_AD_AND_OR  *)pdVal));
	    {
		_cpAuthorizationData(_g, &((*(_AD_AND_OR  *)src).elements), &((*(_AD_AND_OR  *)pdVal).elements));
	    }
	} break;
	case 29: {
	    pdVal = _cpAuthorizationData(_g, (_AuthorizationData * *)src, (_AuthorizationData * *)pdVal);
	} break;
	case 30: {
	    pdVal = (_ChangePasswdData  *)_oss_dec_const_alloc(_g, sizeof(_ChangePasswdData ));
	    OSS_MEMCPY(_g, (_ChangePasswdData  *)pdVal, sizeof(*(_ChangePasswdData  *)pdVal), (_ChangePasswdData  *)src, sizeof(*(_ChangePasswdData  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_ChangePasswdData  *)src).newpasswd), &((*(_ChangePasswdData  *)pdVal).newpasswd), sizeof(((*(_ChangePasswdData  *)pdVal).newpasswd).length), sizeof(((*(_ChangePasswdData  *)pdVal).newpasswd).value[0]), (unsigned int)((char *)&((*(_ChangePasswdData  *)src).newpasswd).value - (char *)&((*(_ChangePasswdData  *)src).newpasswd)));
	    }
	    if ((*(_ChangePasswdData  *)src).bit_mask & 0x80000000) {
		_cpPrincipalName(_g, &((*(_ChangePasswdData  *)src).targname), &((*(_ChangePasswdData  *)pdVal).targname));
	    }
	    if ((*(_ChangePasswdData  *)src).bit_mask & 0x40000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_ChangePasswdData  *)src).targrealm), &((*(_ChangePasswdData  *)pdVal).targrealm), sizeof(((*(_ChangePasswdData  *)pdVal).targrealm).length), sizeof(((*(_ChangePasswdData  *)pdVal).targrealm).value[0]), (unsigned int)((char *)&((*(_ChangePasswdData  *)src).targrealm).value - (char *)&((*(_ChangePasswdData  *)src).targrealm)));
	    }
	} break;
	case 31: {
	    pdVal = (_PA_PK_AS_REQ  *)_oss_dec_const_alloc(_g, sizeof(_PA_PK_AS_REQ ));
	    OSS_MEMCPY(_g, (_PA_PK_AS_REQ  *)pdVal, sizeof(*(_PA_PK_AS_REQ  *)pdVal), (_PA_PK_AS_REQ  *)src, sizeof(*(_PA_PK_AS_REQ  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PA_PK_AS_REQ  *)src).signedAuthPack), &((*(_PA_PK_AS_REQ  *)pdVal).signedAuthPack), sizeof(((*(_PA_PK_AS_REQ  *)pdVal).signedAuthPack).length), sizeof(((*(_PA_PK_AS_REQ  *)pdVal).signedAuthPack).value[0]), (unsigned int)((char *)&((*(_PA_PK_AS_REQ  *)src).signedAuthPack).value - (char *)&((*(_PA_PK_AS_REQ  *)src).signedAuthPack)));
	    }
	    if ((*(_PA_PK_AS_REQ  *)src).bit_mask & 0x80000000) {
		(*(_PA_PK_AS_REQ  *)pdVal).trustedCertifiers = NULL;
		if ((*(_PA_PK_AS_REQ  *)src).trustedCertifiers) {
		    _seqof9 *  s_oss_tmp_2 = (*(_PA_PK_AS_REQ  *)src).trustedCertifiers;
		    _seqof9 *  d_oss_tmp_2;

		    (*(_PA_PK_AS_REQ  *)pdVal).trustedCertifiers = d_oss_tmp_2 = (_seqof9 *)_oss_dec_getmem_internal(_g, sizeof(_seqof9));
		    do {
			OSS_MEMCPY(_g, d_oss_tmp_2,  sizeof(_seqof9), s_oss_tmp_2, sizeof(_seqof9));
			{
			    _cpExternalPrincipalIdentifier(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof9 *)_oss_dec_getmem_internal(_g, sizeof(_seqof9));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_PA_PK_AS_REQ  *)src).bit_mask & 0x40000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PA_PK_AS_REQ  *)src).kdcPkId), &((*(_PA_PK_AS_REQ  *)pdVal).kdcPkId), sizeof(((*(_PA_PK_AS_REQ  *)pdVal).kdcPkId).length), sizeof(((*(_PA_PK_AS_REQ  *)pdVal).kdcPkId).value[0]), (unsigned int)((char *)&((*(_PA_PK_AS_REQ  *)src).kdcPkId).value - (char *)&((*(_PA_PK_AS_REQ  *)src).kdcPkId)));
	    }
	} break;
	case 32: {
	    pdVal = (_AuthPack  *)_oss_dec_const_alloc(_g, sizeof(_AuthPack ));
	    OSS_MEMCPY(_g, (_AuthPack  *)pdVal, sizeof(*(_AuthPack  *)pdVal), (_AuthPack  *)src, sizeof(*(_AuthPack  *)pdVal));
	    {
		{
		    size_t  len_2 = (size_t)sizeof(char) * (OSS_STRNLEN(((*(_AuthPack  *)src).pkAuthenticator).ctime, OSS_MAX_STR) + 1);

		    ((*(_AuthPack  *)pdVal).pkAuthenticator).ctime = (char * )_oss_dec_getmem_internal(_g, (long)len_2);
		    OSS_STRCPY(_g, ((*(_AuthPack  *)pdVal).pkAuthenticator).ctime, (long)len_2, ((*(_AuthPack  *)src).pkAuthenticator).ctime);
		}
		if (((*(_AuthPack  *)src).pkAuthenticator).bit_mask & 0x80000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_AuthPack  *)src).pkAuthenticator).paChecksum), &(((*(_AuthPack  *)pdVal).pkAuthenticator).paChecksum), sizeof((((*(_AuthPack  *)pdVal).pkAuthenticator).paChecksum).length), sizeof((((*(_AuthPack  *)pdVal).pkAuthenticator).paChecksum).value[0]), (unsigned int)((char *)&(((*(_AuthPack  *)src).pkAuthenticator).paChecksum).value - (char *)&(((*(_AuthPack  *)src).pkAuthenticator).paChecksum)));
		}
	    }
	    if ((*(_AuthPack  *)src).bit_mask & 0x80000000) {
		_cpSubjectPublicKeyInfo(_g, &((*(_AuthPack  *)src).clientPublicValue), &((*(_AuthPack  *)pdVal).clientPublicValue));
	    }
	    if ((*(_AuthPack  *)src).bit_mask & 0x40000000) {
		(*(_AuthPack  *)pdVal).supportedCMSTypes = NULL;
		if ((*(_AuthPack  *)src).supportedCMSTypes) {
		    _seqof10 *  s_oss_tmp_2 = (*(_AuthPack  *)src).supportedCMSTypes;
		    _seqof10 *  d_oss_tmp_2;

		    (*(_AuthPack  *)pdVal).supportedCMSTypes = d_oss_tmp_2 = (_seqof10 *)_oss_dec_getmem_internal(_g, sizeof(_seqof10));
		    do {
			OSS_MEMCPY(_g, d_oss_tmp_2,  sizeof(_seqof10), s_oss_tmp_2, sizeof(_seqof10));
			{
			    _cpAlgorithmIdentifier(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof10 *)_oss_dec_getmem_internal(_g, sizeof(_seqof10));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_AuthPack  *)src).bit_mask & 0x20000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_AuthPack  *)src).clientDHNonce), &((*(_AuthPack  *)pdVal).clientDHNonce), sizeof(((*(_AuthPack  *)pdVal).clientDHNonce).length), sizeof(((*(_AuthPack  *)pdVal).clientDHNonce).value[0]), (unsigned int)((char *)&((*(_AuthPack  *)src).clientDHNonce).value - (char *)&((*(_AuthPack  *)src).clientDHNonce)));
	    }
	} break;
	case 33: {
	    pdVal = (_seqof9 * *)_oss_dec_const_alloc(_g, sizeof(_seqof9 *));
	    *(_seqof9 * *)pdVal = NULL;
	    if (*(_seqof9 * *)src) {
		_seqof9 *  s_oss_tmp_1 = *(_seqof9 * *)src;
		_seqof9 *  d_oss_tmp_1;

		*(_seqof9 * *)pdVal = d_oss_tmp_1 = (_seqof9 *)_oss_dec_getmem_internal(_g, sizeof(_seqof9));
		do {
		    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof9), s_oss_tmp_1, sizeof(_seqof9));
		    {
			_cpExternalPrincipalIdentifier(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_seqof9 *)_oss_dec_getmem_internal(_g, sizeof(_seqof9));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 34: {
	    pdVal = (_seqof9 * *)_oss_dec_const_alloc(_g, sizeof(_seqof9 *));
	    *(_seqof9 * *)pdVal = NULL;
	    if (*(_seqof9 * *)src) {
		_seqof9 *  s_oss_tmp_1 = *(_seqof9 * *)src;
		_seqof9 *  d_oss_tmp_1;

		*(_seqof9 * *)pdVal = d_oss_tmp_1 = (_seqof9 *)_oss_dec_getmem_internal(_g, sizeof(_seqof9));
		do {
		    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof9), s_oss_tmp_1, sizeof(_seqof9));
		    {
			_cpExternalPrincipalIdentifier(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_seqof9 *)_oss_dec_getmem_internal(_g, sizeof(_seqof9));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 35: {
	    pdVal = (_KRB5PrincipalName  *)_oss_dec_const_alloc(_g, sizeof(_KRB5PrincipalName ));
	    OSS_MEMCPY(_g, (_KRB5PrincipalName  *)pdVal, sizeof(*(_KRB5PrincipalName  *)pdVal), (_KRB5PrincipalName  *)src, sizeof(*(_KRB5PrincipalName  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_KRB5PrincipalName  *)src).realm), &((*(_KRB5PrincipalName  *)pdVal).realm), sizeof(((*(_KRB5PrincipalName  *)pdVal).realm).length), sizeof(((*(_KRB5PrincipalName  *)pdVal).realm).value[0]), (unsigned int)((char *)&((*(_KRB5PrincipalName  *)src).realm).value - (char *)&((*(_KRB5PrincipalName  *)src).realm)));
	    }
	    {
		_cpPrincipalName(_g, &((*(_KRB5PrincipalName  *)src).principalName), &((*(_KRB5PrincipalName  *)pdVal).principalName));
	    }
	} break;
	case 36: {
	    pdVal = (_seqof9 * *)_oss_dec_const_alloc(_g, sizeof(_seqof9 *));
	    *(_seqof9 * *)pdVal = NULL;
	    if (*(_seqof9 * *)src) {
		_seqof9 *  s_oss_tmp_1 = *(_seqof9 * *)src;
		_seqof9 *  d_oss_tmp_1;

		*(_seqof9 * *)pdVal = d_oss_tmp_1 = (_seqof9 *)_oss_dec_getmem_internal(_g, sizeof(_seqof9));
		do {
		    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof9), s_oss_tmp_1, sizeof(_seqof9));
		    {
			_cpExternalPrincipalIdentifier(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_seqof9 *)_oss_dec_getmem_internal(_g, sizeof(_seqof9));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 37: {
	    pdVal = (_PA_PK_AS_REP  *)_oss_dec_const_alloc(_g, sizeof(_PA_PK_AS_REP ));
	    OSS_MEMCPY(_g, (_PA_PK_AS_REP  *)pdVal, sizeof(*(_PA_PK_AS_REP  *)pdVal), (_PA_PK_AS_REP  *)src, sizeof(*(_PA_PK_AS_REP  *)pdVal));
	    switch ((*(_PA_PK_AS_REP  *)src).choice) {
		case 1: {
		    (*(_PA_PK_AS_REP  *)pdVal).u.dhInfo = (_DHRepInfo  *)_oss_dec_const_alloc(_g, sizeof(_DHRepInfo ));
		    OSS_MEMCPY(_g, (*(_PA_PK_AS_REP  *)pdVal).u.dhInfo, sizeof(*(*(_PA_PK_AS_REP  *)pdVal).u.dhInfo), (*(_PA_PK_AS_REP  *)src).u.dhInfo, sizeof(*(*(_PA_PK_AS_REP  *)pdVal).u.dhInfo));
		    {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_PA_PK_AS_REP  *)src).u.dhInfo).dhSignedData), &((*(*(_PA_PK_AS_REP  *)pdVal).u.dhInfo).dhSignedData), sizeof(((*(*(_PA_PK_AS_REP  *)pdVal).u.dhInfo).dhSignedData).length), sizeof(((*(*(_PA_PK_AS_REP  *)pdVal).u.dhInfo).dhSignedData).value[0]), (unsigned int)((char *)&((*(*(_PA_PK_AS_REP  *)src).u.dhInfo).dhSignedData).value - (char *)&((*(*(_PA_PK_AS_REP  *)src).u.dhInfo).dhSignedData)));
		    }
		    if ((*(*(_PA_PK_AS_REP  *)src).u.dhInfo).bit_mask & 0x80000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_PA_PK_AS_REP  *)src).u.dhInfo).serverDHNonce), &((*(*(_PA_PK_AS_REP  *)pdVal).u.dhInfo).serverDHNonce), sizeof(((*(*(_PA_PK_AS_REP  *)pdVal).u.dhInfo).serverDHNonce).length), sizeof(((*(*(_PA_PK_AS_REP  *)pdVal).u.dhInfo).serverDHNonce).value[0]), (unsigned int)((char *)&((*(*(_PA_PK_AS_REP  *)src).u.dhInfo).serverDHNonce).value - (char *)&((*(*(_PA_PK_AS_REP  *)src).u.dhInfo).serverDHNonce)));
		    }
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_PA_PK_AS_REP  *)src).u.encKeyPack), &((*(_PA_PK_AS_REP  *)pdVal).u.encKeyPack), sizeof(((*(_PA_PK_AS_REP  *)pdVal).u.encKeyPack).length), sizeof(((*(_PA_PK_AS_REP  *)pdVal).u.encKeyPack).value[0]), (unsigned int)((char *)&((*(_PA_PK_AS_REP  *)src).u.encKeyPack).value - (char *)&((*(_PA_PK_AS_REP  *)src).u.encKeyPack)));
		}   break;
		default:;
	    }
	} break;
	case 38: {
	    pdVal = (_KDCDHKeyInfo  *)_oss_dec_const_alloc(_g, sizeof(_KDCDHKeyInfo ));
	    OSS_MEMCPY(_g, (_KDCDHKeyInfo  *)pdVal, sizeof(*(_KDCDHKeyInfo  *)pdVal), (_KDCDHKeyInfo  *)src, sizeof(*(_KDCDHKeyInfo  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_KDCDHKeyInfo  *)src).subjectPublicKey), &((*(_KDCDHKeyInfo  *)pdVal).subjectPublicKey), sizeof(((*(_KDCDHKeyInfo  *)pdVal).subjectPublicKey).length), -1L, (unsigned int)((char *)&((*(_KDCDHKeyInfo  *)src).subjectPublicKey).value - (char *)&((*(_KDCDHKeyInfo  *)src).subjectPublicKey)));
	    }
	    if ((*(_KDCDHKeyInfo  *)src).dhKeyExpiration) {
		size_t  len_1 = (size_t)sizeof(char) * (OSS_STRNLEN((*(_KDCDHKeyInfo  *)src).dhKeyExpiration, OSS_MAX_STR) + 1);

		(*(_KDCDHKeyInfo  *)pdVal).dhKeyExpiration = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		OSS_STRCPY(_g, (*(_KDCDHKeyInfo  *)pdVal).dhKeyExpiration, (long)len_1, (*(_KDCDHKeyInfo  *)src).dhKeyExpiration);
	    }
	} break;
	case 39: {
	    pdVal = (_ReplyKeyPack  *)_oss_dec_const_alloc(_g, sizeof(_ReplyKeyPack ));
	    OSS_MEMCPY(_g, (_ReplyKeyPack  *)pdVal, sizeof(*(_ReplyKeyPack  *)pdVal), (_ReplyKeyPack  *)src, sizeof(*(_ReplyKeyPack  *)pdVal));
	    {
		_cpEncryptionKey(_g, &((*(_ReplyKeyPack  *)src).replyKey), &((*(_ReplyKeyPack  *)pdVal).replyKey));
	    }
	    {
		_cpChecksum(_g, &((*(_ReplyKeyPack  *)src).asChecksum), &((*(_ReplyKeyPack  *)pdVal).asChecksum));
	    }
	} break;
	case 40: {
	    pdVal = (_seqof10 * *)_oss_dec_const_alloc(_g, sizeof(_seqof10 *));
	    *(_seqof10 * *)pdVal = NULL;
	    if (*(_seqof10 * *)src) {
		_seqof10 *  s_oss_tmp_1 = *(_seqof10 * *)src;
		_seqof10 *  d_oss_tmp_1;

		*(_seqof10 * *)pdVal = d_oss_tmp_1 = (_seqof10 *)_oss_dec_getmem_internal(_g, sizeof(_seqof10));
		do {
		    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof10), s_oss_tmp_1, sizeof(_seqof10));
		    {
			_cpAlgorithmIdentifier(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_seqof10 *)_oss_dec_getmem_internal(_g, sizeof(_seqof10));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 41: {
	    pdVal = (_Attribute  *)_oss_dec_const_alloc(_g, sizeof(_Attribute ));
	    OSS_MEMCPY(_g, (_Attribute  *)pdVal, sizeof(*(_Attribute  *)pdVal), (_Attribute  *)src, sizeof(*(_Attribute  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_Attribute  *)src).type), &((*(_Attribute  *)pdVal).type), sizeof(((*(_Attribute  *)pdVal).type).length), sizeof(((*(_Attribute  *)pdVal).type).value[0]), (unsigned int)((char *)&((*(_Attribute  *)src).type).value - (char *)&((*(_Attribute  *)src).type)));
	    }
	    {
		(*(_Attribute  *)pdVal).values = NULL;
		if ((*(_Attribute  *)src).values) {
		    _seqof1 *  s_oss_tmp_2 = (*(_Attribute  *)src).values;
		    _seqof1 *  d_oss_tmp_2;

		    (*(_Attribute  *)pdVal).values = d_oss_tmp_2 = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
		    do {
			OSS_MEMCPY(_g, d_oss_tmp_2,  sizeof(_seqof1), s_oss_tmp_2, sizeof(_seqof1));
			{
			    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 42: {
	    pdVal = (_X520name  *)_oss_dec_const_alloc(_g, sizeof(_X520name ));
	    OSS_MEMCPY(_g, (_X520name  *)pdVal, sizeof(*(_X520name  *)pdVal), (_X520name  *)src, sizeof(*(_X520name  *)pdVal));
	    switch ((*(_X520name  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.teletexString), &((*(_X520name  *)pdVal).u.teletexString), sizeof(((*(_X520name  *)pdVal).u.teletexString).length), sizeof(((*(_X520name  *)pdVal).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.teletexString).value - (char *)&((*(_X520name  *)src).u.teletexString)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.printableString), &((*(_X520name  *)pdVal).u.printableString), sizeof(((*(_X520name  *)pdVal).u.printableString).length), sizeof(((*(_X520name  *)pdVal).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.printableString).value - (char *)&((*(_X520name  *)src).u.printableString)));
		}   break;
		case 3: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.universalString), &((*(_X520name  *)pdVal).u.universalString), sizeof(((*(_X520name  *)pdVal).u.universalString).length), sizeof(((*(_X520name  *)pdVal).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.universalString).value - (char *)&((*(_X520name  *)src).u.universalString)));
		}   break;
		case 4: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.utf8String), &((*(_X520name  *)pdVal).u.utf8String), sizeof(((*(_X520name  *)pdVal).u.utf8String).length), sizeof(((*(_X520name  *)pdVal).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.utf8String).value - (char *)&((*(_X520name  *)src).u.utf8String)));
		}   break;
		case 5: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.bmpString), &((*(_X520name  *)pdVal).u.bmpString), sizeof(((*(_X520name  *)pdVal).u.bmpString).length), sizeof(((*(_X520name  *)pdVal).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.bmpString).value - (char *)&((*(_X520name  *)src).u.bmpString)));
		}   break;
		default:;
	    }
	} break;
	case 43: {
	    pdVal = (_X520name  *)_oss_dec_const_alloc(_g, sizeof(_X520name ));
	    OSS_MEMCPY(_g, (_X520name  *)pdVal, sizeof(*(_X520name  *)pdVal), (_X520name  *)src, sizeof(*(_X520name  *)pdVal));
	    switch ((*(_X520name  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.teletexString), &((*(_X520name  *)pdVal).u.teletexString), sizeof(((*(_X520name  *)pdVal).u.teletexString).length), sizeof(((*(_X520name  *)pdVal).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.teletexString).value - (char *)&((*(_X520name  *)src).u.teletexString)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.printableString), &((*(_X520name  *)pdVal).u.printableString), sizeof(((*(_X520name  *)pdVal).u.printableString).length), sizeof(((*(_X520name  *)pdVal).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.printableString).value - (char *)&((*(_X520name  *)src).u.printableString)));
		}   break;
		case 3: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.universalString), &((*(_X520name  *)pdVal).u.universalString), sizeof(((*(_X520name  *)pdVal).u.universalString).length), sizeof(((*(_X520name  *)pdVal).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.universalString).value - (char *)&((*(_X520name  *)src).u.universalString)));
		}   break;
		case 4: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.utf8String), &((*(_X520name  *)pdVal).u.utf8String), sizeof(((*(_X520name  *)pdVal).u.utf8String).length), sizeof(((*(_X520name  *)pdVal).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.utf8String).value - (char *)&((*(_X520name  *)src).u.utf8String)));
		}   break;
		case 5: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.bmpString), &((*(_X520name  *)pdVal).u.bmpString), sizeof(((*(_X520name  *)pdVal).u.bmpString).length), sizeof(((*(_X520name  *)pdVal).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.bmpString).value - (char *)&((*(_X520name  *)src).u.bmpString)));
		}   break;
		default:;
	    }
	} break;
	case 44: {
	    pdVal = (_X520name  *)_oss_dec_const_alloc(_g, sizeof(_X520name ));
	    OSS_MEMCPY(_g, (_X520name  *)pdVal, sizeof(*(_X520name  *)pdVal), (_X520name  *)src, sizeof(*(_X520name  *)pdVal));
	    switch ((*(_X520name  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.teletexString), &((*(_X520name  *)pdVal).u.teletexString), sizeof(((*(_X520name  *)pdVal).u.teletexString).length), sizeof(((*(_X520name  *)pdVal).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.teletexString).value - (char *)&((*(_X520name  *)src).u.teletexString)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.printableString), &((*(_X520name  *)pdVal).u.printableString), sizeof(((*(_X520name  *)pdVal).u.printableString).length), sizeof(((*(_X520name  *)pdVal).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.printableString).value - (char *)&((*(_X520name  *)src).u.printableString)));
		}   break;
		case 3: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.universalString), &((*(_X520name  *)pdVal).u.universalString), sizeof(((*(_X520name  *)pdVal).u.universalString).length), sizeof(((*(_X520name  *)pdVal).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.universalString).value - (char *)&((*(_X520name  *)src).u.universalString)));
		}   break;
		case 4: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.utf8String), &((*(_X520name  *)pdVal).u.utf8String), sizeof(((*(_X520name  *)pdVal).u.utf8String).length), sizeof(((*(_X520name  *)pdVal).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.utf8String).value - (char *)&((*(_X520name  *)src).u.utf8String)));
		}   break;
		case 5: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.bmpString), &((*(_X520name  *)pdVal).u.bmpString), sizeof(((*(_X520name  *)pdVal).u.bmpString).length), sizeof(((*(_X520name  *)pdVal).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.bmpString).value - (char *)&((*(_X520name  *)src).u.bmpString)));
		}   break;
		default:;
	    }
	} break;
	case 45: {
	    pdVal = (_X520name  *)_oss_dec_const_alloc(_g, sizeof(_X520name ));
	    OSS_MEMCPY(_g, (_X520name  *)pdVal, sizeof(*(_X520name  *)pdVal), (_X520name  *)src, sizeof(*(_X520name  *)pdVal));
	    switch ((*(_X520name  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.teletexString), &((*(_X520name  *)pdVal).u.teletexString), sizeof(((*(_X520name  *)pdVal).u.teletexString).length), sizeof(((*(_X520name  *)pdVal).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.teletexString).value - (char *)&((*(_X520name  *)src).u.teletexString)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.printableString), &((*(_X520name  *)pdVal).u.printableString), sizeof(((*(_X520name  *)pdVal).u.printableString).length), sizeof(((*(_X520name  *)pdVal).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.printableString).value - (char *)&((*(_X520name  *)src).u.printableString)));
		}   break;
		case 3: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.universalString), &((*(_X520name  *)pdVal).u.universalString), sizeof(((*(_X520name  *)pdVal).u.universalString).length), sizeof(((*(_X520name  *)pdVal).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.universalString).value - (char *)&((*(_X520name  *)src).u.universalString)));
		}   break;
		case 4: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.utf8String), &((*(_X520name  *)pdVal).u.utf8String), sizeof(((*(_X520name  *)pdVal).u.utf8String).length), sizeof(((*(_X520name  *)pdVal).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.utf8String).value - (char *)&((*(_X520name  *)src).u.utf8String)));
		}   break;
		case 5: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.bmpString), &((*(_X520name  *)pdVal).u.bmpString), sizeof(((*(_X520name  *)pdVal).u.bmpString).length), sizeof(((*(_X520name  *)pdVal).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.bmpString).value - (char *)&((*(_X520name  *)src).u.bmpString)));
		}   break;
		default:;
	    }
	} break;
	case 46: {
	    pdVal = (_X520name  *)_oss_dec_const_alloc(_g, sizeof(_X520name ));
	    OSS_MEMCPY(_g, (_X520name  *)pdVal, sizeof(*(_X520name  *)pdVal), (_X520name  *)src, sizeof(*(_X520name  *)pdVal));
	    switch ((*(_X520name  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.teletexString), &((*(_X520name  *)pdVal).u.teletexString), sizeof(((*(_X520name  *)pdVal).u.teletexString).length), sizeof(((*(_X520name  *)pdVal).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.teletexString).value - (char *)&((*(_X520name  *)src).u.teletexString)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.printableString), &((*(_X520name  *)pdVal).u.printableString), sizeof(((*(_X520name  *)pdVal).u.printableString).length), sizeof(((*(_X520name  *)pdVal).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.printableString).value - (char *)&((*(_X520name  *)src).u.printableString)));
		}   break;
		case 3: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.universalString), &((*(_X520name  *)pdVal).u.universalString), sizeof(((*(_X520name  *)pdVal).u.universalString).length), sizeof(((*(_X520name  *)pdVal).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.universalString).value - (char *)&((*(_X520name  *)src).u.universalString)));
		}   break;
		case 4: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.utf8String), &((*(_X520name  *)pdVal).u.utf8String), sizeof(((*(_X520name  *)pdVal).u.utf8String).length), sizeof(((*(_X520name  *)pdVal).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.utf8String).value - (char *)&((*(_X520name  *)src).u.utf8String)));
		}   break;
		case 5: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.bmpString), &((*(_X520name  *)pdVal).u.bmpString), sizeof(((*(_X520name  *)pdVal).u.bmpString).length), sizeof(((*(_X520name  *)pdVal).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.bmpString).value - (char *)&((*(_X520name  *)src).u.bmpString)));
		}   break;
		default:;
	    }
	} break;
	case 47: {
	    pdVal = (_X520name  *)_oss_dec_const_alloc(_g, sizeof(_X520name ));
	    OSS_MEMCPY(_g, (_X520name  *)pdVal, sizeof(*(_X520name  *)pdVal), (_X520name  *)src, sizeof(*(_X520name  *)pdVal));
	    switch ((*(_X520name  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.teletexString), &((*(_X520name  *)pdVal).u.teletexString), sizeof(((*(_X520name  *)pdVal).u.teletexString).length), sizeof(((*(_X520name  *)pdVal).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.teletexString).value - (char *)&((*(_X520name  *)src).u.teletexString)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.printableString), &((*(_X520name  *)pdVal).u.printableString), sizeof(((*(_X520name  *)pdVal).u.printableString).length), sizeof(((*(_X520name  *)pdVal).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.printableString).value - (char *)&((*(_X520name  *)src).u.printableString)));
		}   break;
		case 3: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.universalString), &((*(_X520name  *)pdVal).u.universalString), sizeof(((*(_X520name  *)pdVal).u.universalString).length), sizeof(((*(_X520name  *)pdVal).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.universalString).value - (char *)&((*(_X520name  *)src).u.universalString)));
		}   break;
		case 4: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.utf8String), &((*(_X520name  *)pdVal).u.utf8String), sizeof(((*(_X520name  *)pdVal).u.utf8String).length), sizeof(((*(_X520name  *)pdVal).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.utf8String).value - (char *)&((*(_X520name  *)src).u.utf8String)));
		}   break;
		case 5: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.bmpString), &((*(_X520name  *)pdVal).u.bmpString), sizeof(((*(_X520name  *)pdVal).u.bmpString).length), sizeof(((*(_X520name  *)pdVal).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.bmpString).value - (char *)&((*(_X520name  *)src).u.bmpString)));
		}   break;
		default:;
	    }
	} break;
	case 48: {
	    pdVal = (_X520name  *)_oss_dec_const_alloc(_g, sizeof(_X520name ));
	    OSS_MEMCPY(_g, (_X520name  *)pdVal, sizeof(*(_X520name  *)pdVal), (_X520name  *)src, sizeof(*(_X520name  *)pdVal));
	    switch ((*(_X520name  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.teletexString), &((*(_X520name  *)pdVal).u.teletexString), sizeof(((*(_X520name  *)pdVal).u.teletexString).length), sizeof(((*(_X520name  *)pdVal).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.teletexString).value - (char *)&((*(_X520name  *)src).u.teletexString)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.printableString), &((*(_X520name  *)pdVal).u.printableString), sizeof(((*(_X520name  *)pdVal).u.printableString).length), sizeof(((*(_X520name  *)pdVal).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.printableString).value - (char *)&((*(_X520name  *)src).u.printableString)));
		}   break;
		case 3: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.universalString), &((*(_X520name  *)pdVal).u.universalString), sizeof(((*(_X520name  *)pdVal).u.universalString).length), sizeof(((*(_X520name  *)pdVal).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.universalString).value - (char *)&((*(_X520name  *)src).u.universalString)));
		}   break;
		case 4: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.utf8String), &((*(_X520name  *)pdVal).u.utf8String), sizeof(((*(_X520name  *)pdVal).u.utf8String).length), sizeof(((*(_X520name  *)pdVal).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.utf8String).value - (char *)&((*(_X520name  *)src).u.utf8String)));
		}   break;
		case 5: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.bmpString), &((*(_X520name  *)pdVal).u.bmpString), sizeof(((*(_X520name  *)pdVal).u.bmpString).length), sizeof(((*(_X520name  *)pdVal).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.bmpString).value - (char *)&((*(_X520name  *)src).u.bmpString)));
		}   break;
		default:;
	    }
	} break;
	case 49: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 50: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 51: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 52: {
	    pdVal = (_X520name  *)_oss_dec_const_alloc(_g, sizeof(_X520name ));
	    OSS_MEMCPY(_g, (_X520name  *)pdVal, sizeof(*(_X520name  *)pdVal), (_X520name  *)src, sizeof(*(_X520name  *)pdVal));
	    switch ((*(_X520name  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.teletexString), &((*(_X520name  *)pdVal).u.teletexString), sizeof(((*(_X520name  *)pdVal).u.teletexString).length), sizeof(((*(_X520name  *)pdVal).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.teletexString).value - (char *)&((*(_X520name  *)src).u.teletexString)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.printableString), &((*(_X520name  *)pdVal).u.printableString), sizeof(((*(_X520name  *)pdVal).u.printableString).length), sizeof(((*(_X520name  *)pdVal).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.printableString).value - (char *)&((*(_X520name  *)src).u.printableString)));
		}   break;
		case 3: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.universalString), &((*(_X520name  *)pdVal).u.universalString), sizeof(((*(_X520name  *)pdVal).u.universalString).length), sizeof(((*(_X520name  *)pdVal).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.universalString).value - (char *)&((*(_X520name  *)src).u.universalString)));
		}   break;
		case 4: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.utf8String), &((*(_X520name  *)pdVal).u.utf8String), sizeof(((*(_X520name  *)pdVal).u.utf8String).length), sizeof(((*(_X520name  *)pdVal).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.utf8String).value - (char *)&((*(_X520name  *)src).u.utf8String)));
		}   break;
		case 5: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.bmpString), &((*(_X520name  *)pdVal).u.bmpString), sizeof(((*(_X520name  *)pdVal).u.bmpString).length), sizeof(((*(_X520name  *)pdVal).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.bmpString).value - (char *)&((*(_X520name  *)src).u.bmpString)));
		}   break;
		default:;
	    }
	} break;
	case 53: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 54: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 55: {
	    pdVal = _cpRDNSequence(_g, (_RDNSequence * *)src, (_RDNSequence * *)pdVal);
	} break;
	case 56: {
	    pdVal = (_X520name  *)_oss_dec_const_alloc(_g, sizeof(_X520name ));
	    OSS_MEMCPY(_g, (_X520name  *)pdVal, sizeof(*(_X520name  *)pdVal), (_X520name  *)src, sizeof(*(_X520name  *)pdVal));
	    switch ((*(_X520name  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.teletexString), &((*(_X520name  *)pdVal).u.teletexString), sizeof(((*(_X520name  *)pdVal).u.teletexString).length), sizeof(((*(_X520name  *)pdVal).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.teletexString).value - (char *)&((*(_X520name  *)src).u.teletexString)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.printableString), &((*(_X520name  *)pdVal).u.printableString), sizeof(((*(_X520name  *)pdVal).u.printableString).length), sizeof(((*(_X520name  *)pdVal).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.printableString).value - (char *)&((*(_X520name  *)src).u.printableString)));
		}   break;
		case 3: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.universalString), &((*(_X520name  *)pdVal).u.universalString), sizeof(((*(_X520name  *)pdVal).u.universalString).length), sizeof(((*(_X520name  *)pdVal).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.universalString).value - (char *)&((*(_X520name  *)src).u.universalString)));
		}   break;
		case 4: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.utf8String), &((*(_X520name  *)pdVal).u.utf8String), sizeof(((*(_X520name  *)pdVal).u.utf8String).length), sizeof(((*(_X520name  *)pdVal).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.utf8String).value - (char *)&((*(_X520name  *)src).u.utf8String)));
		}   break;
		case 5: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_X520name  *)src).u.bmpString), &((*(_X520name  *)pdVal).u.bmpString), sizeof(((*(_X520name  *)pdVal).u.bmpString).length), sizeof(((*(_X520name  *)pdVal).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)src).u.bmpString).value - (char *)&((*(_X520name  *)src).u.bmpString)));
		}   break;
		default:;
	    }
	} break;
	case 57: {
	    pdVal = (_Certificate  *)_oss_dec_const_alloc(_g, sizeof(_Certificate ));
	    OSS_MEMCPY(_g, (_Certificate  *)pdVal, sizeof(*(_Certificate  *)pdVal), (_Certificate  *)src, sizeof(*(_Certificate  *)pdVal));
	    {
		{
		    _cpAlgorithmIdentifier(_g, &(((*(_Certificate  *)src).tbsCertificate).signature), &(((*(_Certificate  *)pdVal).tbsCertificate).signature));
		}
		{
		    _cpName(_g, &(((*(_Certificate  *)src).tbsCertificate).issuer), &(((*(_Certificate  *)pdVal).tbsCertificate).issuer));
		}
		{
		    {
			_cpTime(_g, &((((*(_Certificate  *)src).tbsCertificate).validity).notBefore), &((((*(_Certificate  *)pdVal).tbsCertificate).validity).notBefore));
		    }
		    {
			_cpTime(_g, &((((*(_Certificate  *)src).tbsCertificate).validity).notAfter), &((((*(_Certificate  *)pdVal).tbsCertificate).validity).notAfter));
		    }
		}
		{
		    _cpName(_g, &(((*(_Certificate  *)src).tbsCertificate).subject), &(((*(_Certificate  *)pdVal).tbsCertificate).subject));
		}
		{
		    _cpSubjectPublicKeyInfo(_g, &(((*(_Certificate  *)src).tbsCertificate).subjectPublicKeyInfo), &(((*(_Certificate  *)pdVal).tbsCertificate).subjectPublicKeyInfo));
		}
		if (((*(_Certificate  *)src).tbsCertificate).bit_mask & 0x40000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_Certificate  *)src).tbsCertificate).issuerUniqueID), &(((*(_Certificate  *)pdVal).tbsCertificate).issuerUniqueID), sizeof((((*(_Certificate  *)pdVal).tbsCertificate).issuerUniqueID).length), -1L, (unsigned int)((char *)&(((*(_Certificate  *)src).tbsCertificate).issuerUniqueID).value - (char *)&(((*(_Certificate  *)src).tbsCertificate).issuerUniqueID)));
		}
		if (((*(_Certificate  *)src).tbsCertificate).bit_mask & 0x20000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_Certificate  *)src).tbsCertificate).subjectUniqueID), &(((*(_Certificate  *)pdVal).tbsCertificate).subjectUniqueID), sizeof((((*(_Certificate  *)pdVal).tbsCertificate).subjectUniqueID).length), -1L, (unsigned int)((char *)&(((*(_Certificate  *)src).tbsCertificate).subjectUniqueID).value - (char *)&(((*(_Certificate  *)src).tbsCertificate).subjectUniqueID)));
		}
		if (((*(_Certificate  *)src).tbsCertificate).bit_mask & 0x10000000) {
		    _cpExtensions(_g, &(((*(_Certificate  *)src).tbsCertificate).extensions), &(((*(_Certificate  *)pdVal).tbsCertificate).extensions));
		}
	    }
	    {
		_cpAlgorithmIdentifier(_g, &((*(_Certificate  *)src).signatureAlgorithm), &((*(_Certificate  *)pdVal).signatureAlgorithm));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_Certificate  *)src).signature), &((*(_Certificate  *)pdVal).signature), sizeof(((*(_Certificate  *)pdVal).signature).length), -1L, (unsigned int)((char *)&((*(_Certificate  *)src).signature).value - (char *)&((*(_Certificate  *)src).signature)));
	    }
	} break;
	case 58: {
	    pdVal = (_CertificateList  *)_oss_dec_const_alloc(_g, sizeof(_CertificateList ));
	    OSS_MEMCPY(_g, (_CertificateList  *)pdVal, sizeof(*(_CertificateList  *)pdVal), (_CertificateList  *)src, sizeof(*(_CertificateList  *)pdVal));
	    {
		{
		    _cpAlgorithmIdentifier(_g, &(((*(_CertificateList  *)src).tbsCertList).signature), &(((*(_CertificateList  *)pdVal).tbsCertList).signature));
		}
		{
		    _cpName(_g, &(((*(_CertificateList  *)src).tbsCertList).issuer), &(((*(_CertificateList  *)pdVal).tbsCertList).issuer));
		}
		{
		    _cpTime(_g, &(((*(_CertificateList  *)src).tbsCertList).thisUpdate), &(((*(_CertificateList  *)pdVal).tbsCertList).thisUpdate));
		}
		if (((*(_CertificateList  *)src).tbsCertList).bit_mask & 0x40000000) {
		    _cpTime(_g, &(((*(_CertificateList  *)src).tbsCertList).nextUpdate), &(((*(_CertificateList  *)pdVal).tbsCertList).nextUpdate));
		}
		if (((*(_CertificateList  *)src).tbsCertList).bit_mask & 0x20000000) {
		    ((*(_CertificateList  *)pdVal).tbsCertList).revokedCertificates = NULL;
		    if (((*(_CertificateList  *)src).tbsCertList).revokedCertificates) {
			_seqof11 *  s_oss_tmp_3 = ((*(_CertificateList  *)src).tbsCertList).revokedCertificates;
			_seqof11 *  d_oss_tmp_3;

			((*(_CertificateList  *)pdVal).tbsCertList).revokedCertificates = d_oss_tmp_3 = (_seqof11 *)_oss_dec_getmem_internal(_g, sizeof(_seqof11));
			do {
			    OSS_MEMCPY(_g, d_oss_tmp_3,  sizeof(_seqof11), s_oss_tmp_3, sizeof(_seqof11));
			    {
				_seq4  * src_3 = &(s_oss_tmp_3->value);
				_seq4  * dst_3 = &(d_oss_tmp_3->value);

				{
				    _cpTime(_g, &((*src_3).revocationDate), &((*dst_3).revocationDate));
				}
				if ((*src_3).bit_mask & 0x80000000) {
				    _cpExtensions(_g, &((*src_3).crlEntryExtensions), &((*dst_3).crlEntryExtensions));
				}
			    }
			    if (s_oss_tmp_3->next)
				d_oss_tmp_3->next = (_seqof11 *)_oss_dec_getmem_internal(_g, sizeof(_seqof11));
			    s_oss_tmp_3 = s_oss_tmp_3->next;
			    d_oss_tmp_3 = d_oss_tmp_3->next;
			} while (s_oss_tmp_3);
		    }
		}
		if (((*(_CertificateList  *)src).tbsCertList).bit_mask & 0x10000000) {
		    _cpExtensions(_g, &(((*(_CertificateList  *)src).tbsCertList).crlExtensions), &(((*(_CertificateList  *)pdVal).tbsCertList).crlExtensions));
		}
	    }
	    {
		_cpAlgorithmIdentifier(_g, &((*(_CertificateList  *)src).signatureAlgorithm), &((*(_CertificateList  *)pdVal).signatureAlgorithm));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_CertificateList  *)src).signature), &((*(_CertificateList  *)pdVal).signature), sizeof(((*(_CertificateList  *)pdVal).signature).length), -1L, (unsigned int)((char *)&((*(_CertificateList  *)src).signature).value - (char *)&((*(_CertificateList  *)src).signature)));
	    }
	} break;
	case 59: {
	    pdVal = (_ORAddress  *)_oss_dec_const_alloc(_g, sizeof(_ORAddress ));
	    OSS_MEMCPY(_g, (_ORAddress  *)pdVal, sizeof(*(_ORAddress  *)pdVal), (_ORAddress  *)src, sizeof(*(_ORAddress  *)pdVal));
	    {
		if (((*(_ORAddress  *)src).built_in_standard_attributes).bit_mask & 0x80000000) {
		    switch ((((*(_ORAddress  *)src).built_in_standard_attributes).country_name).choice) {
			case 1: {
			    _oss_cpy_unbnd_octet_ia(_g, &((((*(_ORAddress  *)src).built_in_standard_attributes).country_name).u.x121_dcc_code), &((((*(_ORAddress  *)pdVal).built_in_standard_attributes).country_name).u.x121_dcc_code), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).country_name).u.x121_dcc_code).length), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).country_name).u.x121_dcc_code).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).country_name).u.x121_dcc_code).value - (char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).country_name).u.x121_dcc_code)));
			}   break;
			case 2: {
			    _oss_cpy_unbnd_octet_ia(_g, &((((*(_ORAddress  *)src).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code), &((((*(_ORAddress  *)pdVal).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code).length), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code).value - (char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code)));
			}   break;
			default:;
		    }
		}
		if (((*(_ORAddress  *)src).built_in_standard_attributes).bit_mask & 0x40000000) {
		    switch ((((*(_ORAddress  *)src).built_in_standard_attributes).administration_domain_name).choice) {
			case 1: {
			    _oss_cpy_unbnd_octet_ia(_g, &((((*(_ORAddress  *)src).built_in_standard_attributes).administration_domain_name).u.numeric), &((((*(_ORAddress  *)pdVal).built_in_standard_attributes).administration_domain_name).u.numeric), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).administration_domain_name).u.numeric).length), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).administration_domain_name).u.numeric).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).administration_domain_name).u.numeric).value - (char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).administration_domain_name).u.numeric)));
			}   break;
			case 2: {
			    _oss_cpy_unbnd_octet_ia(_g, &((((*(_ORAddress  *)src).built_in_standard_attributes).administration_domain_name).u.printable), &((((*(_ORAddress  *)pdVal).built_in_standard_attributes).administration_domain_name).u.printable), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).administration_domain_name).u.printable).length), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).administration_domain_name).u.printable).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).administration_domain_name).u.printable).value - (char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).administration_domain_name).u.printable)));
			}   break;
			default:;
		    }
		}
		if (((*(_ORAddress  *)src).built_in_standard_attributes).bit_mask & 0x20000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_ORAddress  *)src).built_in_standard_attributes).network_address), &(((*(_ORAddress  *)pdVal).built_in_standard_attributes).network_address), sizeof((((*(_ORAddress  *)pdVal).built_in_standard_attributes).network_address).length), sizeof((((*(_ORAddress  *)pdVal).built_in_standard_attributes).network_address).value[0]), (unsigned int)((char *)&(((*(_ORAddress  *)src).built_in_standard_attributes).network_address).value - (char *)&(((*(_ORAddress  *)src).built_in_standard_attributes).network_address)));
		}
		if (((*(_ORAddress  *)src).built_in_standard_attributes).bit_mask & 0x10000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_ORAddress  *)src).built_in_standard_attributes).terminal_identifier), &(((*(_ORAddress  *)pdVal).built_in_standard_attributes).terminal_identifier), sizeof((((*(_ORAddress  *)pdVal).built_in_standard_attributes).terminal_identifier).length), sizeof((((*(_ORAddress  *)pdVal).built_in_standard_attributes).terminal_identifier).value[0]), (unsigned int)((char *)&(((*(_ORAddress  *)src).built_in_standard_attributes).terminal_identifier).value - (char *)&(((*(_ORAddress  *)src).built_in_standard_attributes).terminal_identifier)));
		}
		if (((*(_ORAddress  *)src).built_in_standard_attributes).bit_mask & 0x8000000) {
		    switch ((((*(_ORAddress  *)src).built_in_standard_attributes).private_domain_name).choice) {
			case 1: {
			    _oss_cpy_unbnd_octet_ia(_g, &((((*(_ORAddress  *)src).built_in_standard_attributes).private_domain_name).u.numeric), &((((*(_ORAddress  *)pdVal).built_in_standard_attributes).private_domain_name).u.numeric), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).private_domain_name).u.numeric).length), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).private_domain_name).u.numeric).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).private_domain_name).u.numeric).value - (char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).private_domain_name).u.numeric)));
			}   break;
			case 2: {
			    _oss_cpy_unbnd_octet_ia(_g, &((((*(_ORAddress  *)src).built_in_standard_attributes).private_domain_name).u.printable), &((((*(_ORAddress  *)pdVal).built_in_standard_attributes).private_domain_name).u.printable), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).private_domain_name).u.printable).length), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).private_domain_name).u.printable).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).private_domain_name).u.printable).value - (char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).private_domain_name).u.printable)));
			}   break;
			default:;
		    }
		}
		if (((*(_ORAddress  *)src).built_in_standard_attributes).bit_mask & 0x4000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_ORAddress  *)src).built_in_standard_attributes).organization_name), &(((*(_ORAddress  *)pdVal).built_in_standard_attributes).organization_name), sizeof((((*(_ORAddress  *)pdVal).built_in_standard_attributes).organization_name).length), sizeof((((*(_ORAddress  *)pdVal).built_in_standard_attributes).organization_name).value[0]), (unsigned int)((char *)&(((*(_ORAddress  *)src).built_in_standard_attributes).organization_name).value - (char *)&(((*(_ORAddress  *)src).built_in_standard_attributes).organization_name)));
		}
		if (((*(_ORAddress  *)src).built_in_standard_attributes).bit_mask & 0x2000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_ORAddress  *)src).built_in_standard_attributes).numeric_user_identifier), &(((*(_ORAddress  *)pdVal).built_in_standard_attributes).numeric_user_identifier), sizeof((((*(_ORAddress  *)pdVal).built_in_standard_attributes).numeric_user_identifier).length), sizeof((((*(_ORAddress  *)pdVal).built_in_standard_attributes).numeric_user_identifier).value[0]), (unsigned int)((char *)&(((*(_ORAddress  *)src).built_in_standard_attributes).numeric_user_identifier).value - (char *)&(((*(_ORAddress  *)src).built_in_standard_attributes).numeric_user_identifier)));
		}
		if (((*(_ORAddress  *)src).built_in_standard_attributes).bit_mask & 0x1000000) {
		    {
			_oss_cpy_unbnd_octet_ia(_g, &((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).surname), &((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).surname), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).surname).length), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).surname).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).surname).value - (char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).surname)));
		    }
		    if ((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).bit_mask & 0x80000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).given_name), &((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).given_name), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).given_name).length), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).given_name).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).given_name).value - (char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).given_name)));
		    }
		    if ((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).bit_mask & 0x40000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).initials), &((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).initials), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).initials).length), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).initials).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).initials).value - (char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).initials)));
		    }
		    if ((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).bit_mask & 0x20000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).generation_qualifier), &((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).generation_qualifier), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).generation_qualifier).length), sizeof(((((*(_ORAddress  *)pdVal).built_in_standard_attributes).personal_name).generation_qualifier).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).generation_qualifier).value - (char *)&((((*(_ORAddress  *)src).built_in_standard_attributes).personal_name).generation_qualifier)));
		    }
		}
		if (((*(_ORAddress  *)src).built_in_standard_attributes).bit_mask & 0x800000) {
		    ((*(_ORAddress  *)pdVal).built_in_standard_attributes).organizational_unit_names = NULL;
		    if (((*(_ORAddress  *)src).built_in_standard_attributes).organizational_unit_names) {
			_seqof1 *  s_oss_tmp_3 = ((*(_ORAddress  *)src).built_in_standard_attributes).organizational_unit_names;
			_seqof1 *  d_oss_tmp_3;

			((*(_ORAddress  *)pdVal).built_in_standard_attributes).organizational_unit_names = d_oss_tmp_3 = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
			do {
			    OSS_MEMCPY(_g, d_oss_tmp_3,  sizeof(_seqof1), s_oss_tmp_3, sizeof(_seqof1));
			    {
				_oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_3->value), &(d_oss_tmp_3->value), sizeof((d_oss_tmp_3->value).length), sizeof((d_oss_tmp_3->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_3->value).value - (char *)&(s_oss_tmp_3->value)));
			    }
			    if (s_oss_tmp_3->next)
				d_oss_tmp_3->next = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
			    s_oss_tmp_3 = s_oss_tmp_3->next;
			    d_oss_tmp_3 = d_oss_tmp_3->next;
			} while (s_oss_tmp_3);
		    }
		}
	    }
	    if ((*(_ORAddress  *)src).bit_mask & 0x80000000) {
		(*(_ORAddress  *)pdVal).built_in_domain_defined_attributes = NULL;
		if ((*(_ORAddress  *)src).built_in_domain_defined_attributes) {
		    _BuiltInDomainDefinedAttributes *  s_oss_tmp_2 = (*(_ORAddress  *)src).built_in_domain_defined_attributes;
		    _BuiltInDomainDefinedAttributes *  d_oss_tmp_2;

		    (*(_ORAddress  *)pdVal).built_in_domain_defined_attributes = d_oss_tmp_2 = (_BuiltInDomainDefinedAttributes *)_oss_dec_getmem_internal(_g, sizeof(_BuiltInDomainDefinedAttributes));
		    do {
			OSS_MEMCPY(_g, d_oss_tmp_2,  sizeof(_BuiltInDomainDefinedAttributes), s_oss_tmp_2, sizeof(_BuiltInDomainDefinedAttributes));
			{
			    {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).type), &((d_oss_tmp_2->value).type), sizeof(((d_oss_tmp_2->value).type).length), sizeof(((d_oss_tmp_2->value).type).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).type).value - (char *)&((s_oss_tmp_2->value).type)));
			    }
			    {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).value), &((d_oss_tmp_2->value).value), sizeof(((d_oss_tmp_2->value).value).length), sizeof(((d_oss_tmp_2->value).value).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).value).value - (char *)&((s_oss_tmp_2->value).value)));
			    }
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_BuiltInDomainDefinedAttributes *)_oss_dec_getmem_internal(_g, sizeof(_BuiltInDomainDefinedAttributes));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_ORAddress  *)src).bit_mask & 0x40000000) {
		(*(_ORAddress  *)pdVal).extension_attributes = NULL;
		if ((*(_ORAddress  *)src).extension_attributes) {
		    _ExtensionAttributes *  s_oss_tmp_2 = (*(_ORAddress  *)src).extension_attributes;
		    _ExtensionAttributes *  d_oss_tmp_2;

		    (*(_ORAddress  *)pdVal).extension_attributes = d_oss_tmp_2 = (_ExtensionAttributes *)_oss_dec_getmem_internal(_g, sizeof(_ExtensionAttributes));
		    do {
			OSS_MEMCPY(_g, d_oss_tmp_2,  sizeof(_ExtensionAttributes), s_oss_tmp_2, sizeof(_ExtensionAttributes));
			{
			    {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).extension_attribute_value), &((d_oss_tmp_2->value).extension_attribute_value), sizeof(((d_oss_tmp_2->value).extension_attribute_value).length), sizeof(((d_oss_tmp_2->value).extension_attribute_value).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).extension_attribute_value).value - (char *)&((s_oss_tmp_2->value).extension_attribute_value)));
			    }
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_ExtensionAttributes *)_oss_dec_getmem_internal(_g, sizeof(_ExtensionAttributes));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 60: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 61: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 62: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 63: {
	    pdVal = (_PersonalName  *)_oss_dec_const_alloc(_g, sizeof(_PersonalName ));
	    OSS_MEMCPY(_g, (_PersonalName  *)pdVal, sizeof(*(_PersonalName  *)pdVal), (_PersonalName  *)src, sizeof(*(_PersonalName  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PersonalName  *)src).surname), &((*(_PersonalName  *)pdVal).surname), sizeof(((*(_PersonalName  *)pdVal).surname).length), sizeof(((*(_PersonalName  *)pdVal).surname).value[0]), (unsigned int)((char *)&((*(_PersonalName  *)src).surname).value - (char *)&((*(_PersonalName  *)src).surname)));
	    }
	    if ((*(_PersonalName  *)src).bit_mask & 0x80000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PersonalName  *)src).given_name), &((*(_PersonalName  *)pdVal).given_name), sizeof(((*(_PersonalName  *)pdVal).given_name).length), sizeof(((*(_PersonalName  *)pdVal).given_name).value[0]), (unsigned int)((char *)&((*(_PersonalName  *)src).given_name).value - (char *)&((*(_PersonalName  *)src).given_name)));
	    }
	    if ((*(_PersonalName  *)src).bit_mask & 0x40000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PersonalName  *)src).initials), &((*(_PersonalName  *)pdVal).initials), sizeof(((*(_PersonalName  *)pdVal).initials).length), sizeof(((*(_PersonalName  *)pdVal).initials).value[0]), (unsigned int)((char *)&((*(_PersonalName  *)src).initials).value - (char *)&((*(_PersonalName  *)src).initials)));
	    }
	    if ((*(_PersonalName  *)src).bit_mask & 0x20000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PersonalName  *)src).generation_qualifier), &((*(_PersonalName  *)pdVal).generation_qualifier), sizeof(((*(_PersonalName  *)pdVal).generation_qualifier).length), sizeof(((*(_PersonalName  *)pdVal).generation_qualifier).value[0]), (unsigned int)((char *)&((*(_PersonalName  *)src).generation_qualifier).value - (char *)&((*(_PersonalName  *)src).generation_qualifier)));
	    }
	} break;
	case 64: {
	    pdVal = (_seqof1 * *)_oss_dec_const_alloc(_g, sizeof(_seqof1 *));
	    *(_seqof1 * *)pdVal = NULL;
	    if (*(_seqof1 * *)src) {
		_seqof1 *  s_oss_tmp_1 = *(_seqof1 * *)src;
		_seqof1 *  d_oss_tmp_1;

		*(_seqof1 * *)pdVal = d_oss_tmp_1 = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
		do {
		    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_seqof1), s_oss_tmp_1, sizeof(_seqof1));
		    {
			_oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value), sizeof((d_oss_tmp_1->value).length), sizeof((d_oss_tmp_1->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_1->value).value - (char *)&(s_oss_tmp_1->value)));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 65: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 66: {
	    pdVal = (_CountryName  *)_oss_dec_const_alloc(_g, sizeof(_CountryName ));
	    OSS_MEMCPY(_g, (_CountryName  *)pdVal, sizeof(*(_CountryName  *)pdVal), (_CountryName  *)src, sizeof(*(_CountryName  *)pdVal));
	    switch ((*(_CountryName  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_CountryName  *)src).u.x121_dcc_code), &((*(_CountryName  *)pdVal).u.x121_dcc_code), sizeof(((*(_CountryName  *)pdVal).u.x121_dcc_code).length), sizeof(((*(_CountryName  *)pdVal).u.x121_dcc_code).value[0]), (unsigned int)((char *)&((*(_CountryName  *)src).u.x121_dcc_code).value - (char *)&((*(_CountryName  *)src).u.x121_dcc_code)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_CountryName  *)src).u.iso_3166_alpha2_code), &((*(_CountryName  *)pdVal).u.iso_3166_alpha2_code), sizeof(((*(_CountryName  *)pdVal).u.iso_3166_alpha2_code).length), sizeof(((*(_CountryName  *)pdVal).u.iso_3166_alpha2_code).value[0]), (unsigned int)((char *)&((*(_CountryName  *)src).u.iso_3166_alpha2_code).value - (char *)&((*(_CountryName  *)src).u.iso_3166_alpha2_code)));
		}   break;
		default:;
	    }
	} break;
	case 67: {
	    pdVal = (_PostalCode  *)_oss_dec_const_alloc(_g, sizeof(_PostalCode ));
	    OSS_MEMCPY(_g, (_PostalCode  *)pdVal, sizeof(*(_PostalCode  *)pdVal), (_PostalCode  *)src, sizeof(*(_PostalCode  *)pdVal));
	    switch ((*(_PostalCode  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_PostalCode  *)src).u.numeric_code), &((*(_PostalCode  *)pdVal).u.numeric_code), sizeof(((*(_PostalCode  *)pdVal).u.numeric_code).length), sizeof(((*(_PostalCode  *)pdVal).u.numeric_code).value[0]), (unsigned int)((char *)&((*(_PostalCode  *)src).u.numeric_code).value - (char *)&((*(_PostalCode  *)src).u.numeric_code)));
		}   break;
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_PostalCode  *)src).u.printable_code), &((*(_PostalCode  *)pdVal).u.printable_code), sizeof(((*(_PostalCode  *)pdVal).u.printable_code).length), sizeof(((*(_PostalCode  *)pdVal).u.printable_code).value[0]), (unsigned int)((char *)&((*(_PostalCode  *)src).u.printable_code).value - (char *)&((*(_PostalCode  *)src).u.printable_code)));
		}   break;
		default:;
	    }
	} break;
	case 68: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 69: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 70: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 71: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 72: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 73: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 74: {
	    pdVal = (_UnformattedPostalAddress  *)_oss_dec_const_alloc(_g, sizeof(_UnformattedPostalAddress ));
	    OSS_MEMCPY(_g, (_UnformattedPostalAddress  *)pdVal, sizeof(*(_UnformattedPostalAddress  *)pdVal), (_UnformattedPostalAddress  *)src, sizeof(*(_UnformattedPostalAddress  *)pdVal));
	    if ((*(_UnformattedPostalAddress  *)src).bit_mask & 0x80000000) {
		(*(_UnformattedPostalAddress  *)pdVal).printable_address = NULL;
		if ((*(_UnformattedPostalAddress  *)src).printable_address) {
		    _seqof1 *  s_oss_tmp_2 = (*(_UnformattedPostalAddress  *)src).printable_address;
		    _seqof1 *  d_oss_tmp_2;

		    (*(_UnformattedPostalAddress  *)pdVal).printable_address = d_oss_tmp_2 = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
		    do {
			OSS_MEMCPY(_g, d_oss_tmp_2,  sizeof(_seqof1), s_oss_tmp_2, sizeof(_seqof1));
			{
			    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_UnformattedPostalAddress  *)src).bit_mask & 0x40000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_UnformattedPostalAddress  *)src).teletex_string), &((*(_UnformattedPostalAddress  *)pdVal).teletex_string), sizeof(((*(_UnformattedPostalAddress  *)pdVal).teletex_string).length), sizeof(((*(_UnformattedPostalAddress  *)pdVal).teletex_string).value[0]), (unsigned int)((char *)&((*(_UnformattedPostalAddress  *)src).teletex_string).value - (char *)&((*(_UnformattedPostalAddress  *)src).teletex_string)));
	    }
	} break;
	case 75: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 76: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 77: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 78: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 79: {
	    pdVal = _cpPDSParameter(_g, (_PDSParameter  *)src, (_PDSParameter  *)pdVal);
	} break;
	case 80: {
	    pdVal = (_ExtendedNetworkAddress  *)_oss_dec_const_alloc(_g, sizeof(_ExtendedNetworkAddress ));
	    OSS_MEMCPY(_g, (_ExtendedNetworkAddress  *)pdVal, sizeof(*(_ExtendedNetworkAddress  *)pdVal), (_ExtendedNetworkAddress  *)src, sizeof(*(_ExtendedNetworkAddress  *)pdVal));
	    switch ((*(_ExtendedNetworkAddress  *)src).choice) {
		case 1: {
		    (*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address = (_seq5 *)_oss_dec_const_alloc(_g, sizeof(*((*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address)));
		    OSS_MEMCPY(_g, (*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address, sizeof(*(*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address), (*(_ExtendedNetworkAddress  *)src).u.e163_4_address, sizeof(*(*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address));
		    {
			_oss_cpy_unbnd_octet_ia(_g, &(((*(_ExtendedNetworkAddress  *)src).u.e163_4_address)->number), &(((*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address)->number), sizeof((((*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address)->number).length), sizeof((((*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address)->number).value[0]), (unsigned int)((char *)&(((*(_ExtendedNetworkAddress  *)src).u.e163_4_address)->number).value - (char *)&(((*(_ExtendedNetworkAddress  *)src).u.e163_4_address)->number)));
		    }
		    if (((*(_ExtendedNetworkAddress  *)src).u.e163_4_address)->bit_mask & 0x80000000) {
			_oss_cpy_unbnd_octet_ia(_g, &(((*(_ExtendedNetworkAddress  *)src).u.e163_4_address)->sub_address), &(((*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address)->sub_address), sizeof((((*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address)->sub_address).length), sizeof((((*(_ExtendedNetworkAddress  *)pdVal).u.e163_4_address)->sub_address).value[0]), (unsigned int)((char *)&(((*(_ExtendedNetworkAddress  *)src).u.e163_4_address)->sub_address).value - (char *)&(((*(_ExtendedNetworkAddress  *)src).u.e163_4_address)->sub_address)));
		    }
		}   break;
		case 2: {
		    (*(_ExtendedNetworkAddress  *)pdVal).u.psap_address = (_PresentationAddress  *)_oss_dec_const_alloc(_g, sizeof(_PresentationAddress ));
		    OSS_MEMCPY(_g, (*(_ExtendedNetworkAddress  *)pdVal).u.psap_address, sizeof(*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address), (*(_ExtendedNetworkAddress  *)src).u.psap_address, sizeof(*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address));
		    if ((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).bit_mask & 0x80000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).pSelector), &((*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).pSelector), sizeof(((*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).pSelector).length), sizeof(((*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).pSelector).value[0]), (unsigned int)((char *)&((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).pSelector).value - (char *)&((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).pSelector)));
		    }
		    if ((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).bit_mask & 0x40000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).sSelector), &((*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).sSelector), sizeof(((*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).sSelector).length), sizeof(((*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).sSelector).value[0]), (unsigned int)((char *)&((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).sSelector).value - (char *)&((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).sSelector)));
		    }
		    if ((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).bit_mask & 0x20000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).tSelector), &((*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).tSelector), sizeof(((*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).tSelector).length), sizeof(((*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).tSelector).value[0]), (unsigned int)((char *)&((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).tSelector).value - (char *)&((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).tSelector)));
		    }
		    {
			(*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).nAddresses = NULL;
			if ((*(*(_ExtendedNetworkAddress  *)src).u.psap_address).nAddresses) {
			    _seqof1 *  s_oss_tmp_3 = (*(*(_ExtendedNetworkAddress  *)src).u.psap_address).nAddresses;
			    _seqof1 *  d_oss_tmp_3;

			    (*(*(_ExtendedNetworkAddress  *)pdVal).u.psap_address).nAddresses = d_oss_tmp_3 = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
			    do {
				OSS_MEMCPY(_g, d_oss_tmp_3,  sizeof(_seqof1), s_oss_tmp_3, sizeof(_seqof1));
				{
				    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_3->value), &(d_oss_tmp_3->value), sizeof((d_oss_tmp_3->value).length), sizeof((d_oss_tmp_3->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_3->value).value - (char *)&(s_oss_tmp_3->value)));
				}
				if (s_oss_tmp_3->next)
				    d_oss_tmp_3->next = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
				s_oss_tmp_3 = s_oss_tmp_3->next;
				d_oss_tmp_3 = d_oss_tmp_3->next;
			    } while (s_oss_tmp_3);
			}
		    }
		}   break;
		default:;
	    }
	} break;
	case 81: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 82: {
	    pdVal = (_BuiltInDomainDefinedAttributes * *)_oss_dec_const_alloc(_g, sizeof(_BuiltInDomainDefinedAttributes *));
	    *(_BuiltInDomainDefinedAttributes * *)pdVal = NULL;
	    if (*(_BuiltInDomainDefinedAttributes * *)src) {
		_BuiltInDomainDefinedAttributes *  s_oss_tmp_1 = *(_BuiltInDomainDefinedAttributes * *)src;
		_BuiltInDomainDefinedAttributes *  d_oss_tmp_1;

		*(_BuiltInDomainDefinedAttributes * *)pdVal = d_oss_tmp_1 = (_BuiltInDomainDefinedAttributes *)_oss_dec_getmem_internal(_g, sizeof(_BuiltInDomainDefinedAttributes));
		do {
		    OSS_MEMCPY(_g, d_oss_tmp_1,  sizeof(_BuiltInDomainDefinedAttributes), s_oss_tmp_1, sizeof(_BuiltInDomainDefinedAttributes));
		    {
			{
			    _oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).type), &((d_oss_tmp_1->value).type), sizeof(((d_oss_tmp_1->value).type).length), sizeof(((d_oss_tmp_1->value).type).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).type).value - (char *)&((s_oss_tmp_1->value).type)));
			}
			{
			    _oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).value), &((d_oss_tmp_1->value).value), sizeof(((d_oss_tmp_1->value).value).length), sizeof(((d_oss_tmp_1->value).value).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).value).value - (char *)&((s_oss_tmp_1->value).value)));
			}
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_BuiltInDomainDefinedAttributes *)_oss_dec_getmem_internal(_g, sizeof(_BuiltInDomainDefinedAttributes));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 83: {
	    pdVal = (_AuthPack_OLD  *)_oss_dec_const_alloc(_g, sizeof(_AuthPack_OLD ));
	    OSS_MEMCPY(_g, (_AuthPack_OLD  *)pdVal, sizeof(*(_AuthPack_OLD  *)pdVal), (_AuthPack_OLD  *)src, sizeof(*(_AuthPack_OLD  *)pdVal));
	    {
		{
		    _cpPrincipalName(_g, &(((*(_AuthPack_OLD  *)src).pkAuthenticator).kdc_name), &(((*(_AuthPack_OLD  *)pdVal).pkAuthenticator).kdc_name));
		}
		{
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_AuthPack_OLD  *)src).pkAuthenticator).kdc_realm), &(((*(_AuthPack_OLD  *)pdVal).pkAuthenticator).kdc_realm), sizeof((((*(_AuthPack_OLD  *)pdVal).pkAuthenticator).kdc_realm).length), sizeof((((*(_AuthPack_OLD  *)pdVal).pkAuthenticator).kdc_realm).value[0]), (unsigned int)((char *)&(((*(_AuthPack_OLD  *)src).pkAuthenticator).kdc_realm).value - (char *)&(((*(_AuthPack_OLD  *)src).pkAuthenticator).kdc_realm)));
		}
		{
		    size_t  len_2 = (size_t)sizeof(char) * (OSS_STRNLEN(((*(_AuthPack_OLD  *)src).pkAuthenticator).ctime, OSS_MAX_STR) + 1);

		    ((*(_AuthPack_OLD  *)pdVal).pkAuthenticator).ctime = (char * )_oss_dec_getmem_internal(_g, (long)len_2);
		    OSS_STRCPY(_g, ((*(_AuthPack_OLD  *)pdVal).pkAuthenticator).ctime, (long)len_2, ((*(_AuthPack_OLD  *)src).pkAuthenticator).ctime);
		}
	    }
	} break;
	case 84: {
	    pdVal = (_KERB_REPLY_KEY_PACKAGE  *)_oss_dec_const_alloc(_g, sizeof(_KERB_REPLY_KEY_PACKAGE ));
	    OSS_MEMCPY(_g, (_KERB_REPLY_KEY_PACKAGE  *)pdVal, sizeof(*(_KERB_REPLY_KEY_PACKAGE  *)pdVal), (_KERB_REPLY_KEY_PACKAGE  *)src, sizeof(*(_KERB_REPLY_KEY_PACKAGE  *)pdVal));
	    {
		_cpEncryptionKey(_g, &((*(_KERB_REPLY_KEY_PACKAGE  *)src).replyKey), &((*(_KERB_REPLY_KEY_PACKAGE  *)pdVal).replyKey));
	    }
	} break;
	case 85: {
	    pdVal = (_PA_FOR_USER_ENC  *)_oss_dec_const_alloc(_g, sizeof(_PA_FOR_USER_ENC ));
	    OSS_MEMCPY(_g, (_PA_FOR_USER_ENC  *)pdVal, sizeof(*(_PA_FOR_USER_ENC  *)pdVal), (_PA_FOR_USER_ENC  *)src, sizeof(*(_PA_FOR_USER_ENC  *)pdVal));
	    {
		_cpPrincipalName(_g, &((*(_PA_FOR_USER_ENC  *)src).userName), &((*(_PA_FOR_USER_ENC  *)pdVal).userName));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PA_FOR_USER_ENC  *)src).userRealm), &((*(_PA_FOR_USER_ENC  *)pdVal).userRealm), sizeof(((*(_PA_FOR_USER_ENC  *)pdVal).userRealm).length), sizeof(((*(_PA_FOR_USER_ENC  *)pdVal).userRealm).value[0]), (unsigned int)((char *)&((*(_PA_FOR_USER_ENC  *)src).userRealm).value - (char *)&((*(_PA_FOR_USER_ENC  *)src).userRealm)));
	    }
	    {
		_cpChecksum(_g, &((*(_PA_FOR_USER_ENC  *)src).cksum), &((*(_PA_FOR_USER_ENC  *)pdVal).cksum));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PA_FOR_USER_ENC  *)src).auth_package), &((*(_PA_FOR_USER_ENC  *)pdVal).auth_package), sizeof(((*(_PA_FOR_USER_ENC  *)pdVal).auth_package).length), sizeof(((*(_PA_FOR_USER_ENC  *)pdVal).auth_package).value[0]), (unsigned int)((char *)&((*(_PA_FOR_USER_ENC  *)src).auth_package).value - (char *)&((*(_PA_FOR_USER_ENC  *)src).auth_package)));
	    }
	} break;
	case 86: {
	    pdVal = (_PA_S4U_X509_USER  *)_oss_dec_const_alloc(_g, sizeof(_PA_S4U_X509_USER ));
	    OSS_MEMCPY(_g, (_PA_S4U_X509_USER  *)pdVal, sizeof(*(_PA_S4U_X509_USER  *)pdVal), (_PA_S4U_X509_USER  *)src, sizeof(*(_PA_S4U_X509_USER  *)pdVal));
	    {
		if (((*(_PA_S4U_X509_USER  *)src).user_id).bit_mask & 0x80000000) {
		    _cpPrincipalName(_g, &(((*(_PA_S4U_X509_USER  *)src).user_id).cname), &(((*(_PA_S4U_X509_USER  *)pdVal).user_id).cname));
		}
		{
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_PA_S4U_X509_USER  *)src).user_id).crealm), &(((*(_PA_S4U_X509_USER  *)pdVal).user_id).crealm), sizeof((((*(_PA_S4U_X509_USER  *)pdVal).user_id).crealm).length), sizeof((((*(_PA_S4U_X509_USER  *)pdVal).user_id).crealm).value[0]), (unsigned int)((char *)&(((*(_PA_S4U_X509_USER  *)src).user_id).crealm).value - (char *)&(((*(_PA_S4U_X509_USER  *)src).user_id).crealm)));
		}
		if (((*(_PA_S4U_X509_USER  *)src).user_id).bit_mask & 0x40000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_PA_S4U_X509_USER  *)src).user_id).subject_certificate), &(((*(_PA_S4U_X509_USER  *)pdVal).user_id).subject_certificate), sizeof((((*(_PA_S4U_X509_USER  *)pdVal).user_id).subject_certificate).length), sizeof((((*(_PA_S4U_X509_USER  *)pdVal).user_id).subject_certificate).value[0]), (unsigned int)((char *)&(((*(_PA_S4U_X509_USER  *)src).user_id).subject_certificate).value - (char *)&(((*(_PA_S4U_X509_USER  *)src).user_id).subject_certificate)));
		}
		if (((*(_PA_S4U_X509_USER  *)src).user_id).bit_mask & 0x20000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_PA_S4U_X509_USER  *)src).user_id).options), &(((*(_PA_S4U_X509_USER  *)pdVal).user_id).options), sizeof((((*(_PA_S4U_X509_USER  *)pdVal).user_id).options).length), -1L, (unsigned int)((char *)&(((*(_PA_S4U_X509_USER  *)src).user_id).options).value - (char *)&(((*(_PA_S4U_X509_USER  *)src).user_id).options)));
		}
	    }
	    {
		_cpChecksum(_g, &((*(_PA_S4U_X509_USER  *)src).checksum), &((*(_PA_S4U_X509_USER  *)pdVal).checksum));
	    }
	} break;
	case 87: {
	    pdVal = (_PA_PAC_OPTIONS  *)_oss_dec_const_alloc(_g, sizeof(_PA_PAC_OPTIONS ));
	    OSS_MEMCPY(_g, (_PA_PAC_OPTIONS  *)pdVal, sizeof(*(_PA_PAC_OPTIONS  *)pdVal), (_PA_PAC_OPTIONS  *)src, sizeof(*(_PA_PAC_OPTIONS  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PA_PAC_OPTIONS  *)src).kerberosFlags), &((*(_PA_PAC_OPTIONS  *)pdVal).kerberosFlags), sizeof(((*(_PA_PAC_OPTIONS  *)pdVal).kerberosFlags).length), -1L, (unsigned int)((char *)&((*(_PA_PAC_OPTIONS  *)src).kerberosFlags).value - (char *)&((*(_PA_PAC_OPTIONS  *)src).kerberosFlags)));
	    }
	} break;
	case 88: {
	    pdVal = (_KERB_PA_PAC_REQUEST  *)_oss_dec_const_alloc(_g, sizeof(_KERB_PA_PAC_REQUEST ));
	    OSS_MEMCPY(_g, (_KERB_PA_PAC_REQUEST  *)pdVal, sizeof(*(_KERB_PA_PAC_REQUEST  *)pdVal), (_KERB_PA_PAC_REQUEST  *)src, sizeof(*(_KERB_PA_PAC_REQUEST  *)pdVal));
	} break;
	case 89: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 90: {
	    pdVal = (_KERB_AD_RESTRICTION_ENTRY  *)_oss_dec_const_alloc(_g, sizeof(_KERB_AD_RESTRICTION_ENTRY ));
	    OSS_MEMCPY(_g, (_KERB_AD_RESTRICTION_ENTRY  *)pdVal, sizeof(*(_KERB_AD_RESTRICTION_ENTRY  *)pdVal), (_KERB_AD_RESTRICTION_ENTRY  *)src, sizeof(*(_KERB_AD_RESTRICTION_ENTRY  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_KERB_AD_RESTRICTION_ENTRY  *)src).restriction), &((*(_KERB_AD_RESTRICTION_ENTRY  *)pdVal).restriction), sizeof(((*(_KERB_AD_RESTRICTION_ENTRY  *)pdVal).restriction).length), sizeof(((*(_KERB_AD_RESTRICTION_ENTRY  *)pdVal).restriction).value[0]), (unsigned int)((char *)&((*(_KERB_AD_RESTRICTION_ENTRY  *)src).restriction).value - (char *)&((*(_KERB_AD_RESTRICTION_ENTRY  *)src).restriction)));
	    }
	} break;
	case 91: {
	    pdVal = (OSS_INT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32 ));
	    *(OSS_INT32  *)pdVal = *(OSS_INT32  *)src;
	} break;
	default:
	    res = PDU_RANGE;
    }
    *pdst = pdVal;
    return res;
}
#undef _oss_c
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
static int _cmTicket(OssGlobal * _g, _Ticket  * _odata, _Ticket  * _cdata)
{
    int _res = 0;

    if ((*_cdata).tkt_vno != (*_odata).tkt_vno)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).realm), &((*_cdata).realm), sizeof(((*_cdata).realm).length), sizeof(((*_cdata).realm).value[0]), (unsigned int)((char *)&((*_odata).realm).value - (char *)&((*_odata).realm))))
	return 1;
    _res = _cmPrincipalName(_g, &((*_odata).sname), &((*_cdata).sname));
    if (_res)
	return _res;
    _res = _cmEncryptedData(_g, &((*_odata).enc_part), &((*_cdata).enc_part));
    if (_res)
	return _res;
    (void)_g;

    return _res;
}


static int _cmKDC_REQ_BODY(OssGlobal * _g, _KDC_REQ_BODY  * _odata, _KDC_REQ_BODY  * _cdata)
{
    int _res = 0;

    if (_oss_cmp_arrbits(((*_odata).kdc_options).value, ((*_cdata).kdc_options).value, ((*_odata).kdc_options).length, ((*_cdata).kdc_options).length))
	return 1;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cmPrincipalName(_g, &((*_odata).cname), &((*_cdata).cname));
	if (_res)
	    return _res;
    }
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).realm), &((*_cdata).realm), sizeof(((*_cdata).realm).length), sizeof(((*_cdata).realm).value[0]), (unsigned int)((char *)&((*_odata).realm).value - (char *)&((*_odata).realm))))
	return 1;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	_res = _cmPrincipalName(_g, &((*_odata).sname), &((*_cdata).sname));
	if (_res)
	    return _res;
    }
    if (!(*_odata).from != !(*_cdata).from)
	return 1;
    if ((*_odata).from) {
	if (OSS_STRCMP(_g, (*_cdata).from, OSS_MAX_STR, (*_odata).from, _g->_res))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).from, (*_odata).from, 0))
#endif
		return 1;
    }
    if (OSS_STRCMP(_g, (*_cdata).till, OSS_MAX_STR, (*_odata).till, _g->_res))
#ifdef BAD_OID_IRI
	if (_oss_cmp_str2time((*_cdata).till, (*_odata).till, 0))
#endif
	    return 1;
    if (!(*_odata).rtime != !(*_cdata).rtime)
	return 1;
    if ((*_odata).rtime) {
	if (OSS_STRCMP(_g, (*_cdata).rtime, OSS_MAX_STR, (*_odata).rtime, _g->_res))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).rtime, (*_odata).rtime, 0))
#endif
		return 1;
    }
    if ((*_cdata).nonce != (*_odata).nonce)
	return 1;
    _res = _cm_seqof2(_g, &((*_odata).etype), &((*_cdata).etype));
    if (_res)
	return _res;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x20000000)
	return 1;
    if ((*_odata).bit_mask & 0x20000000) {
	_res = _cmHostAddresses(_g, &((*_odata).addresses), &((*_cdata).addresses));
	if (_res)
	    return _res;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x10000000)
	return 1;
    if ((*_odata).bit_mask & 0x10000000) {
	_res = _cmEncryptedData(_g, &((*_odata).enc_authorization_data), &((*_cdata).enc_authorization_data));
	if (_res)
	    return _res;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x8000000)
	return 1;
    if ((*_odata).bit_mask & 0x8000000) {
	_res = _cm_seqof3(_g, &((*_odata).additional_tickets), &((*_cdata).additional_tickets));
	if (_res)
	    return _res;
    }
    (void)_g;

    return _res;
}


static int _cm_seqof1(OssGlobal * _g, _seqof1 * * _odata, _seqof1 * * _cdata)
{
    int _res = 0;

    {
	_seqof1 *  _s_oss_tmp_1 = *_odata;
	_seqof1 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    if (_oss_cmp_unbnd_octet_ia(&(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value), sizeof((_d_oss_tmp_1->value).length), sizeof((_d_oss_tmp_1->value).value[0]), (unsigned int)((char *)&(_s_oss_tmp_1->value).value - (char *)&(_s_oss_tmp_1->value))))
		return 1;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmPrincipalName(OssGlobal * _g, _PrincipalName  * _odata, _PrincipalName  * _cdata)
{
    int _res = 0;

    if ((*_cdata).name_type != (*_odata).name_type)
	return 1;
    _res = _cm_seqof1(_g, &((*_odata).name_string), &((*_cdata).name_string));
    if (_res)
	return _res;
    (void)_g;

    return _res;
}


static int _cmHostAddress(OssGlobal * _g, _HostAddress  * _odata, _HostAddress  * _cdata)
{
    int _res = 0;

    if ((*_cdata).addr_type != (*_odata).addr_type)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).address), &((*_cdata).address), sizeof(((*_cdata).address).length), sizeof(((*_cdata).address).value[0]), (unsigned int)((char *)&((*_odata).address).value - (char *)&((*_odata).address))))
	return 1;
    (void)_g;

    return _res;
}


static int _cmHostAddresses(OssGlobal * _g, _HostAddresses * * _odata, _HostAddresses * * _cdata)
{
    int _res = 0;

    {
	_HostAddresses *  _s_oss_tmp_1 = *_odata;
	_HostAddresses *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmHostAddress(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cm_seq1(OssGlobal * _g, _seq1  * _odata, _seq1  * _cdata)
{
    int _res = 0;

    if ((*_cdata).ad_type != (*_odata).ad_type)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).ad_data), &((*_cdata).ad_data), sizeof(((*_cdata).ad_data).length), sizeof(((*_cdata).ad_data).value[0]), (unsigned int)((char *)&((*_odata).ad_data).value - (char *)&((*_odata).ad_data))))
	return 1;
    (void)_g;

    return _res;
}


static int _cmAuthorizationData(OssGlobal * _g, _AuthorizationData * * _odata, _AuthorizationData * * _cdata)
{
    int _res = 0;

    {
	_AuthorizationData *  _s_oss_tmp_1 = *_odata;
	_AuthorizationData *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cm_seq1(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmPA_DATA(OssGlobal * _g, _PA_DATA  * _odata, _PA_DATA  * _cdata)
{
    int _res = 0;

    if ((*_cdata).padata_type != (*_odata).padata_type)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).padata_value), &((*_cdata).padata_value), sizeof(((*_cdata).padata_value).length), sizeof(((*_cdata).padata_value).value[0]), (unsigned int)((char *)&((*_odata).padata_value).value - (char *)&((*_odata).padata_value))))
	return 1;
    (void)_g;

    return _res;
}


static int _cmEncryptedData(OssGlobal * _g, _EncryptedData  * _odata, _EncryptedData  * _cdata)
{
    int _res = 0;

    if ((*_cdata).etype != (*_odata).etype)
	return 1;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	if ((*_cdata).kvno != (*_odata).kvno)
	    return 1;
    }
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).cipher), &((*_cdata).cipher), sizeof(((*_cdata).cipher).length), sizeof(((*_cdata).cipher).value[0]), (unsigned int)((char *)&((*_odata).cipher).value - (char *)&((*_odata).cipher))))
	return 1;
    (void)_g;

    return _res;
}


static int _cmEncryptionKey(OssGlobal * _g, _EncryptionKey  * _odata, _EncryptionKey  * _cdata)
{
    int _res = 0;

    if ((*_cdata).keytype != (*_odata).keytype)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).keyvalue), &((*_cdata).keyvalue), sizeof(((*_cdata).keyvalue).length), sizeof(((*_cdata).keyvalue).value[0]), (unsigned int)((char *)&((*_odata).keyvalue).value - (char *)&((*_odata).keyvalue))))
	return 1;
    (void)_g;

    return _res;
}


static int _cmChecksum(OssGlobal * _g, _Checksum  * _odata, _Checksum  * _cdata)
{
    int _res = 0;

    if ((*_cdata).cksumtype != (*_odata).cksumtype)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).checksum), &((*_cdata).checksum), sizeof(((*_cdata).checksum).length), sizeof(((*_cdata).checksum).value[0]), (unsigned int)((char *)&((*_odata).checksum).value - (char *)&((*_odata).checksum))))
	return 1;
    (void)_g;

    return _res;
}


static int _cm_seqof2(OssGlobal * _g, _seqof2 * * _odata, _seqof2 * * _cdata)
{
    int _res = 0;

    {
	_seqof2 *  _s_oss_tmp_1 = *_odata;
	_seqof2 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    if (_d_oss_tmp_1->value != _s_oss_tmp_1->value)
		return 1;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cm_seqof3(OssGlobal * _g, _seqof3 * * _odata, _seqof3 * * _cdata)
{
    int _res = 0;

    {
	_seqof3 *  _s_oss_tmp_1 = *_odata;
	_seqof3 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmTicket(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cm_seqof4(OssGlobal * _g, _seqof4 * * _odata, _seqof4 * * _cdata)
{
    int _res = 0;

    {
	_seqof4 *  _s_oss_tmp_1 = *_odata;
	_seqof4 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmPA_DATA(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmKDC_REQ(OssGlobal * _g, _KDC_REQ  * _odata, _KDC_REQ  * _cdata)
{
    int _res = 0;

    if ((*_cdata).pvno != (*_odata).pvno)
	return 1;
    if ((*_cdata).msg_type != (*_odata).msg_type)
	return 1;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cm_seqof4(_g, &((*_odata).padata), &((*_cdata).padata));
	if (_res)
	    return _res;
    }
    _res = _cmKDC_REQ_BODY(_g, &((*_odata).req_body), &((*_cdata).req_body));
    if (_res)
	return _res;
    (void)_g;

    return _res;
}


static int _cm_seqof5(OssGlobal * _g, _seqof4 * * _odata, _seqof4 * * _cdata)
{
    int _res = 0;

    {
	_seqof4 *  _s_oss_tmp_1 = *_odata;
	_seqof4 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmPA_DATA(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmKDC_REP(OssGlobal * _g, _KDC_REP  * _odata, _KDC_REP  * _cdata)
{
    int _res = 0;

    if ((*_cdata).pvno != (*_odata).pvno)
	return 1;
    if ((*_cdata).msg_type != (*_odata).msg_type)
	return 1;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cm_seqof5(_g, &((*_odata).padata), &((*_cdata).padata));
	if (_res)
	    return _res;
    }
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).crealm), &((*_cdata).crealm), sizeof(((*_cdata).crealm).length), sizeof(((*_cdata).crealm).value[0]), (unsigned int)((char *)&((*_odata).crealm).value - (char *)&((*_odata).crealm))))
	return 1;
    _res = _cmPrincipalName(_g, &((*_odata).cname), &((*_cdata).cname));
    if (_res)
	return _res;
    _res = _cmTicket(_g, &((*_odata).ticket), &((*_cdata).ticket));
    if (_res)
	return _res;
    _res = _cmEncryptedData(_g, &((*_odata).enc_part), &((*_cdata).enc_part));
    if (_res)
	return _res;
    (void)_g;

    return _res;
}


static int _cm_seqof6(OssGlobal * _g, _seqof4 * * _odata, _seqof4 * * _cdata)
{
    int _res = 0;

    {
	_seqof4 *  _s_oss_tmp_1 = *_odata;
	_seqof4 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmPA_DATA(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmEncKDCRepPart(OssGlobal * _g, _EncKDCRepPart  * _odata, _EncKDCRepPart  * _cdata)
{
    int _res = 0;

    _res = _cmEncryptionKey(_g, &((*_odata).key), &((*_cdata).key));
    if (_res)
	return _res;
    _res = _cmLastReq(_g, &((*_odata).last_req), &((*_cdata).last_req));
    if (_res)
	return _res;
    if ((*_cdata).nonce != (*_odata).nonce)
	return 1;
    if (!(*_odata).key_expiration != !(*_cdata).key_expiration)
	return 1;
    if ((*_odata).key_expiration) {
	if (OSS_STRCMP(_g, (*_cdata).key_expiration, OSS_MAX_STR, (*_odata).key_expiration, _g->_res))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).key_expiration, (*_odata).key_expiration, 0))
#endif
		return 1;
    }
    if (_oss_cmp_arrbits(((*_odata).flags).value, ((*_cdata).flags).value, ((*_odata).flags).length, ((*_cdata).flags).length))
	return 1;
    if (OSS_STRCMP(_g, (*_cdata).authtime, OSS_MAX_STR, (*_odata).authtime, _g->_res))
#ifdef BAD_OID_IRI
	if (_oss_cmp_str2time((*_cdata).authtime, (*_odata).authtime, 0))
#endif
	    return 1;
    if (!(*_odata).starttime != !(*_cdata).starttime)
	return 1;
    if ((*_odata).starttime) {
	if (OSS_STRCMP(_g, (*_cdata).starttime, OSS_MAX_STR, (*_odata).starttime, _g->_res))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).starttime, (*_odata).starttime, 0))
#endif
		return 1;
    }
    if (OSS_STRCMP(_g, (*_cdata).endtime, OSS_MAX_STR, (*_odata).endtime, _g->_res))
#ifdef BAD_OID_IRI
	if (_oss_cmp_str2time((*_cdata).endtime, (*_odata).endtime, 0))
#endif
	    return 1;
    if (!(*_odata).renew_till != !(*_cdata).renew_till)
	return 1;
    if ((*_odata).renew_till) {
	if (OSS_STRCMP(_g, (*_cdata).renew_till, OSS_MAX_STR, (*_odata).renew_till, _g->_res))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).renew_till, (*_odata).renew_till, 0))
#endif
		return 1;
    }
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).srealm), &((*_cdata).srealm), sizeof(((*_cdata).srealm).length), sizeof(((*_cdata).srealm).value[0]), (unsigned int)((char *)&((*_odata).srealm).value - (char *)&((*_odata).srealm))))
	return 1;
    _res = _cmPrincipalName(_g, &((*_odata).sname), &((*_cdata).sname));
    if (_res)
	return _res;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cmHostAddresses(_g, &((*_odata).caddr), &((*_cdata).caddr));
	if (_res)
	    return _res;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	_res = _cm_seqof6(_g, &((*_odata).encrypted_pa_data), &((*_cdata).encrypted_pa_data));
	if (_res)
	    return _res;
    }
    (void)_g;

    return _res;
}


static int _cm_seq2(OssGlobal * _g, _seq2  * _odata, _seq2  * _cdata)
{
    int _res = 0;

    if ((*_cdata).lr_type != (*_odata).lr_type)
	return 1;
    if (OSS_STRCMP(_g, (*_cdata).lr_value, OSS_MAX_STR, (*_odata).lr_value, _g->_res))
#ifdef BAD_OID_IRI
	if (_oss_cmp_str2time((*_cdata).lr_value, (*_odata).lr_value, 0))
#endif
	    return 1;
    (void)_g;

    return _res;
}


static int _cmLastReq(OssGlobal * _g, _LastReq * * _odata, _LastReq * * _cdata)
{
    int _res = 0;

    {
	_LastReq *  _s_oss_tmp_1 = *_odata;
	_LastReq *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cm_seq2(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmExternalPrincipalIdentifier(OssGlobal * _g, _ExternalPrincipalIdentifier  * _odata, _ExternalPrincipalIdentifier  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).subjectName), &((*_cdata).subjectName), sizeof(((*_cdata).subjectName).length), sizeof(((*_cdata).subjectName).value[0]), (unsigned int)((char *)&((*_odata).subjectName).value - (char *)&((*_odata).subjectName))))
	    return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).issuerAndSerialNumber), &((*_cdata).issuerAndSerialNumber), sizeof(((*_cdata).issuerAndSerialNumber).length), sizeof(((*_cdata).issuerAndSerialNumber).value[0]), (unsigned int)((char *)&((*_odata).issuerAndSerialNumber).value - (char *)&((*_odata).issuerAndSerialNumber))))
	    return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x20000000)
	return 1;
    if ((*_odata).bit_mask & 0x20000000) {
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).subjectKeyIdentifier), &((*_cdata).subjectKeyIdentifier), sizeof(((*_cdata).subjectKeyIdentifier).length), sizeof(((*_cdata).subjectKeyIdentifier).value[0]), (unsigned int)((char *)&((*_odata).subjectKeyIdentifier).value - (char *)&((*_odata).subjectKeyIdentifier))))
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmAlgorithmIdentifier(OssGlobal * _g, _AlgorithmIdentifier  * _odata, _AlgorithmIdentifier  * _cdata)
{
    int _res = 0;

    if (!((*_cdata).algorithm).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).algorithm), &((*_cdata).algorithm), sizeof(((*_cdata).algorithm).length), sizeof(((*_cdata).algorithm).value[0]), (unsigned int)((char *)&((*_odata).algorithm).value - (char *)&((*_odata).algorithm))))
	return 1;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).parameters), &((*_cdata).parameters), sizeof(((*_cdata).parameters).length), sizeof(((*_cdata).parameters).value[0]), (unsigned int)((char *)&((*_odata).parameters).value - (char *)&((*_odata).parameters))))
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmSubjectPublicKeyInfo(OssGlobal * _g, _SubjectPublicKeyInfo  * _odata, _SubjectPublicKeyInfo  * _cdata)
{
    int _res = 0;

    _res = _cmAlgorithmIdentifier(_g, &((*_odata).algorithm), &((*_cdata).algorithm));
    if (_res)
	return _res;
    if (_oss_cmp_arrbits(((*_odata).subjectPublicKey).value, ((*_cdata).subjectPublicKey).value, ((*_odata).subjectPublicKey).length, ((*_cdata).subjectPublicKey).length))
	return 1;
    (void)_g;

    return _res;
}


static int _cmName(OssGlobal * _g, _Name  * _odata, _Name  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    _res = _cmRDNSequence(_g, &((*_odata).u.rdnSequence), &((*_cdata).u.rdnSequence));
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmRDNSequence(OssGlobal * _g, _RDNSequence * * _odata, _RDNSequence * * _cdata)
{
    int _res = 0;

    {
	_RDNSequence *  _s_oss_tmp_1 = *_odata;
	_RDNSequence *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    {
		_RelativeDistinguishedName *  _s_2 = _s_oss_tmp_1->value;
		_RelativeDistinguishedName *  _d_2 = _d_oss_tmp_1->value;
		long        *_a, _i, _i_next, _c = 0L;

		while (_s_2 && _d_2) {
		    ++ _c;
		    _s_2 = _s_2->next;
		    _d_2 = _d_2->next;
		}
		if (_s_2 || _d_2)
		    return 1;
		if (_c) {
		    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		    for (_i = 0; _i < _c; _i ++)
			_a[_i] = _i;
		    _a[_c] = -1L;
		    for (_s_2 = _s_oss_tmp_1->value; _s_2; _s_2 = _s_2->next) {
			_i_next = _a[0]; _res = 1;
			for (_d_2 = _d_oss_tmp_1->value, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			    if (_i < _i_next)
				continue;
			    if (!((_d_2->value).type).length)
				continue;
			    if (_oss_cmp_unbnd_octet_ia(&((_s_2->value).type), &((_d_2->value).type), sizeof(((_d_2->value).type).length), sizeof(((_d_2->value).type).value[0]), (unsigned int)((char *)&((_s_2->value).type).value - (char *)&((_s_2->value).type))))
				continue;
			    if (_oss_cmp_unbnd_octet_ia(&((_s_2->value).value), &((_d_2->value).value), sizeof(((_d_2->value).value).length), sizeof(((_d_2->value).value).value[0]), (unsigned int)((char *)&((_s_2->value).value).value - (char *)&((_s_2->value).value))))
				continue;
			    _res = 0; _a[_i] = _a[_i+1];
			    break;
			}
			if (_res)
			    break;
		    }
		    _oss_dec_freetempmem(_g, _a);
		    if (_res)
			return _res;
		}
	    }
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmTime(OssGlobal * _g, _Time  * _odata, _Time  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (OSS_STRCMP(_g, (*_cdata).u.utcTime, OSS_MAX_STR, (*_odata).u.utcTime, _g->_res))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time((*_cdata).u.utcTime, (*_odata).u.utcTime, 1))
#endif
		    return 1;
	}   break;
	case 2: {
	    if (OSS_STRCMP(_g, (*_cdata).u.generalTime, OSS_MAX_STR, (*_odata).u.generalTime, _g->_res))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time((*_cdata).u.generalTime, (*_odata).u.generalTime, 0))
#endif
		    return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmExtension(OssGlobal * _g, _Extension  * _odata, _Extension  * _cdata)
{
    int _res = 0;

    if (!((*_cdata).extnID).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).extnID), &((*_cdata).extnID), sizeof(((*_cdata).extnID).length), sizeof(((*_cdata).extnID).value[0]), (unsigned int)((char *)&((*_odata).extnID).value - (char *)&((*_odata).extnID))))
	return 1;
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x80000000) {
	if (((*_cdata).critical ^ (*_odata).critical) & 0x01)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x80000000) {
	    if ((Extension::default_critical ^ (*_odata).critical) & 0x01)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x80000000) {
	    if (((*_cdata).critical ^ Extension::default_critical) & 0x01)
		return 1;
	}
    }
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).extnValue), &((*_cdata).extnValue), sizeof(((*_cdata).extnValue).length), sizeof(((*_cdata).extnValue).value[0]), (unsigned int)((char *)&((*_odata).extnValue).value - (char *)&((*_odata).extnValue))))
	return 1;
    (void)_g;

    return _res;
}


static int _cmExtensions(OssGlobal * _g, _Extensions * * _odata, _Extensions * * _cdata)
{
    int _res = 0;

    {
	_Extensions *  _s_oss_tmp_1 = *_odata;
	_Extensions *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmExtension(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmPDSParameter(OssGlobal * _g, _PDSParameter  * _odata, _PDSParameter  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).printable_string), &((*_cdata).printable_string), sizeof(((*_cdata).printable_string).length), sizeof(((*_cdata).printable_string).value[0]), (unsigned int)((char *)&((*_odata).printable_string).value - (char *)&((*_odata).printable_string))))
	    return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).teletex_string), &((*_cdata).teletex_string), sizeof(((*_cdata).teletex_string).length), sizeof(((*_cdata).teletex_string).value[0]), (unsigned int)((char *)&((*_odata).teletex_string).value - (char *)&((*_odata).teletex_string))))
	    return 1;
    }
    (void)_g;

    return _res;
}


int DLL_ENTRY_FDEF _CMMS_SFU_KILE(struct ossGlobal * _g, int _pduNum, void * _odata, void * _cdata)
{
    int _res = 0;

    if (_pduNum <= 0 || _pduNum > 92)
	return PDU_RANGE;
    switch (_pduNum) {
	case 1: {
	    _res = _cmTicket(_g, (_Ticket  *)_odata, (_Ticket  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 2: {
	    if (_oss_cmp_arrbits(((*(_EncTicketPart  *)_odata).flags).value, ((*(_EncTicketPart  *)_cdata).flags).value, ((*(_EncTicketPart  *)_odata).flags).length, ((*(_EncTicketPart  *)_cdata).flags).length))
		return 1;
	    _res = _cmEncryptionKey(_g, &((*(_EncTicketPart  *)_odata).key), &((*(_EncTicketPart  *)_cdata).key));
	    if (_res)
		return _res;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_EncTicketPart  *)_odata).crealm), &((*(_EncTicketPart  *)_cdata).crealm), sizeof(((*(_EncTicketPart  *)_cdata).crealm).length), sizeof(((*(_EncTicketPart  *)_cdata).crealm).value[0]), (unsigned int)((char *)&((*(_EncTicketPart  *)_odata).crealm).value - (char *)&((*(_EncTicketPart  *)_odata).crealm))))
		return 1;
	    _res = _cmPrincipalName(_g, &((*(_EncTicketPart  *)_odata).cname), &((*(_EncTicketPart  *)_cdata).cname));
	    if (_res)
		return _res;
	    if (((*(_EncTicketPart  *)_cdata).transited).tr_type != ((*(_EncTicketPart  *)_odata).transited).tr_type)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&(((*(_EncTicketPart  *)_odata).transited).contents), &(((*(_EncTicketPart  *)_cdata).transited).contents), sizeof((((*(_EncTicketPart  *)_cdata).transited).contents).length), sizeof((((*(_EncTicketPart  *)_cdata).transited).contents).value[0]), (unsigned int)((char *)&(((*(_EncTicketPart  *)_odata).transited).contents).value - (char *)&(((*(_EncTicketPart  *)_odata).transited).contents))))
		return 1;
	    if (OSS_STRCMP(_g, (*(_EncTicketPart  *)_cdata).authtime, OSS_MAX_STR, (*(_EncTicketPart  *)_odata).authtime, _g->_res))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time((*(_EncTicketPart  *)_cdata).authtime, (*(_EncTicketPart  *)_odata).authtime, 0))
#endif
		    return 1;
	    if (!(*(_EncTicketPart  *)_odata).starttime != !(*(_EncTicketPart  *)_cdata).starttime)
		return 1;
	    if ((*(_EncTicketPart  *)_odata).starttime) {
		if (OSS_STRCMP(_g, (*(_EncTicketPart  *)_cdata).starttime, OSS_MAX_STR, (*(_EncTicketPart  *)_odata).starttime, _g->_res))
#ifdef BAD_OID_IRI
		    if (_oss_cmp_str2time((*(_EncTicketPart  *)_cdata).starttime, (*(_EncTicketPart  *)_odata).starttime, 0))
#endif
			return 1;
	    }
	    if (OSS_STRCMP(_g, (*(_EncTicketPart  *)_cdata).endtime, OSS_MAX_STR, (*(_EncTicketPart  *)_odata).endtime, _g->_res))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time((*(_EncTicketPart  *)_cdata).endtime, (*(_EncTicketPart  *)_odata).endtime, 0))
#endif
		    return 1;
	    if (!(*(_EncTicketPart  *)_odata).renew_till != !(*(_EncTicketPart  *)_cdata).renew_till)
		return 1;
	    if ((*(_EncTicketPart  *)_odata).renew_till) {
		if (OSS_STRCMP(_g, (*(_EncTicketPart  *)_cdata).renew_till, OSS_MAX_STR, (*(_EncTicketPart  *)_odata).renew_till, _g->_res))
#ifdef BAD_OID_IRI
		    if (_oss_cmp_str2time((*(_EncTicketPart  *)_cdata).renew_till, (*(_EncTicketPart  *)_odata).renew_till, 0))
#endif
			return 1;
	    }
	    if (((*(_EncTicketPart  *)_odata).bit_mask ^ (*(_EncTicketPart  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_EncTicketPart  *)_odata).bit_mask & 0x80000000) {
		_res = _cmHostAddresses(_g, &((*(_EncTicketPart  *)_odata).caddr), &((*(_EncTicketPart  *)_cdata).caddr));
		if (_res)
		    return _res;
	    }
	    if (((*(_EncTicketPart  *)_odata).bit_mask ^ (*(_EncTicketPart  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_EncTicketPart  *)_odata).bit_mask & 0x40000000) {
		_res = _cmAuthorizationData(_g, &((*(_EncTicketPart  *)_odata).authorization_data), &((*(_EncTicketPart  *)_cdata).authorization_data));
		if (_res)
		    return _res;
	    }
	} break;
	case 3: {
	    _res = _cmKDC_REQ(_g, (_KDC_REQ  *)_odata, (_KDC_REQ  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 4: {
	    _res = _cmKDC_REQ(_g, (_KDC_REQ  *)_odata, (_KDC_REQ  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 5: {
	    _res = _cmKDC_REQ_BODY(_g, (_KDC_REQ_BODY  *)_odata, (_KDC_REQ_BODY  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 6: {
	    _res = _cmKDC_REP(_g, (_KDC_REP  *)_odata, (_KDC_REP  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 7: {
	    _res = _cmKDC_REP(_g, (_KDC_REP  *)_odata, (_KDC_REP  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 8: {
	    _res = _cmEncKDCRepPart(_g, (_EncKDCRepPart  *)_odata, (_EncKDCRepPart  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 9: {
	    _res = _cmEncKDCRepPart(_g, (_EncKDCRepPart  *)_odata, (_EncKDCRepPart  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 10: {
	    if ((*(_AP_REQ  *)_cdata).pvno != (*(_AP_REQ  *)_odata).pvno)
		return 1;
	    if ((*(_AP_REQ  *)_cdata).msg_type != (*(_AP_REQ  *)_odata).msg_type)
		return 1;
	    if (_oss_cmp_arrbits(((*(_AP_REQ  *)_odata).ap_options).value, ((*(_AP_REQ  *)_cdata).ap_options).value, ((*(_AP_REQ  *)_odata).ap_options).length, ((*(_AP_REQ  *)_cdata).ap_options).length))
		return 1;
	    _res = _cmTicket(_g, &((*(_AP_REQ  *)_odata).ticket), &((*(_AP_REQ  *)_cdata).ticket));
	    if (_res)
		return _res;
	    _res = _cmEncryptedData(_g, &((*(_AP_REQ  *)_odata).authenticator), &((*(_AP_REQ  *)_cdata).authenticator));
	    if (_res)
		return _res;
	} break;
	case 11: {
	    if ((*(_Authenticator  *)_cdata).authenticator_vno != (*(_Authenticator  *)_odata).authenticator_vno)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_Authenticator  *)_odata).crealm), &((*(_Authenticator  *)_cdata).crealm), sizeof(((*(_Authenticator  *)_cdata).crealm).length), sizeof(((*(_Authenticator  *)_cdata).crealm).value[0]), (unsigned int)((char *)&((*(_Authenticator  *)_odata).crealm).value - (char *)&((*(_Authenticator  *)_odata).crealm))))
		return 1;
	    _res = _cmPrincipalName(_g, &((*(_Authenticator  *)_odata).cname), &((*(_Authenticator  *)_cdata).cname));
	    if (_res)
		return _res;
	    if (((*(_Authenticator  *)_odata).bit_mask ^ (*(_Authenticator  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_Authenticator  *)_odata).bit_mask & 0x80000000) {
		_res = _cmChecksum(_g, &((*(_Authenticator  *)_odata).cksum), &((*(_Authenticator  *)_cdata).cksum));
		if (_res)
		    return _res;
	    }
	    if ((*(_Authenticator  *)_cdata).cusec != (*(_Authenticator  *)_odata).cusec)
		return 1;
	    if (OSS_STRCMP(_g, (*(_Authenticator  *)_cdata).ctime, OSS_MAX_STR, (*(_Authenticator  *)_odata).ctime, _g->_res))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time((*(_Authenticator  *)_cdata).ctime, (*(_Authenticator  *)_odata).ctime, 0))
#endif
		    return 1;
	    if (((*(_Authenticator  *)_odata).bit_mask ^ (*(_Authenticator  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_Authenticator  *)_odata).bit_mask & 0x40000000) {
		_res = _cmEncryptionKey(_g, &((*(_Authenticator  *)_odata).subkey), &((*(_Authenticator  *)_cdata).subkey));
		if (_res)
		    return _res;
	    }
	    if (((*(_Authenticator  *)_odata).bit_mask ^ (*(_Authenticator  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_Authenticator  *)_odata).bit_mask & 0x20000000) {
		if ((*(_Authenticator  *)_cdata).seq_number != (*(_Authenticator  *)_odata).seq_number)
		    return 1;
	    }
	    if (((*(_Authenticator  *)_odata).bit_mask ^ (*(_Authenticator  *)_cdata).bit_mask) & 0x10000000)
		return 1;
	    if ((*(_Authenticator  *)_odata).bit_mask & 0x10000000) {
		_res = _cmAuthorizationData(_g, &((*(_Authenticator  *)_odata).authorization_data), &((*(_Authenticator  *)_cdata).authorization_data));
		if (_res)
		    return _res;
	    }
	} break;
	case 12: {
	    if ((*(_AP_REP  *)_cdata).pvno != (*(_AP_REP  *)_odata).pvno)
		return 1;
	    if ((*(_AP_REP  *)_cdata).msg_type != (*(_AP_REP  *)_odata).msg_type)
		return 1;
	    _res = _cmEncryptedData(_g, &((*(_AP_REP  *)_odata).enc_part), &((*(_AP_REP  *)_cdata).enc_part));
	    if (_res)
		return _res;
	} break;
	case 13: {
	    if (OSS_STRCMP(_g, (*(_EncAPRepPart  *)_cdata).ctime, OSS_MAX_STR, (*(_EncAPRepPart  *)_odata).ctime, _g->_res))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time((*(_EncAPRepPart  *)_cdata).ctime, (*(_EncAPRepPart  *)_odata).ctime, 0))
#endif
		    return 1;
	    if ((*(_EncAPRepPart  *)_cdata).cusec != (*(_EncAPRepPart  *)_odata).cusec)
		return 1;
	    if (((*(_EncAPRepPart  *)_odata).bit_mask ^ (*(_EncAPRepPart  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_EncAPRepPart  *)_odata).bit_mask & 0x80000000) {
		_res = _cmEncryptionKey(_g, &((*(_EncAPRepPart  *)_odata).subkey), &((*(_EncAPRepPart  *)_cdata).subkey));
		if (_res)
		    return _res;
	    }
	    if (((*(_EncAPRepPart  *)_odata).bit_mask ^ (*(_EncAPRepPart  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_EncAPRepPart  *)_odata).bit_mask & 0x40000000) {
		if ((*(_EncAPRepPart  *)_cdata).seq_number != (*(_EncAPRepPart  *)_odata).seq_number)
		    return 1;
	    }
	} break;
	case 14: {
	    if ((*(_KRB_SAFE  *)_cdata).pvno != (*(_KRB_SAFE  *)_odata).pvno)
		return 1;
	    if ((*(_KRB_SAFE  *)_cdata).msg_type != (*(_KRB_SAFE  *)_odata).msg_type)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&(((*(_KRB_SAFE  *)_odata).safe_body).user_data), &(((*(_KRB_SAFE  *)_cdata).safe_body).user_data), sizeof((((*(_KRB_SAFE  *)_cdata).safe_body).user_data).length), sizeof((((*(_KRB_SAFE  *)_cdata).safe_body).user_data).value[0]), (unsigned int)((char *)&(((*(_KRB_SAFE  *)_odata).safe_body).user_data).value - (char *)&(((*(_KRB_SAFE  *)_odata).safe_body).user_data))))
		return 1;
	    if (!((*(_KRB_SAFE  *)_odata).safe_body).timestamp != !((*(_KRB_SAFE  *)_cdata).safe_body).timestamp)
		return 1;
	    if (((*(_KRB_SAFE  *)_odata).safe_body).timestamp) {
		if (OSS_STRCMP(_g, ((*(_KRB_SAFE  *)_cdata).safe_body).timestamp, OSS_MAX_STR, ((*(_KRB_SAFE  *)_odata).safe_body).timestamp, _g->_res))
#ifdef BAD_OID_IRI
		    if (_oss_cmp_str2time(((*(_KRB_SAFE  *)_cdata).safe_body).timestamp, ((*(_KRB_SAFE  *)_odata).safe_body).timestamp, 0))
#endif
			return 1;
	    }
	    if ((((*(_KRB_SAFE  *)_odata).safe_body).bit_mask ^ ((*(_KRB_SAFE  *)_cdata).safe_body).bit_mask) & 0x80000000)
		return 1;
	    if (((*(_KRB_SAFE  *)_odata).safe_body).bit_mask & 0x80000000) {
		if (((*(_KRB_SAFE  *)_cdata).safe_body).usec != ((*(_KRB_SAFE  *)_odata).safe_body).usec)
		    return 1;
	    }
	    if ((((*(_KRB_SAFE  *)_odata).safe_body).bit_mask ^ ((*(_KRB_SAFE  *)_cdata).safe_body).bit_mask) & 0x40000000)
		return 1;
	    if (((*(_KRB_SAFE  *)_odata).safe_body).bit_mask & 0x40000000) {
		if (((*(_KRB_SAFE  *)_cdata).safe_body).seq_number != ((*(_KRB_SAFE  *)_odata).safe_body).seq_number)
		    return 1;
	    }
	    _res = _cmHostAddress(_g, &(((*(_KRB_SAFE  *)_odata).safe_body).s_address), &(((*(_KRB_SAFE  *)_cdata).safe_body).s_address));
	    if (_res)
		return _res;
	    if ((((*(_KRB_SAFE  *)_odata).safe_body).bit_mask ^ ((*(_KRB_SAFE  *)_cdata).safe_body).bit_mask) & 0x20000000)
		return 1;
	    if (((*(_KRB_SAFE  *)_odata).safe_body).bit_mask & 0x20000000) {
		_res = _cmHostAddress(_g, &(((*(_KRB_SAFE  *)_odata).safe_body).r_address), &(((*(_KRB_SAFE  *)_cdata).safe_body).r_address));
		if (_res)
		    return _res;
	    }
	    _res = _cmChecksum(_g, &((*(_KRB_SAFE  *)_odata).cksum), &((*(_KRB_SAFE  *)_cdata).cksum));
	    if (_res)
		return _res;
	} break;
	case 15: {
	    if ((*(_AP_REP  *)_cdata).pvno != (*(_AP_REP  *)_odata).pvno)
		return 1;
	    if ((*(_AP_REP  *)_cdata).msg_type != (*(_AP_REP  *)_odata).msg_type)
		return 1;
	    _res = _cmEncryptedData(_g, &((*(_AP_REP  *)_odata).enc_part), &((*(_AP_REP  *)_cdata).enc_part));
	    if (_res)
		return _res;
	} break;
	case 16: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_KRB_SAFE_BODY  *)_odata).user_data), &((*(_KRB_SAFE_BODY  *)_cdata).user_data), sizeof(((*(_KRB_SAFE_BODY  *)_cdata).user_data).length), sizeof(((*(_KRB_SAFE_BODY  *)_cdata).user_data).value[0]), (unsigned int)((char *)&((*(_KRB_SAFE_BODY  *)_odata).user_data).value - (char *)&((*(_KRB_SAFE_BODY  *)_odata).user_data))))
		return 1;
	    if (!(*(_KRB_SAFE_BODY  *)_odata).timestamp != !(*(_KRB_SAFE_BODY  *)_cdata).timestamp)
		return 1;
	    if ((*(_KRB_SAFE_BODY  *)_odata).timestamp) {
		if (OSS_STRCMP(_g, (*(_KRB_SAFE_BODY  *)_cdata).timestamp, OSS_MAX_STR, (*(_KRB_SAFE_BODY  *)_odata).timestamp, _g->_res))
#ifdef BAD_OID_IRI
		    if (_oss_cmp_str2time((*(_KRB_SAFE_BODY  *)_cdata).timestamp, (*(_KRB_SAFE_BODY  *)_odata).timestamp, 0))
#endif
			return 1;
	    }
	    if (((*(_KRB_SAFE_BODY  *)_odata).bit_mask ^ (*(_KRB_SAFE_BODY  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_KRB_SAFE_BODY  *)_odata).bit_mask & 0x80000000) {
		if ((*(_KRB_SAFE_BODY  *)_cdata).usec != (*(_KRB_SAFE_BODY  *)_odata).usec)
		    return 1;
	    }
	    if (((*(_KRB_SAFE_BODY  *)_odata).bit_mask ^ (*(_KRB_SAFE_BODY  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_KRB_SAFE_BODY  *)_odata).bit_mask & 0x40000000) {
		if ((*(_KRB_SAFE_BODY  *)_cdata).seq_number != (*(_KRB_SAFE_BODY  *)_odata).seq_number)
		    return 1;
	    }
	    _res = _cmHostAddress(_g, &((*(_KRB_SAFE_BODY  *)_odata).s_address), &((*(_KRB_SAFE_BODY  *)_cdata).s_address));
	    if (_res)
		return _res;
	    if (((*(_KRB_SAFE_BODY  *)_odata).bit_mask ^ (*(_KRB_SAFE_BODY  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_KRB_SAFE_BODY  *)_odata).bit_mask & 0x20000000) {
		_res = _cmHostAddress(_g, &((*(_KRB_SAFE_BODY  *)_odata).r_address), &((*(_KRB_SAFE_BODY  *)_cdata).r_address));
		if (_res)
		    return _res;
	    }
	} break;
	case 17: {
	    if ((*(_KRB_CRED  *)_cdata).pvno != (*(_KRB_CRED  *)_odata).pvno)
		return 1;
	    if ((*(_KRB_CRED  *)_cdata).msg_type != (*(_KRB_CRED  *)_odata).msg_type)
		return 1;
	    {
		_seqof3 *  _s_oss_tmp_2 = (*(_KRB_CRED  *)_odata).tickets;
		_seqof3 *  _d_oss_tmp_2 = (*(_KRB_CRED  *)_cdata).tickets;

		while (_s_oss_tmp_2 && _d_oss_tmp_2) {
		    _res = _cmTicket(_g, &(_s_oss_tmp_2->value), &(_d_oss_tmp_2->value));
		    if (_res)
			return _res;
		    _s_oss_tmp_2 = _s_oss_tmp_2->next;
		    _d_oss_tmp_2 = _d_oss_tmp_2->next;
		}
		if (_s_oss_tmp_2 || _d_oss_tmp_2)
		    return 1;
	    }
	    _res = _cmEncryptedData(_g, &((*(_KRB_CRED  *)_odata).enc_part), &((*(_KRB_CRED  *)_cdata).enc_part));
	    if (_res)
		return _res;
	} break;
	case 18: {
	    {
		_seqof8 *  _s_oss_tmp_2 = (*(_EncKrbCredPart  *)_odata).ticket_info;
		_seqof8 *  _d_oss_tmp_2 = (*(_EncKrbCredPart  *)_cdata).ticket_info;

		while (_s_oss_tmp_2 && _d_oss_tmp_2) {
		    _res = _cmEncryptionKey(_g, &((_s_oss_tmp_2->value).key), &((_d_oss_tmp_2->value).key));
		    if (_res)
			return _res;
		    if (((_s_oss_tmp_2->value).bit_mask ^ (_d_oss_tmp_2->value).bit_mask) & 0x80000000)
			return 1;
		    if ((_s_oss_tmp_2->value).bit_mask & 0x80000000) {
			if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_2->value).prealm), &((_d_oss_tmp_2->value).prealm), sizeof(((_d_oss_tmp_2->value).prealm).length), sizeof(((_d_oss_tmp_2->value).prealm).value[0]), (unsigned int)((char *)&((_s_oss_tmp_2->value).prealm).value - (char *)&((_s_oss_tmp_2->value).prealm))))
			    return 1;
		    }
		    if (((_s_oss_tmp_2->value).bit_mask ^ (_d_oss_tmp_2->value).bit_mask) & 0x40000000)
			return 1;
		    if ((_s_oss_tmp_2->value).bit_mask & 0x40000000) {
			_res = _cmPrincipalName(_g, &((_s_oss_tmp_2->value).pname), &((_d_oss_tmp_2->value).pname));
			if (_res)
			    return _res;
		    }
		    if (((_s_oss_tmp_2->value).bit_mask ^ (_d_oss_tmp_2->value).bit_mask) & 0x20000000)
			return 1;
		    if ((_s_oss_tmp_2->value).bit_mask & 0x20000000) {
			if (_oss_cmp_arrbits(((_s_oss_tmp_2->value).flags).value, ((_d_oss_tmp_2->value).flags).value, ((_s_oss_tmp_2->value).flags).length, ((_d_oss_tmp_2->value).flags).length))
			    return 1;
		    }
		    if (!(_s_oss_tmp_2->value).authtime != !(_d_oss_tmp_2->value).authtime)
			return 1;
		    if ((_s_oss_tmp_2->value).authtime) {
			if (OSS_STRCMP(_g, (_d_oss_tmp_2->value).authtime, OSS_MAX_STR, (_s_oss_tmp_2->value).authtime, _g->_res))
#ifdef BAD_OID_IRI
			    if (_oss_cmp_str2time((_d_oss_tmp_2->value).authtime, (_s_oss_tmp_2->value).authtime, 0))
#endif
				return 1;
		    }
		    if (!(_s_oss_tmp_2->value).starttime != !(_d_oss_tmp_2->value).starttime)
			return 1;
		    if ((_s_oss_tmp_2->value).starttime) {
			if (OSS_STRCMP(_g, (_d_oss_tmp_2->value).starttime, OSS_MAX_STR, (_s_oss_tmp_2->value).starttime, _g->_res))
#ifdef BAD_OID_IRI
			    if (_oss_cmp_str2time((_d_oss_tmp_2->value).starttime, (_s_oss_tmp_2->value).starttime, 0))
#endif
				return 1;
		    }
		    if (!(_s_oss_tmp_2->value).endtime != !(_d_oss_tmp_2->value).endtime)
			return 1;
		    if ((_s_oss_tmp_2->value).endtime) {
			if (OSS_STRCMP(_g, (_d_oss_tmp_2->value).endtime, OSS_MAX_STR, (_s_oss_tmp_2->value).endtime, _g->_res))
#ifdef BAD_OID_IRI
			    if (_oss_cmp_str2time((_d_oss_tmp_2->value).endtime, (_s_oss_tmp_2->value).endtime, 0))
#endif
				return 1;
		    }
		    if (!(_s_oss_tmp_2->value).renew_till != !(_d_oss_tmp_2->value).renew_till)
			return 1;
		    if ((_s_oss_tmp_2->value).renew_till) {
			if (OSS_STRCMP(_g, (_d_oss_tmp_2->value).renew_till, OSS_MAX_STR, (_s_oss_tmp_2->value).renew_till, _g->_res))
#ifdef BAD_OID_IRI
			    if (_oss_cmp_str2time((_d_oss_tmp_2->value).renew_till, (_s_oss_tmp_2->value).renew_till, 0))
#endif
				return 1;
		    }
		    if (((_s_oss_tmp_2->value).bit_mask ^ (_d_oss_tmp_2->value).bit_mask) & 0x10000000)
			return 1;
		    if ((_s_oss_tmp_2->value).bit_mask & 0x10000000) {
			if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_2->value).srealm), &((_d_oss_tmp_2->value).srealm), sizeof(((_d_oss_tmp_2->value).srealm).length), sizeof(((_d_oss_tmp_2->value).srealm).value[0]), (unsigned int)((char *)&((_s_oss_tmp_2->value).srealm).value - (char *)&((_s_oss_tmp_2->value).srealm))))
			    return 1;
		    }
		    if (((_s_oss_tmp_2->value).bit_mask ^ (_d_oss_tmp_2->value).bit_mask) & 0x8000000)
			return 1;
		    if ((_s_oss_tmp_2->value).bit_mask & 0x8000000) {
			_res = _cmPrincipalName(_g, &((_s_oss_tmp_2->value).sname), &((_d_oss_tmp_2->value).sname));
			if (_res)
			    return _res;
		    }
		    if (((_s_oss_tmp_2->value).bit_mask ^ (_d_oss_tmp_2->value).bit_mask) & 0x4000000)
			return 1;
		    if ((_s_oss_tmp_2->value).bit_mask & 0x4000000) {
			_res = _cmHostAddresses(_g, &((_s_oss_tmp_2->value).caddr), &((_d_oss_tmp_2->value).caddr));
			if (_res)
			    return _res;
		    }
		    _s_oss_tmp_2 = _s_oss_tmp_2->next;
		    _d_oss_tmp_2 = _d_oss_tmp_2->next;
		}
		if (_s_oss_tmp_2 || _d_oss_tmp_2)
		    return 1;
	    }
	    if (((*(_EncKrbCredPart  *)_odata).bit_mask ^ (*(_EncKrbCredPart  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_EncKrbCredPart  *)_odata).bit_mask & 0x80000000) {
		if ((*(_EncKrbCredPart  *)_cdata).nonce != (*(_EncKrbCredPart  *)_odata).nonce)
		    return 1;
	    }
	    if (!(*(_EncKrbCredPart  *)_odata).timestamp != !(*(_EncKrbCredPart  *)_cdata).timestamp)
		return 1;
	    if ((*(_EncKrbCredPart  *)_odata).timestamp) {
		if (OSS_STRCMP(_g, (*(_EncKrbCredPart  *)_cdata).timestamp, OSS_MAX_STR, (*(_EncKrbCredPart  *)_odata).timestamp, _g->_res))
#ifdef BAD_OID_IRI
		    if (_oss_cmp_str2time((*(_EncKrbCredPart  *)_cdata).timestamp, (*(_EncKrbCredPart  *)_odata).timestamp, 0))
#endif
			return 1;
	    }
	    if (((*(_EncKrbCredPart  *)_odata).bit_mask ^ (*(_EncKrbCredPart  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_EncKrbCredPart  *)_odata).bit_mask & 0x40000000) {
		if ((*(_EncKrbCredPart  *)_cdata).usec != (*(_EncKrbCredPart  *)_odata).usec)
		    return 1;
	    }
	    if (((*(_EncKrbCredPart  *)_odata).bit_mask ^ (*(_EncKrbCredPart  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_EncKrbCredPart  *)_odata).bit_mask & 0x20000000) {
		_res = _cmHostAddress(_g, &((*(_EncKrbCredPart  *)_odata).s_address), &((*(_EncKrbCredPart  *)_cdata).s_address));
		if (_res)
		    return _res;
	    }
	    if (((*(_EncKrbCredPart  *)_odata).bit_mask ^ (*(_EncKrbCredPart  *)_cdata).bit_mask) & 0x10000000)
		return 1;
	    if ((*(_EncKrbCredPart  *)_odata).bit_mask & 0x10000000) {
		_res = _cmHostAddress(_g, &((*(_EncKrbCredPart  *)_odata).r_address), &((*(_EncKrbCredPart  *)_cdata).r_address));
		if (_res)
		    return _res;
	    }
	} break;
	case 19: {
	    if ((*(_KRB_ERROR  *)_cdata).pvno != (*(_KRB_ERROR  *)_odata).pvno)
		return 1;
	    if ((*(_KRB_ERROR  *)_cdata).msg_type != (*(_KRB_ERROR  *)_odata).msg_type)
		return 1;
	    if (!(*(_KRB_ERROR  *)_odata).ctime != !(*(_KRB_ERROR  *)_cdata).ctime)
		return 1;
	    if ((*(_KRB_ERROR  *)_odata).ctime) {
		if (OSS_STRCMP(_g, (*(_KRB_ERROR  *)_cdata).ctime, OSS_MAX_STR, (*(_KRB_ERROR  *)_odata).ctime, _g->_res))
#ifdef BAD_OID_IRI
		    if (_oss_cmp_str2time((*(_KRB_ERROR  *)_cdata).ctime, (*(_KRB_ERROR  *)_odata).ctime, 0))
#endif
			return 1;
	    }
	    if (((*(_KRB_ERROR  *)_odata).bit_mask ^ (*(_KRB_ERROR  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_KRB_ERROR  *)_odata).bit_mask & 0x80000000) {
		if ((*(_KRB_ERROR  *)_cdata).cusec != (*(_KRB_ERROR  *)_odata).cusec)
		    return 1;
	    }
	    if (OSS_STRCMP(_g, (*(_KRB_ERROR  *)_cdata).stime, OSS_MAX_STR, (*(_KRB_ERROR  *)_odata).stime, _g->_res))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time((*(_KRB_ERROR  *)_cdata).stime, (*(_KRB_ERROR  *)_odata).stime, 0))
#endif
		    return 1;
	    if ((*(_KRB_ERROR  *)_cdata).susec != (*(_KRB_ERROR  *)_odata).susec)
		return 1;
	    if ((*(_KRB_ERROR  *)_cdata).error_code != (*(_KRB_ERROR  *)_odata).error_code)
		return 1;
	    if (((*(_KRB_ERROR  *)_odata).bit_mask ^ (*(_KRB_ERROR  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_KRB_ERROR  *)_odata).bit_mask & 0x40000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_KRB_ERROR  *)_odata).crealm), &((*(_KRB_ERROR  *)_cdata).crealm), sizeof(((*(_KRB_ERROR  *)_cdata).crealm).length), sizeof(((*(_KRB_ERROR  *)_cdata).crealm).value[0]), (unsigned int)((char *)&((*(_KRB_ERROR  *)_odata).crealm).value - (char *)&((*(_KRB_ERROR  *)_odata).crealm))))
		    return 1;
	    }
	    if (((*(_KRB_ERROR  *)_odata).bit_mask ^ (*(_KRB_ERROR  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_KRB_ERROR  *)_odata).bit_mask & 0x20000000) {
		_res = _cmPrincipalName(_g, &((*(_KRB_ERROR  *)_odata).cname), &((*(_KRB_ERROR  *)_cdata).cname));
		if (_res)
		    return _res;
	    }
	    if (_oss_cmp_unbnd_octet_ia(&((*(_KRB_ERROR  *)_odata).realm), &((*(_KRB_ERROR  *)_cdata).realm), sizeof(((*(_KRB_ERROR  *)_cdata).realm).length), sizeof(((*(_KRB_ERROR  *)_cdata).realm).value[0]), (unsigned int)((char *)&((*(_KRB_ERROR  *)_odata).realm).value - (char *)&((*(_KRB_ERROR  *)_odata).realm))))
		return 1;
	    _res = _cmPrincipalName(_g, &((*(_KRB_ERROR  *)_odata).sname), &((*(_KRB_ERROR  *)_cdata).sname));
	    if (_res)
		return _res;
	    if (((*(_KRB_ERROR  *)_odata).bit_mask ^ (*(_KRB_ERROR  *)_cdata).bit_mask) & 0x10000000)
		return 1;
	    if ((*(_KRB_ERROR  *)_odata).bit_mask & 0x10000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_KRB_ERROR  *)_odata).e_text), &((*(_KRB_ERROR  *)_cdata).e_text), sizeof(((*(_KRB_ERROR  *)_cdata).e_text).length), sizeof(((*(_KRB_ERROR  *)_cdata).e_text).value[0]), (unsigned int)((char *)&((*(_KRB_ERROR  *)_odata).e_text).value - (char *)&((*(_KRB_ERROR  *)_odata).e_text))))
		    return 1;
	    }
	    if (((*(_KRB_ERROR  *)_odata).bit_mask ^ (*(_KRB_ERROR  *)_cdata).bit_mask) & 0x8000000)
		return 1;
	    if ((*(_KRB_ERROR  *)_odata).bit_mask & 0x8000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_KRB_ERROR  *)_odata).e_data), &((*(_KRB_ERROR  *)_cdata).e_data), sizeof(((*(_KRB_ERROR  *)_cdata).e_data).length), sizeof(((*(_KRB_ERROR  *)_cdata).e_data).value[0]), (unsigned int)((char *)&((*(_KRB_ERROR  *)_odata).e_data).value - (char *)&((*(_KRB_ERROR  *)_odata).e_data))))
		    return 1;
	    }
	} break;
	case 20: {
	    {
		_seqof4 *  _s_oss_tmp_1 = *(_seqof4 * *)_odata;
		_seqof4 *  _d_oss_tmp_1 = *(_seqof4 * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    _res = _cmPA_DATA(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
		    if (_res)
			return _res;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 21: {
	    {
		_TYPED_DATA *  _s_oss_tmp_1 = *(_TYPED_DATA * *)_odata;
		_TYPED_DATA *  _d_oss_tmp_1 = *(_TYPED_DATA * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    if ((_d_oss_tmp_1->value).data_type != (_s_oss_tmp_1->value).data_type)
			return 1;
		    if (((_s_oss_tmp_1->value).bit_mask ^ (_d_oss_tmp_1->value).bit_mask) & 0x80000000)
			return 1;
		    if ((_s_oss_tmp_1->value).bit_mask & 0x80000000) {
			if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_1->value).data_value), &((_d_oss_tmp_1->value).data_value), sizeof(((_d_oss_tmp_1->value).data_value).length), sizeof(((_d_oss_tmp_1->value).data_value).value[0]), (unsigned int)((char *)&((_s_oss_tmp_1->value).data_value).value - (char *)&((_s_oss_tmp_1->value).data_value))))
			    return 1;
		    }
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 22: {
	    _res = _cmEncryptedData(_g, (_EncryptedData  *)_odata, (_EncryptedData  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 23: {
	    if (OSS_STRCMP(_g, (*(_PA_ENC_TS_ENC  *)_cdata).patimestamp, OSS_MAX_STR, (*(_PA_ENC_TS_ENC  *)_odata).patimestamp, _g->_res))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time((*(_PA_ENC_TS_ENC  *)_cdata).patimestamp, (*(_PA_ENC_TS_ENC  *)_odata).patimestamp, 0))
#endif
		    return 1;
	    if (((*(_PA_ENC_TS_ENC  *)_odata).bit_mask ^ (*(_PA_ENC_TS_ENC  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_PA_ENC_TS_ENC  *)_odata).bit_mask & 0x80000000) {
		if ((*(_PA_ENC_TS_ENC  *)_cdata).pausec != (*(_PA_ENC_TS_ENC  *)_odata).pausec)
		    return 1;
	    }
	} break;
	case 24: {
	    {
		_ETYPE_INFO *  _s_oss_tmp_1 = *(_ETYPE_INFO * *)_odata;
		_ETYPE_INFO *  _d_oss_tmp_1 = *(_ETYPE_INFO * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    if ((_d_oss_tmp_1->value).etype != (_s_oss_tmp_1->value).etype)
			return 1;
		    if (((_s_oss_tmp_1->value).bit_mask ^ (_d_oss_tmp_1->value).bit_mask) & 0x80000000)
			return 1;
		    if ((_s_oss_tmp_1->value).bit_mask & 0x80000000) {
			if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_1->value).salt), &((_d_oss_tmp_1->value).salt), sizeof(((_d_oss_tmp_1->value).salt).length), sizeof(((_d_oss_tmp_1->value).salt).value[0]), (unsigned int)((char *)&((_s_oss_tmp_1->value).salt).value - (char *)&((_s_oss_tmp_1->value).salt))))
			    return 1;
		    }
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 25: {
	    {
		_ETYPE_INFO2 *  _s_oss_tmp_1 = *(_ETYPE_INFO2 * *)_odata;
		_ETYPE_INFO2 *  _d_oss_tmp_1 = *(_ETYPE_INFO2 * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    if ((_d_oss_tmp_1->value).etype != (_s_oss_tmp_1->value).etype)
			return 1;
		    if (((_s_oss_tmp_1->value).bit_mask ^ (_d_oss_tmp_1->value).bit_mask) & 0x80000000)
			return 1;
		    if ((_s_oss_tmp_1->value).bit_mask & 0x80000000) {
			if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_1->value).salt), &((_d_oss_tmp_1->value).salt), sizeof(((_d_oss_tmp_1->value).salt).length), sizeof(((_d_oss_tmp_1->value).salt).value[0]), (unsigned int)((char *)&((_s_oss_tmp_1->value).salt).value - (char *)&((_s_oss_tmp_1->value).salt))))
			    return 1;
		    }
		    if (((_s_oss_tmp_1->value).bit_mask ^ (_d_oss_tmp_1->value).bit_mask) & 0x40000000)
			return 1;
		    if ((_s_oss_tmp_1->value).bit_mask & 0x40000000) {
			if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_1->value).s2kparams), &((_d_oss_tmp_1->value).s2kparams), sizeof(((_d_oss_tmp_1->value).s2kparams).length), sizeof(((_d_oss_tmp_1->value).s2kparams).value[0]), (unsigned int)((char *)&((_s_oss_tmp_1->value).s2kparams).value - (char *)&((_s_oss_tmp_1->value).s2kparams))))
			    return 1;
		    }
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 26: {
	    _res = _cmAuthorizationData(_g, (_AuthorizationData * *)_odata, (_AuthorizationData * *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 27: {
	    _res = _cmChecksum(_g, &((*(_AD_KDCIssued  *)_odata).ad_checksum), &((*(_AD_KDCIssued  *)_cdata).ad_checksum));
	    if (_res)
		return _res;
	    if (((*(_AD_KDCIssued  *)_odata).bit_mask ^ (*(_AD_KDCIssued  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_AD_KDCIssued  *)_odata).bit_mask & 0x80000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_AD_KDCIssued  *)_odata).i_realm), &((*(_AD_KDCIssued  *)_cdata).i_realm), sizeof(((*(_AD_KDCIssued  *)_cdata).i_realm).length), sizeof(((*(_AD_KDCIssued  *)_cdata).i_realm).value[0]), (unsigned int)((char *)&((*(_AD_KDCIssued  *)_odata).i_realm).value - (char *)&((*(_AD_KDCIssued  *)_odata).i_realm))))
		    return 1;
	    }
	    if (((*(_AD_KDCIssued  *)_odata).bit_mask ^ (*(_AD_KDCIssued  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_AD_KDCIssued  *)_odata).bit_mask & 0x40000000) {
		_res = _cmPrincipalName(_g, &((*(_AD_KDCIssued  *)_odata).i_sname), &((*(_AD_KDCIssued  *)_cdata).i_sname));
		if (_res)
		    return _res;
	    }
	    _res = _cmAuthorizationData(_g, &((*(_AD_KDCIssued  *)_odata).elements), &((*(_AD_KDCIssued  *)_cdata).elements));
	    if (_res)
		return _res;
	} break;
	case 28: {
	    if ((*(_AD_AND_OR  *)_cdata).condition_count != (*(_AD_AND_OR  *)_odata).condition_count)
		return 1;
	    _res = _cmAuthorizationData(_g, &((*(_AD_AND_OR  *)_odata).elements), &((*(_AD_AND_OR  *)_cdata).elements));
	    if (_res)
		return _res;
	} break;
	case 29: {
	    _res = _cmAuthorizationData(_g, (_AuthorizationData * *)_odata, (_AuthorizationData * *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 30: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_ChangePasswdData  *)_odata).newpasswd), &((*(_ChangePasswdData  *)_cdata).newpasswd), sizeof(((*(_ChangePasswdData  *)_cdata).newpasswd).length), sizeof(((*(_ChangePasswdData  *)_cdata).newpasswd).value[0]), (unsigned int)((char *)&((*(_ChangePasswdData  *)_odata).newpasswd).value - (char *)&((*(_ChangePasswdData  *)_odata).newpasswd))))
		return 1;
	    if (((*(_ChangePasswdData  *)_odata).bit_mask ^ (*(_ChangePasswdData  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_ChangePasswdData  *)_odata).bit_mask & 0x80000000) {
		_res = _cmPrincipalName(_g, &((*(_ChangePasswdData  *)_odata).targname), &((*(_ChangePasswdData  *)_cdata).targname));
		if (_res)
		    return _res;
	    }
	    if (((*(_ChangePasswdData  *)_odata).bit_mask ^ (*(_ChangePasswdData  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_ChangePasswdData  *)_odata).bit_mask & 0x40000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_ChangePasswdData  *)_odata).targrealm), &((*(_ChangePasswdData  *)_cdata).targrealm), sizeof(((*(_ChangePasswdData  *)_cdata).targrealm).length), sizeof(((*(_ChangePasswdData  *)_cdata).targrealm).value[0]), (unsigned int)((char *)&((*(_ChangePasswdData  *)_odata).targrealm).value - (char *)&((*(_ChangePasswdData  *)_odata).targrealm))))
		    return 1;
	    }
	} break;
	case 31: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_PA_PK_AS_REQ  *)_odata).signedAuthPack), &((*(_PA_PK_AS_REQ  *)_cdata).signedAuthPack), sizeof(((*(_PA_PK_AS_REQ  *)_cdata).signedAuthPack).length), sizeof(((*(_PA_PK_AS_REQ  *)_cdata).signedAuthPack).value[0]), (unsigned int)((char *)&((*(_PA_PK_AS_REQ  *)_odata).signedAuthPack).value - (char *)&((*(_PA_PK_AS_REQ  *)_odata).signedAuthPack))))
		return 1;
	    if (((*(_PA_PK_AS_REQ  *)_odata).bit_mask ^ (*(_PA_PK_AS_REQ  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_PA_PK_AS_REQ  *)_odata).bit_mask & 0x80000000) {
		{
		    _seqof9 *  _s_oss_tmp_2 = (*(_PA_PK_AS_REQ  *)_odata).trustedCertifiers;
		    _seqof9 *  _d_oss_tmp_2 = (*(_PA_PK_AS_REQ  *)_cdata).trustedCertifiers;

		    while (_s_oss_tmp_2 && _d_oss_tmp_2) {
			_res = _cmExternalPrincipalIdentifier(_g, &(_s_oss_tmp_2->value), &(_d_oss_tmp_2->value));
			if (_res)
			    return _res;
			_s_oss_tmp_2 = _s_oss_tmp_2->next;
			_d_oss_tmp_2 = _d_oss_tmp_2->next;
		    }
		    if (_s_oss_tmp_2 || _d_oss_tmp_2)
			return 1;
		}
	    }
	    if (((*(_PA_PK_AS_REQ  *)_odata).bit_mask ^ (*(_PA_PK_AS_REQ  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_PA_PK_AS_REQ  *)_odata).bit_mask & 0x40000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_PA_PK_AS_REQ  *)_odata).kdcPkId), &((*(_PA_PK_AS_REQ  *)_cdata).kdcPkId), sizeof(((*(_PA_PK_AS_REQ  *)_cdata).kdcPkId).length), sizeof(((*(_PA_PK_AS_REQ  *)_cdata).kdcPkId).value[0]), (unsigned int)((char *)&((*(_PA_PK_AS_REQ  *)_odata).kdcPkId).value - (char *)&((*(_PA_PK_AS_REQ  *)_odata).kdcPkId))))
		    return 1;
	    }
	} break;
	case 32: {
	    if (((*(_AuthPack  *)_cdata).pkAuthenticator).cusec != ((*(_AuthPack  *)_odata).pkAuthenticator).cusec)
		return 1;
	    if (OSS_STRCMP(_g, ((*(_AuthPack  *)_cdata).pkAuthenticator).ctime, OSS_MAX_STR, ((*(_AuthPack  *)_odata).pkAuthenticator).ctime, _g->_res))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time(((*(_AuthPack  *)_cdata).pkAuthenticator).ctime, ((*(_AuthPack  *)_odata).pkAuthenticator).ctime, 0))
#endif
		    return 1;
	    if (((*(_AuthPack  *)_cdata).pkAuthenticator).nonce != ((*(_AuthPack  *)_odata).pkAuthenticator).nonce)
		return 1;
	    if ((((*(_AuthPack  *)_odata).pkAuthenticator).bit_mask ^ ((*(_AuthPack  *)_cdata).pkAuthenticator).bit_mask) & 0x80000000)
		return 1;
	    if (((*(_AuthPack  *)_odata).pkAuthenticator).bit_mask & 0x80000000) {
		if (_oss_cmp_unbnd_octet_ia(&(((*(_AuthPack  *)_odata).pkAuthenticator).paChecksum), &(((*(_AuthPack  *)_cdata).pkAuthenticator).paChecksum), sizeof((((*(_AuthPack  *)_cdata).pkAuthenticator).paChecksum).length), sizeof((((*(_AuthPack  *)_cdata).pkAuthenticator).paChecksum).value[0]), (unsigned int)((char *)&(((*(_AuthPack  *)_odata).pkAuthenticator).paChecksum).value - (char *)&(((*(_AuthPack  *)_odata).pkAuthenticator).paChecksum))))
		    return 1;
	    }
	    if (((*(_AuthPack  *)_odata).bit_mask ^ (*(_AuthPack  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_AuthPack  *)_odata).bit_mask & 0x80000000) {
		_res = _cmSubjectPublicKeyInfo(_g, &((*(_AuthPack  *)_odata).clientPublicValue), &((*(_AuthPack  *)_cdata).clientPublicValue));
		if (_res)
		    return _res;
	    }
	    if (((*(_AuthPack  *)_odata).bit_mask ^ (*(_AuthPack  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_AuthPack  *)_odata).bit_mask & 0x40000000) {
		{
		    _seqof10 *  _s_oss_tmp_2 = (*(_AuthPack  *)_odata).supportedCMSTypes;
		    _seqof10 *  _d_oss_tmp_2 = (*(_AuthPack  *)_cdata).supportedCMSTypes;

		    while (_s_oss_tmp_2 && _d_oss_tmp_2) {
			_res = _cmAlgorithmIdentifier(_g, &(_s_oss_tmp_2->value), &(_d_oss_tmp_2->value));
			if (_res)
			    return _res;
			_s_oss_tmp_2 = _s_oss_tmp_2->next;
			_d_oss_tmp_2 = _d_oss_tmp_2->next;
		    }
		    if (_s_oss_tmp_2 || _d_oss_tmp_2)
			return 1;
		}
	    }
	    if (((*(_AuthPack  *)_odata).bit_mask ^ (*(_AuthPack  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_AuthPack  *)_odata).bit_mask & 0x20000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_AuthPack  *)_odata).clientDHNonce), &((*(_AuthPack  *)_cdata).clientDHNonce), sizeof(((*(_AuthPack  *)_cdata).clientDHNonce).length), sizeof(((*(_AuthPack  *)_cdata).clientDHNonce).value[0]), (unsigned int)((char *)&((*(_AuthPack  *)_odata).clientDHNonce).value - (char *)&((*(_AuthPack  *)_odata).clientDHNonce))))
		    return 1;
	    }
	} break;
	case 33: {
	    {
		_seqof9 *  _s_oss_tmp_1 = *(_seqof9 * *)_odata;
		_seqof9 *  _d_oss_tmp_1 = *(_seqof9 * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    _res = _cmExternalPrincipalIdentifier(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
		    if (_res)
			return _res;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 34: {
	    {
		_seqof9 *  _s_oss_tmp_1 = *(_seqof9 * *)_odata;
		_seqof9 *  _d_oss_tmp_1 = *(_seqof9 * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    _res = _cmExternalPrincipalIdentifier(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
		    if (_res)
			return _res;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 35: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_KRB5PrincipalName  *)_odata).realm), &((*(_KRB5PrincipalName  *)_cdata).realm), sizeof(((*(_KRB5PrincipalName  *)_cdata).realm).length), sizeof(((*(_KRB5PrincipalName  *)_cdata).realm).value[0]), (unsigned int)((char *)&((*(_KRB5PrincipalName  *)_odata).realm).value - (char *)&((*(_KRB5PrincipalName  *)_odata).realm))))
		return 1;
	    _res = _cmPrincipalName(_g, &((*(_KRB5PrincipalName  *)_odata).principalName), &((*(_KRB5PrincipalName  *)_cdata).principalName));
	    if (_res)
		return _res;
	} break;
	case 36: {
	    {
		_seqof9 *  _s_oss_tmp_1 = *(_seqof9 * *)_odata;
		_seqof9 *  _d_oss_tmp_1 = *(_seqof9 * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    _res = _cmExternalPrincipalIdentifier(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
		    if (_res)
			return _res;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 37: {
	    if ((*(_PA_PK_AS_REP  *)_odata).choice != (*(_PA_PK_AS_REP  *)_cdata).choice)
		return 1;
	    switch ((*(_PA_PK_AS_REP  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(*(_PA_PK_AS_REP  *)_odata).u.dhInfo).dhSignedData), &((*(*(_PA_PK_AS_REP  *)_cdata).u.dhInfo).dhSignedData), sizeof(((*(*(_PA_PK_AS_REP  *)_cdata).u.dhInfo).dhSignedData).length), sizeof(((*(*(_PA_PK_AS_REP  *)_cdata).u.dhInfo).dhSignedData).value[0]), (unsigned int)((char *)&((*(*(_PA_PK_AS_REP  *)_odata).u.dhInfo).dhSignedData).value - (char *)&((*(*(_PA_PK_AS_REP  *)_odata).u.dhInfo).dhSignedData))))
			return 1;
		    if (((*(*(_PA_PK_AS_REP  *)_odata).u.dhInfo).bit_mask ^ (*(*(_PA_PK_AS_REP  *)_cdata).u.dhInfo).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_PA_PK_AS_REP  *)_odata).u.dhInfo).bit_mask & 0x80000000) {
			if (_oss_cmp_unbnd_octet_ia(&((*(*(_PA_PK_AS_REP  *)_odata).u.dhInfo).serverDHNonce), &((*(*(_PA_PK_AS_REP  *)_cdata).u.dhInfo).serverDHNonce), sizeof(((*(*(_PA_PK_AS_REP  *)_cdata).u.dhInfo).serverDHNonce).length), sizeof(((*(*(_PA_PK_AS_REP  *)_cdata).u.dhInfo).serverDHNonce).value[0]), (unsigned int)((char *)&((*(*(_PA_PK_AS_REP  *)_odata).u.dhInfo).serverDHNonce).value - (char *)&((*(*(_PA_PK_AS_REP  *)_odata).u.dhInfo).serverDHNonce))))
			    return 1;
		    }
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_PA_PK_AS_REP  *)_odata).u.encKeyPack), &((*(_PA_PK_AS_REP  *)_cdata).u.encKeyPack), sizeof(((*(_PA_PK_AS_REP  *)_cdata).u.encKeyPack).length), sizeof(((*(_PA_PK_AS_REP  *)_cdata).u.encKeyPack).value[0]), (unsigned int)((char *)&((*(_PA_PK_AS_REP  *)_odata).u.encKeyPack).value - (char *)&((*(_PA_PK_AS_REP  *)_odata).u.encKeyPack))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 38: {
	    if (_oss_cmp_arrbits(((*(_KDCDHKeyInfo  *)_odata).subjectPublicKey).value, ((*(_KDCDHKeyInfo  *)_cdata).subjectPublicKey).value, ((*(_KDCDHKeyInfo  *)_odata).subjectPublicKey).length, ((*(_KDCDHKeyInfo  *)_cdata).subjectPublicKey).length))
		return 1;
	    if ((*(_KDCDHKeyInfo  *)_cdata).nonce != (*(_KDCDHKeyInfo  *)_odata).nonce)
		return 1;
	    if (!(*(_KDCDHKeyInfo  *)_odata).dhKeyExpiration != !(*(_KDCDHKeyInfo  *)_cdata).dhKeyExpiration)
		return 1;
	    if ((*(_KDCDHKeyInfo  *)_odata).dhKeyExpiration) {
		if (OSS_STRCMP(_g, (*(_KDCDHKeyInfo  *)_cdata).dhKeyExpiration, OSS_MAX_STR, (*(_KDCDHKeyInfo  *)_odata).dhKeyExpiration, _g->_res))
#ifdef BAD_OID_IRI
		    if (_oss_cmp_str2time((*(_KDCDHKeyInfo  *)_cdata).dhKeyExpiration, (*(_KDCDHKeyInfo  *)_odata).dhKeyExpiration, 0))
#endif
			return 1;
	    }
	} break;
	case 39: {
	    _res = _cmEncryptionKey(_g, &((*(_ReplyKeyPack  *)_odata).replyKey), &((*(_ReplyKeyPack  *)_cdata).replyKey));
	    if (_res)
		return _res;
	    _res = _cmChecksum(_g, &((*(_ReplyKeyPack  *)_odata).asChecksum), &((*(_ReplyKeyPack  *)_cdata).asChecksum));
	    if (_res)
		return _res;
	} break;
	case 40: {
	    {
		_seqof10 *  _s_oss_tmp_1 = *(_seqof10 * *)_odata;
		_seqof10 *  _d_oss_tmp_1 = *(_seqof10 * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    _res = _cmAlgorithmIdentifier(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
		    if (_res)
			return _res;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 41: {
	    if (!((*(_Attribute  *)_cdata).type).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_Attribute  *)_odata).type), &((*(_Attribute  *)_cdata).type), sizeof(((*(_Attribute  *)_cdata).type).length), sizeof(((*(_Attribute  *)_cdata).type).value[0]), (unsigned int)((char *)&((*(_Attribute  *)_odata).type).value - (char *)&((*(_Attribute  *)_odata).type))))
		return 1;
	    {
		_seqof1 *  _s_2 = (*(_Attribute  *)_odata).values;
		_seqof1 *  _d_2 = (*(_Attribute  *)_cdata).values;
		long        *_a, _i, _i_next, _c = 0L;

		while (_s_2 && _d_2) {
		    ++ _c;
		    _s_2 = _s_2->next;
		    _d_2 = _d_2->next;
		}
		if (_s_2 || _d_2)
		    return 1;
		if (_c) {
		    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		    for (_i = 0; _i < _c; _i ++)
			_a[_i] = _i;
		    _a[_c] = -1L;
		    for (_s_2 = (*(_Attribute  *)_odata).values; _s_2; _s_2 = _s_2->next) {
			_i_next = _a[0]; _res = 1;
			for (_d_2 = (*(_Attribute  *)_cdata).values, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			    if (_i < _i_next)
				continue;
			    if (_oss_cmp_unbnd_octet_ia(&(_s_2->value), &(_d_2->value), sizeof((_d_2->value).length), sizeof((_d_2->value).value[0]), (unsigned int)((char *)&(_s_2->value).value - (char *)&(_s_2->value))))
				continue;
			    _res = 0; _a[_i] = _a[_i+1];
			    break;
			}
			if (_res)
			    break;
		    }
		    _oss_dec_freetempmem(_g, _a);
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 42: {
	    if ((*(_X520name  *)_odata).choice != (*(_X520name  *)_cdata).choice)
		return 1;
	    switch ((*(_X520name  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.teletexString), &((*(_X520name  *)_cdata).u.teletexString), sizeof(((*(_X520name  *)_cdata).u.teletexString).length), sizeof(((*(_X520name  *)_cdata).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.teletexString).value - (char *)&((*(_X520name  *)_odata).u.teletexString))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.printableString), &((*(_X520name  *)_cdata).u.printableString), sizeof(((*(_X520name  *)_cdata).u.printableString).length), sizeof(((*(_X520name  *)_cdata).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.printableString).value - (char *)&((*(_X520name  *)_odata).u.printableString))))
			return 1;
		}   break;
		case 3: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.universalString), &((*(_X520name  *)_cdata).u.universalString), sizeof(((*(_X520name  *)_cdata).u.universalString).length), sizeof(((*(_X520name  *)_cdata).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.universalString).value - (char *)&((*(_X520name  *)_odata).u.universalString))))
			return 1;
		}   break;
		case 4: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.utf8String), &((*(_X520name  *)_cdata).u.utf8String), sizeof(((*(_X520name  *)_cdata).u.utf8String).length), sizeof(((*(_X520name  *)_cdata).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.utf8String).value - (char *)&((*(_X520name  *)_odata).u.utf8String))))
			return 1;
		}   break;
		case 5: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.bmpString), &((*(_X520name  *)_cdata).u.bmpString), sizeof(((*(_X520name  *)_cdata).u.bmpString).length), sizeof(((*(_X520name  *)_cdata).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.bmpString).value - (char *)&((*(_X520name  *)_odata).u.bmpString))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 43: {
	    if ((*(_X520name  *)_odata).choice != (*(_X520name  *)_cdata).choice)
		return 1;
	    switch ((*(_X520name  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.teletexString), &((*(_X520name  *)_cdata).u.teletexString), sizeof(((*(_X520name  *)_cdata).u.teletexString).length), sizeof(((*(_X520name  *)_cdata).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.teletexString).value - (char *)&((*(_X520name  *)_odata).u.teletexString))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.printableString), &((*(_X520name  *)_cdata).u.printableString), sizeof(((*(_X520name  *)_cdata).u.printableString).length), sizeof(((*(_X520name  *)_cdata).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.printableString).value - (char *)&((*(_X520name  *)_odata).u.printableString))))
			return 1;
		}   break;
		case 3: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.universalString), &((*(_X520name  *)_cdata).u.universalString), sizeof(((*(_X520name  *)_cdata).u.universalString).length), sizeof(((*(_X520name  *)_cdata).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.universalString).value - (char *)&((*(_X520name  *)_odata).u.universalString))))
			return 1;
		}   break;
		case 4: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.utf8String), &((*(_X520name  *)_cdata).u.utf8String), sizeof(((*(_X520name  *)_cdata).u.utf8String).length), sizeof(((*(_X520name  *)_cdata).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.utf8String).value - (char *)&((*(_X520name  *)_odata).u.utf8String))))
			return 1;
		}   break;
		case 5: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.bmpString), &((*(_X520name  *)_cdata).u.bmpString), sizeof(((*(_X520name  *)_cdata).u.bmpString).length), sizeof(((*(_X520name  *)_cdata).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.bmpString).value - (char *)&((*(_X520name  *)_odata).u.bmpString))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 44: {
	    if ((*(_X520name  *)_odata).choice != (*(_X520name  *)_cdata).choice)
		return 1;
	    switch ((*(_X520name  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.teletexString), &((*(_X520name  *)_cdata).u.teletexString), sizeof(((*(_X520name  *)_cdata).u.teletexString).length), sizeof(((*(_X520name  *)_cdata).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.teletexString).value - (char *)&((*(_X520name  *)_odata).u.teletexString))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.printableString), &((*(_X520name  *)_cdata).u.printableString), sizeof(((*(_X520name  *)_cdata).u.printableString).length), sizeof(((*(_X520name  *)_cdata).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.printableString).value - (char *)&((*(_X520name  *)_odata).u.printableString))))
			return 1;
		}   break;
		case 3: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.universalString), &((*(_X520name  *)_cdata).u.universalString), sizeof(((*(_X520name  *)_cdata).u.universalString).length), sizeof(((*(_X520name  *)_cdata).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.universalString).value - (char *)&((*(_X520name  *)_odata).u.universalString))))
			return 1;
		}   break;
		case 4: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.utf8String), &((*(_X520name  *)_cdata).u.utf8String), sizeof(((*(_X520name  *)_cdata).u.utf8String).length), sizeof(((*(_X520name  *)_cdata).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.utf8String).value - (char *)&((*(_X520name  *)_odata).u.utf8String))))
			return 1;
		}   break;
		case 5: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.bmpString), &((*(_X520name  *)_cdata).u.bmpString), sizeof(((*(_X520name  *)_cdata).u.bmpString).length), sizeof(((*(_X520name  *)_cdata).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.bmpString).value - (char *)&((*(_X520name  *)_odata).u.bmpString))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 45: {
	    if ((*(_X520name  *)_odata).choice != (*(_X520name  *)_cdata).choice)
		return 1;
	    switch ((*(_X520name  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.teletexString), &((*(_X520name  *)_cdata).u.teletexString), sizeof(((*(_X520name  *)_cdata).u.teletexString).length), sizeof(((*(_X520name  *)_cdata).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.teletexString).value - (char *)&((*(_X520name  *)_odata).u.teletexString))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.printableString), &((*(_X520name  *)_cdata).u.printableString), sizeof(((*(_X520name  *)_cdata).u.printableString).length), sizeof(((*(_X520name  *)_cdata).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.printableString).value - (char *)&((*(_X520name  *)_odata).u.printableString))))
			return 1;
		}   break;
		case 3: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.universalString), &((*(_X520name  *)_cdata).u.universalString), sizeof(((*(_X520name  *)_cdata).u.universalString).length), sizeof(((*(_X520name  *)_cdata).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.universalString).value - (char *)&((*(_X520name  *)_odata).u.universalString))))
			return 1;
		}   break;
		case 4: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.utf8String), &((*(_X520name  *)_cdata).u.utf8String), sizeof(((*(_X520name  *)_cdata).u.utf8String).length), sizeof(((*(_X520name  *)_cdata).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.utf8String).value - (char *)&((*(_X520name  *)_odata).u.utf8String))))
			return 1;
		}   break;
		case 5: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.bmpString), &((*(_X520name  *)_cdata).u.bmpString), sizeof(((*(_X520name  *)_cdata).u.bmpString).length), sizeof(((*(_X520name  *)_cdata).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.bmpString).value - (char *)&((*(_X520name  *)_odata).u.bmpString))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 46: {
	    if ((*(_X520name  *)_odata).choice != (*(_X520name  *)_cdata).choice)
		return 1;
	    switch ((*(_X520name  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.teletexString), &((*(_X520name  *)_cdata).u.teletexString), sizeof(((*(_X520name  *)_cdata).u.teletexString).length), sizeof(((*(_X520name  *)_cdata).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.teletexString).value - (char *)&((*(_X520name  *)_odata).u.teletexString))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.printableString), &((*(_X520name  *)_cdata).u.printableString), sizeof(((*(_X520name  *)_cdata).u.printableString).length), sizeof(((*(_X520name  *)_cdata).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.printableString).value - (char *)&((*(_X520name  *)_odata).u.printableString))))
			return 1;
		}   break;
		case 3: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.universalString), &((*(_X520name  *)_cdata).u.universalString), sizeof(((*(_X520name  *)_cdata).u.universalString).length), sizeof(((*(_X520name  *)_cdata).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.universalString).value - (char *)&((*(_X520name  *)_odata).u.universalString))))
			return 1;
		}   break;
		case 4: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.utf8String), &((*(_X520name  *)_cdata).u.utf8String), sizeof(((*(_X520name  *)_cdata).u.utf8String).length), sizeof(((*(_X520name  *)_cdata).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.utf8String).value - (char *)&((*(_X520name  *)_odata).u.utf8String))))
			return 1;
		}   break;
		case 5: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.bmpString), &((*(_X520name  *)_cdata).u.bmpString), sizeof(((*(_X520name  *)_cdata).u.bmpString).length), sizeof(((*(_X520name  *)_cdata).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.bmpString).value - (char *)&((*(_X520name  *)_odata).u.bmpString))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 47: {
	    if ((*(_X520name  *)_odata).choice != (*(_X520name  *)_cdata).choice)
		return 1;
	    switch ((*(_X520name  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.teletexString), &((*(_X520name  *)_cdata).u.teletexString), sizeof(((*(_X520name  *)_cdata).u.teletexString).length), sizeof(((*(_X520name  *)_cdata).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.teletexString).value - (char *)&((*(_X520name  *)_odata).u.teletexString))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.printableString), &((*(_X520name  *)_cdata).u.printableString), sizeof(((*(_X520name  *)_cdata).u.printableString).length), sizeof(((*(_X520name  *)_cdata).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.printableString).value - (char *)&((*(_X520name  *)_odata).u.printableString))))
			return 1;
		}   break;
		case 3: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.universalString), &((*(_X520name  *)_cdata).u.universalString), sizeof(((*(_X520name  *)_cdata).u.universalString).length), sizeof(((*(_X520name  *)_cdata).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.universalString).value - (char *)&((*(_X520name  *)_odata).u.universalString))))
			return 1;
		}   break;
		case 4: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.utf8String), &((*(_X520name  *)_cdata).u.utf8String), sizeof(((*(_X520name  *)_cdata).u.utf8String).length), sizeof(((*(_X520name  *)_cdata).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.utf8String).value - (char *)&((*(_X520name  *)_odata).u.utf8String))))
			return 1;
		}   break;
		case 5: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.bmpString), &((*(_X520name  *)_cdata).u.bmpString), sizeof(((*(_X520name  *)_cdata).u.bmpString).length), sizeof(((*(_X520name  *)_cdata).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.bmpString).value - (char *)&((*(_X520name  *)_odata).u.bmpString))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 48: {
	    if ((*(_X520name  *)_odata).choice != (*(_X520name  *)_cdata).choice)
		return 1;
	    switch ((*(_X520name  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.teletexString), &((*(_X520name  *)_cdata).u.teletexString), sizeof(((*(_X520name  *)_cdata).u.teletexString).length), sizeof(((*(_X520name  *)_cdata).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.teletexString).value - (char *)&((*(_X520name  *)_odata).u.teletexString))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.printableString), &((*(_X520name  *)_cdata).u.printableString), sizeof(((*(_X520name  *)_cdata).u.printableString).length), sizeof(((*(_X520name  *)_cdata).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.printableString).value - (char *)&((*(_X520name  *)_odata).u.printableString))))
			return 1;
		}   break;
		case 3: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.universalString), &((*(_X520name  *)_cdata).u.universalString), sizeof(((*(_X520name  *)_cdata).u.universalString).length), sizeof(((*(_X520name  *)_cdata).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.universalString).value - (char *)&((*(_X520name  *)_odata).u.universalString))))
			return 1;
		}   break;
		case 4: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.utf8String), &((*(_X520name  *)_cdata).u.utf8String), sizeof(((*(_X520name  *)_cdata).u.utf8String).length), sizeof(((*(_X520name  *)_cdata).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.utf8String).value - (char *)&((*(_X520name  *)_odata).u.utf8String))))
			return 1;
		}   break;
		case 5: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.bmpString), &((*(_X520name  *)_cdata).u.bmpString), sizeof(((*(_X520name  *)_cdata).u.bmpString).length), sizeof(((*(_X520name  *)_cdata).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.bmpString).value - (char *)&((*(_X520name  *)_odata).u.bmpString))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 49: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 50: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 51: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 52: {
	    if ((*(_X520name  *)_odata).choice != (*(_X520name  *)_cdata).choice)
		return 1;
	    switch ((*(_X520name  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.teletexString), &((*(_X520name  *)_cdata).u.teletexString), sizeof(((*(_X520name  *)_cdata).u.teletexString).length), sizeof(((*(_X520name  *)_cdata).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.teletexString).value - (char *)&((*(_X520name  *)_odata).u.teletexString))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.printableString), &((*(_X520name  *)_cdata).u.printableString), sizeof(((*(_X520name  *)_cdata).u.printableString).length), sizeof(((*(_X520name  *)_cdata).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.printableString).value - (char *)&((*(_X520name  *)_odata).u.printableString))))
			return 1;
		}   break;
		case 3: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.universalString), &((*(_X520name  *)_cdata).u.universalString), sizeof(((*(_X520name  *)_cdata).u.universalString).length), sizeof(((*(_X520name  *)_cdata).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.universalString).value - (char *)&((*(_X520name  *)_odata).u.universalString))))
			return 1;
		}   break;
		case 4: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.utf8String), &((*(_X520name  *)_cdata).u.utf8String), sizeof(((*(_X520name  *)_cdata).u.utf8String).length), sizeof(((*(_X520name  *)_cdata).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.utf8String).value - (char *)&((*(_X520name  *)_odata).u.utf8String))))
			return 1;
		}   break;
		case 5: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.bmpString), &((*(_X520name  *)_cdata).u.bmpString), sizeof(((*(_X520name  *)_cdata).u.bmpString).length), sizeof(((*(_X520name  *)_cdata).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.bmpString).value - (char *)&((*(_X520name  *)_odata).u.bmpString))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 53: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 54: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 55: {
	    _res = _cmRDNSequence(_g, (_RDNSequence * *)_odata, (_RDNSequence * *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 56: {
	    if ((*(_X520name  *)_odata).choice != (*(_X520name  *)_cdata).choice)
		return 1;
	    switch ((*(_X520name  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.teletexString), &((*(_X520name  *)_cdata).u.teletexString), sizeof(((*(_X520name  *)_cdata).u.teletexString).length), sizeof(((*(_X520name  *)_cdata).u.teletexString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.teletexString).value - (char *)&((*(_X520name  *)_odata).u.teletexString))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.printableString), &((*(_X520name  *)_cdata).u.printableString), sizeof(((*(_X520name  *)_cdata).u.printableString).length), sizeof(((*(_X520name  *)_cdata).u.printableString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.printableString).value - (char *)&((*(_X520name  *)_odata).u.printableString))))
			return 1;
		}   break;
		case 3: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.universalString), &((*(_X520name  *)_cdata).u.universalString), sizeof(((*(_X520name  *)_cdata).u.universalString).length), sizeof(((*(_X520name  *)_cdata).u.universalString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.universalString).value - (char *)&((*(_X520name  *)_odata).u.universalString))))
			return 1;
		}   break;
		case 4: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.utf8String), &((*(_X520name  *)_cdata).u.utf8String), sizeof(((*(_X520name  *)_cdata).u.utf8String).length), sizeof(((*(_X520name  *)_cdata).u.utf8String).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.utf8String).value - (char *)&((*(_X520name  *)_odata).u.utf8String))))
			return 1;
		}   break;
		case 5: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_X520name  *)_odata).u.bmpString), &((*(_X520name  *)_cdata).u.bmpString), sizeof(((*(_X520name  *)_cdata).u.bmpString).length), sizeof(((*(_X520name  *)_cdata).u.bmpString).value[0]), (unsigned int)((char *)&((*(_X520name  *)_odata).u.bmpString).value - (char *)&((*(_X520name  *)_odata).u.bmpString))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 57: {
	    if ((((*(_Certificate  *)_odata).tbsCertificate).bit_mask & ((*(_Certificate  *)_cdata).tbsCertificate).bit_mask) & 0x80000000) {
		if (((*(_Certificate  *)_cdata).tbsCertificate).version != ((*(_Certificate  *)_odata).tbsCertificate).version)
		    return 1;
	    } else {
		if (((*(_Certificate  *)_odata).tbsCertificate).bit_mask & 0x80000000) {
		    if (TBSCertificate::default_version != ((*(_Certificate  *)_odata).tbsCertificate).version)
			return 1;
		}
		if (((*(_Certificate  *)_cdata).tbsCertificate).bit_mask & 0x80000000) {
		    if (((*(_Certificate  *)_cdata).tbsCertificate).version != TBSCertificate::default_version)
			return 1;
		}
	    }
	    if (((*(_Certificate  *)_cdata).tbsCertificate).serialNumber != ((*(_Certificate  *)_odata).tbsCertificate).serialNumber)
		return 1;
	    _res = _cmAlgorithmIdentifier(_g, &(((*(_Certificate  *)_odata).tbsCertificate).signature), &(((*(_Certificate  *)_cdata).tbsCertificate).signature));
	    if (_res)
		return _res;
	    _res = _cmName(_g, &(((*(_Certificate  *)_odata).tbsCertificate).issuer), &(((*(_Certificate  *)_cdata).tbsCertificate).issuer));
	    if (_res)
		return _res;
	    _res = _cmTime(_g, &((((*(_Certificate  *)_odata).tbsCertificate).validity).notBefore), &((((*(_Certificate  *)_cdata).tbsCertificate).validity).notBefore));
	    if (_res)
		return _res;
	    _res = _cmTime(_g, &((((*(_Certificate  *)_odata).tbsCertificate).validity).notAfter), &((((*(_Certificate  *)_cdata).tbsCertificate).validity).notAfter));
	    if (_res)
		return _res;
	    _res = _cmName(_g, &(((*(_Certificate  *)_odata).tbsCertificate).subject), &(((*(_Certificate  *)_cdata).tbsCertificate).subject));
	    if (_res)
		return _res;
	    _res = _cmSubjectPublicKeyInfo(_g, &(((*(_Certificate  *)_odata).tbsCertificate).subjectPublicKeyInfo), &(((*(_Certificate  *)_cdata).tbsCertificate).subjectPublicKeyInfo));
	    if (_res)
		return _res;
	    if ((((*(_Certificate  *)_odata).tbsCertificate).bit_mask ^ ((*(_Certificate  *)_cdata).tbsCertificate).bit_mask) & 0x40000000)
		return 1;
	    if (((*(_Certificate  *)_odata).tbsCertificate).bit_mask & 0x40000000) {
		if (_oss_cmp_arrbits((((*(_Certificate  *)_odata).tbsCertificate).issuerUniqueID).value, (((*(_Certificate  *)_cdata).tbsCertificate).issuerUniqueID).value, (((*(_Certificate  *)_odata).tbsCertificate).issuerUniqueID).length, (((*(_Certificate  *)_cdata).tbsCertificate).issuerUniqueID).length))
		    return 1;
	    }
	    if ((((*(_Certificate  *)_odata).tbsCertificate).bit_mask ^ ((*(_Certificate  *)_cdata).tbsCertificate).bit_mask) & 0x20000000)
		return 1;
	    if (((*(_Certificate  *)_odata).tbsCertificate).bit_mask & 0x20000000) {
		if (_oss_cmp_arrbits((((*(_Certificate  *)_odata).tbsCertificate).subjectUniqueID).value, (((*(_Certificate  *)_cdata).tbsCertificate).subjectUniqueID).value, (((*(_Certificate  *)_odata).tbsCertificate).subjectUniqueID).length, (((*(_Certificate  *)_cdata).tbsCertificate).subjectUniqueID).length))
		    return 1;
	    }
	    if ((((*(_Certificate  *)_odata).tbsCertificate).bit_mask ^ ((*(_Certificate  *)_cdata).tbsCertificate).bit_mask) & 0x10000000)
		return 1;
	    if (((*(_Certificate  *)_odata).tbsCertificate).bit_mask & 0x10000000) {
		_res = _cmExtensions(_g, &(((*(_Certificate  *)_odata).tbsCertificate).extensions), &(((*(_Certificate  *)_cdata).tbsCertificate).extensions));
		if (_res)
		    return _res;
	    }
	    _res = _cmAlgorithmIdentifier(_g, &((*(_Certificate  *)_odata).signatureAlgorithm), &((*(_Certificate  *)_cdata).signatureAlgorithm));
	    if (_res)
		return _res;
	    if (_oss_cmp_arrbits(((*(_Certificate  *)_odata).signature).value, ((*(_Certificate  *)_cdata).signature).value, ((*(_Certificate  *)_odata).signature).length, ((*(_Certificate  *)_cdata).signature).length))
		return 1;
	} break;
	case 58: {
	    if ((((*(_CertificateList  *)_odata).tbsCertList).bit_mask ^ ((*(_CertificateList  *)_cdata).tbsCertList).bit_mask) & 0x80000000)
		return 1;
	    if (((*(_CertificateList  *)_odata).tbsCertList).bit_mask & 0x80000000) {
		if (((*(_CertificateList  *)_cdata).tbsCertList).version != ((*(_CertificateList  *)_odata).tbsCertList).version)
		    return 1;
	    }
	    _res = _cmAlgorithmIdentifier(_g, &(((*(_CertificateList  *)_odata).tbsCertList).signature), &(((*(_CertificateList  *)_cdata).tbsCertList).signature));
	    if (_res)
		return _res;
	    _res = _cmName(_g, &(((*(_CertificateList  *)_odata).tbsCertList).issuer), &(((*(_CertificateList  *)_cdata).tbsCertList).issuer));
	    if (_res)
		return _res;
	    _res = _cmTime(_g, &(((*(_CertificateList  *)_odata).tbsCertList).thisUpdate), &(((*(_CertificateList  *)_cdata).tbsCertList).thisUpdate));
	    if (_res)
		return _res;
	    if ((((*(_CertificateList  *)_odata).tbsCertList).bit_mask ^ ((*(_CertificateList  *)_cdata).tbsCertList).bit_mask) & 0x40000000)
		return 1;
	    if (((*(_CertificateList  *)_odata).tbsCertList).bit_mask & 0x40000000) {
		_res = _cmTime(_g, &(((*(_CertificateList  *)_odata).tbsCertList).nextUpdate), &(((*(_CertificateList  *)_cdata).tbsCertList).nextUpdate));
		if (_res)
		    return _res;
	    }
	    if ((((*(_CertificateList  *)_odata).tbsCertList).bit_mask ^ ((*(_CertificateList  *)_cdata).tbsCertList).bit_mask) & 0x20000000)
		return 1;
	    if (((*(_CertificateList  *)_odata).tbsCertList).bit_mask & 0x20000000) {
		{
		    _seqof11 *  _s_oss_tmp_3 = ((*(_CertificateList  *)_odata).tbsCertList).revokedCertificates;
		    _seqof11 *  _d_oss_tmp_3 = ((*(_CertificateList  *)_cdata).tbsCertList).revokedCertificates;

		    while (_s_oss_tmp_3 && _d_oss_tmp_3) {
			{
			    _seq4  * _odata_3 = &(_s_oss_tmp_3->value);
			    _seq4  * _cdata_3 = &(_d_oss_tmp_3->value);

			    if ((*_cdata_3).userCertificate != (*_odata_3).userCertificate)
				return 1;
			    _res = _cmTime(_g, &((*_odata_3).revocationDate), &((*_cdata_3).revocationDate));
			    if (_res)
				return _res;
			    if (((*_odata_3).bit_mask ^ (*_cdata_3).bit_mask) & 0x80000000)
				return 1;
			    if ((*_odata_3).bit_mask & 0x80000000) {
				_res = _cmExtensions(_g, &((*_odata_3).crlEntryExtensions), &((*_cdata_3).crlEntryExtensions));
				if (_res)
				    return _res;
			    }
			}
			_s_oss_tmp_3 = _s_oss_tmp_3->next;
			_d_oss_tmp_3 = _d_oss_tmp_3->next;
		    }
		    if (_s_oss_tmp_3 || _d_oss_tmp_3)
			return 1;
		}
	    }
	    if ((((*(_CertificateList  *)_odata).tbsCertList).bit_mask ^ ((*(_CertificateList  *)_cdata).tbsCertList).bit_mask) & 0x10000000)
		return 1;
	    if (((*(_CertificateList  *)_odata).tbsCertList).bit_mask & 0x10000000) {
		_res = _cmExtensions(_g, &(((*(_CertificateList  *)_odata).tbsCertList).crlExtensions), &(((*(_CertificateList  *)_cdata).tbsCertList).crlExtensions));
		if (_res)
		    return _res;
	    }
	    _res = _cmAlgorithmIdentifier(_g, &((*(_CertificateList  *)_odata).signatureAlgorithm), &((*(_CertificateList  *)_cdata).signatureAlgorithm));
	    if (_res)
		return _res;
	    if (_oss_cmp_arrbits(((*(_CertificateList  *)_odata).signature).value, ((*(_CertificateList  *)_cdata).signature).value, ((*(_CertificateList  *)_odata).signature).length, ((*(_CertificateList  *)_cdata).signature).length))
		return 1;
	} break;
	case 59: {
	    if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask ^ ((*(_ORAddress  *)_cdata).built_in_standard_attributes).bit_mask) & 0x80000000)
		return 1;
	    if (((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask & 0x80000000) {
		if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).country_name).choice != (((*(_ORAddress  *)_cdata).built_in_standard_attributes).country_name).choice)
		    return 1;
		switch ((((*(_ORAddress  *)_odata).built_in_standard_attributes).country_name).choice) {
		    case 1: {
			if (_oss_cmp_unbnd_octet_ia(&((((*(_ORAddress  *)_odata).built_in_standard_attributes).country_name).u.x121_dcc_code), &((((*(_ORAddress  *)_cdata).built_in_standard_attributes).country_name).u.x121_dcc_code), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).country_name).u.x121_dcc_code).length), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).country_name).u.x121_dcc_code).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).country_name).u.x121_dcc_code).value - (char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).country_name).u.x121_dcc_code))))
			    return 1;
		    }   break;
		    case 2: {
			if (_oss_cmp_unbnd_octet_ia(&((((*(_ORAddress  *)_odata).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code), &((((*(_ORAddress  *)_cdata).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code).length), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code).value - (char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).country_name).u.iso_3166_alpha2_code))))
			    return 1;
		    }   break;
		    case 0:
			break;
		    default:
			return 1;
		}
	    }
	    if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask ^ ((*(_ORAddress  *)_cdata).built_in_standard_attributes).bit_mask) & 0x40000000)
		return 1;
	    if (((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask & 0x40000000) {
		if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).administration_domain_name).choice != (((*(_ORAddress  *)_cdata).built_in_standard_attributes).administration_domain_name).choice)
		    return 1;
		switch ((((*(_ORAddress  *)_odata).built_in_standard_attributes).administration_domain_name).choice) {
		    case 1: {
			if (_oss_cmp_unbnd_octet_ia(&((((*(_ORAddress  *)_odata).built_in_standard_attributes).administration_domain_name).u.numeric), &((((*(_ORAddress  *)_cdata).built_in_standard_attributes).administration_domain_name).u.numeric), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).administration_domain_name).u.numeric).length), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).administration_domain_name).u.numeric).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).administration_domain_name).u.numeric).value - (char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).administration_domain_name).u.numeric))))
			    return 1;
		    }   break;
		    case 2: {
			if (_oss_cmp_unbnd_octet_ia(&((((*(_ORAddress  *)_odata).built_in_standard_attributes).administration_domain_name).u.printable), &((((*(_ORAddress  *)_cdata).built_in_standard_attributes).administration_domain_name).u.printable), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).administration_domain_name).u.printable).length), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).administration_domain_name).u.printable).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).administration_domain_name).u.printable).value - (char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).administration_domain_name).u.printable))))
			    return 1;
		    }   break;
		    case 0:
			break;
		    default:
			return 1;
		}
	    }
	    if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask ^ ((*(_ORAddress  *)_cdata).built_in_standard_attributes).bit_mask) & 0x20000000)
		return 1;
	    if (((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask & 0x20000000) {
		if (_oss_cmp_unbnd_octet_ia(&(((*(_ORAddress  *)_odata).built_in_standard_attributes).network_address), &(((*(_ORAddress  *)_cdata).built_in_standard_attributes).network_address), sizeof((((*(_ORAddress  *)_cdata).built_in_standard_attributes).network_address).length), sizeof((((*(_ORAddress  *)_cdata).built_in_standard_attributes).network_address).value[0]), (unsigned int)((char *)&(((*(_ORAddress  *)_odata).built_in_standard_attributes).network_address).value - (char *)&(((*(_ORAddress  *)_odata).built_in_standard_attributes).network_address))))
		    return 1;
	    }
	    if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask ^ ((*(_ORAddress  *)_cdata).built_in_standard_attributes).bit_mask) & 0x10000000)
		return 1;
	    if (((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask & 0x10000000) {
		if (_oss_cmp_unbnd_octet_ia(&(((*(_ORAddress  *)_odata).built_in_standard_attributes).terminal_identifier), &(((*(_ORAddress  *)_cdata).built_in_standard_attributes).terminal_identifier), sizeof((((*(_ORAddress  *)_cdata).built_in_standard_attributes).terminal_identifier).length), sizeof((((*(_ORAddress  *)_cdata).built_in_standard_attributes).terminal_identifier).value[0]), (unsigned int)((char *)&(((*(_ORAddress  *)_odata).built_in_standard_attributes).terminal_identifier).value - (char *)&(((*(_ORAddress  *)_odata).built_in_standard_attributes).terminal_identifier))))
		    return 1;
	    }
	    if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask ^ ((*(_ORAddress  *)_cdata).built_in_standard_attributes).bit_mask) & 0x8000000)
		return 1;
	    if (((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask & 0x8000000) {
		if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).private_domain_name).choice != (((*(_ORAddress  *)_cdata).built_in_standard_attributes).private_domain_name).choice)
		    return 1;
		switch ((((*(_ORAddress  *)_odata).built_in_standard_attributes).private_domain_name).choice) {
		    case 1: {
			if (_oss_cmp_unbnd_octet_ia(&((((*(_ORAddress  *)_odata).built_in_standard_attributes).private_domain_name).u.numeric), &((((*(_ORAddress  *)_cdata).built_in_standard_attributes).private_domain_name).u.numeric), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).private_domain_name).u.numeric).length), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).private_domain_name).u.numeric).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).private_domain_name).u.numeric).value - (char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).private_domain_name).u.numeric))))
			    return 1;
		    }   break;
		    case 2: {
			if (_oss_cmp_unbnd_octet_ia(&((((*(_ORAddress  *)_odata).built_in_standard_attributes).private_domain_name).u.printable), &((((*(_ORAddress  *)_cdata).built_in_standard_attributes).private_domain_name).u.printable), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).private_domain_name).u.printable).length), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).private_domain_name).u.printable).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).private_domain_name).u.printable).value - (char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).private_domain_name).u.printable))))
			    return 1;
		    }   break;
		    case 0:
			break;
		    default:
			return 1;
		}
	    }
	    if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask ^ ((*(_ORAddress  *)_cdata).built_in_standard_attributes).bit_mask) & 0x4000000)
		return 1;
	    if (((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask & 0x4000000) {
		if (_oss_cmp_unbnd_octet_ia(&(((*(_ORAddress  *)_odata).built_in_standard_attributes).organization_name), &(((*(_ORAddress  *)_cdata).built_in_standard_attributes).organization_name), sizeof((((*(_ORAddress  *)_cdata).built_in_standard_attributes).organization_name).length), sizeof((((*(_ORAddress  *)_cdata).built_in_standard_attributes).organization_name).value[0]), (unsigned int)((char *)&(((*(_ORAddress  *)_odata).built_in_standard_attributes).organization_name).value - (char *)&(((*(_ORAddress  *)_odata).built_in_standard_attributes).organization_name))))
		    return 1;
	    }
	    if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask ^ ((*(_ORAddress  *)_cdata).built_in_standard_attributes).bit_mask) & 0x2000000)
		return 1;
	    if (((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask & 0x2000000) {
		if (_oss_cmp_unbnd_octet_ia(&(((*(_ORAddress  *)_odata).built_in_standard_attributes).numeric_user_identifier), &(((*(_ORAddress  *)_cdata).built_in_standard_attributes).numeric_user_identifier), sizeof((((*(_ORAddress  *)_cdata).built_in_standard_attributes).numeric_user_identifier).length), sizeof((((*(_ORAddress  *)_cdata).built_in_standard_attributes).numeric_user_identifier).value[0]), (unsigned int)((char *)&(((*(_ORAddress  *)_odata).built_in_standard_attributes).numeric_user_identifier).value - (char *)&(((*(_ORAddress  *)_odata).built_in_standard_attributes).numeric_user_identifier))))
		    return 1;
	    }
	    if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask ^ ((*(_ORAddress  *)_cdata).built_in_standard_attributes).bit_mask) & 0x1000000)
		return 1;
	    if (((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask & 0x1000000) {
		if (_oss_cmp_unbnd_octet_ia(&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).surname), &((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).surname), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).surname).length), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).surname).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).surname).value - (char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).surname))))
		    return 1;
		if (((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).bit_mask ^ (((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).bit_mask) & 0x80000000)
		    return 1;
		if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).bit_mask & 0x80000000) {
		    if (_oss_cmp_unbnd_octet_ia(&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).given_name), &((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).given_name), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).given_name).length), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).given_name).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).given_name).value - (char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).given_name))))
			return 1;
		}
		if (((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).bit_mask ^ (((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).bit_mask) & 0x40000000)
		    return 1;
		if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).bit_mask & 0x40000000) {
		    if (_oss_cmp_unbnd_octet_ia(&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).initials), &((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).initials), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).initials).length), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).initials).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).initials).value - (char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).initials))))
			return 1;
		}
		if (((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).bit_mask ^ (((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).bit_mask) & 0x20000000)
		    return 1;
		if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).bit_mask & 0x20000000) {
		    if (_oss_cmp_unbnd_octet_ia(&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).generation_qualifier), &((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).generation_qualifier), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).generation_qualifier).length), sizeof(((((*(_ORAddress  *)_cdata).built_in_standard_attributes).personal_name).generation_qualifier).value[0]), (unsigned int)((char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).generation_qualifier).value - (char *)&((((*(_ORAddress  *)_odata).built_in_standard_attributes).personal_name).generation_qualifier))))
			return 1;
		}
	    }
	    if ((((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask ^ ((*(_ORAddress  *)_cdata).built_in_standard_attributes).bit_mask) & 0x800000)
		return 1;
	    if (((*(_ORAddress  *)_odata).built_in_standard_attributes).bit_mask & 0x800000) {
		{
		    _seqof1 *  _s_oss_tmp_3 = (_seqof1 *)((*(_ORAddress  *)_odata).built_in_standard_attributes).organizational_unit_names;
		    _seqof1 *  _d_oss_tmp_3 = (_seqof1 *)((*(_ORAddress  *)_cdata).built_in_standard_attributes).organizational_unit_names;

		    while (_s_oss_tmp_3 && _d_oss_tmp_3) {
			if (_oss_cmp_unbnd_octet_ia(&(_s_oss_tmp_3->value), &(_d_oss_tmp_3->value), sizeof((_d_oss_tmp_3->value).length), sizeof((_d_oss_tmp_3->value).value[0]), (unsigned int)((char *)&(_s_oss_tmp_3->value).value - (char *)&(_s_oss_tmp_3->value))))
			    return 1;
			_s_oss_tmp_3 = _s_oss_tmp_3->next;
			_d_oss_tmp_3 = _d_oss_tmp_3->next;
		    }
		    if (_s_oss_tmp_3 || _d_oss_tmp_3)
			return 1;
		}
	    }
	    if (((*(_ORAddress  *)_odata).bit_mask ^ (*(_ORAddress  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_ORAddress  *)_odata).bit_mask & 0x80000000) {
		{
		    _BuiltInDomainDefinedAttributes *  _s_oss_tmp_2 = (*(_ORAddress  *)_odata).built_in_domain_defined_attributes;
		    _BuiltInDomainDefinedAttributes *  _d_oss_tmp_2 = (*(_ORAddress  *)_cdata).built_in_domain_defined_attributes;

		    while (_s_oss_tmp_2 && _d_oss_tmp_2) {
			if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_2->value).type), &((_d_oss_tmp_2->value).type), sizeof(((_d_oss_tmp_2->value).type).length), sizeof(((_d_oss_tmp_2->value).type).value[0]), (unsigned int)((char *)&((_s_oss_tmp_2->value).type).value - (char *)&((_s_oss_tmp_2->value).type))))
			    return 1;
			if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_2->value).value), &((_d_oss_tmp_2->value).value), sizeof(((_d_oss_tmp_2->value).value).length), sizeof(((_d_oss_tmp_2->value).value).value[0]), (unsigned int)((char *)&((_s_oss_tmp_2->value).value).value - (char *)&((_s_oss_tmp_2->value).value))))
			    return 1;
			_s_oss_tmp_2 = _s_oss_tmp_2->next;
			_d_oss_tmp_2 = _d_oss_tmp_2->next;
		    }
		    if (_s_oss_tmp_2 || _d_oss_tmp_2)
			return 1;
		}
	    }
	    if (((*(_ORAddress  *)_odata).bit_mask ^ (*(_ORAddress  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_ORAddress  *)_odata).bit_mask & 0x40000000) {
		{
		    _ExtensionAttributes *  _s_2 = (*(_ORAddress  *)_odata).extension_attributes;
		    _ExtensionAttributes *  _d_2 = (*(_ORAddress  *)_cdata).extension_attributes;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_ORAddress  *)_odata).extension_attributes; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_ORAddress  *)_cdata).extension_attributes, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				if ((_d_2->value).extension_attribute_type != (_s_2->value).extension_attribute_type)
				    continue;
				if (_oss_cmp_unbnd_octet_ia(&((_s_2->value).extension_attribute_value), &((_d_2->value).extension_attribute_value), sizeof(((_d_2->value).extension_attribute_value).length), sizeof(((_d_2->value).extension_attribute_value).value[0]), (unsigned int)((char *)&((_s_2->value).extension_attribute_value).value - (char *)&((_s_2->value).extension_attribute_value))))
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	} break;
	case 60: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 61: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 62: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 63: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_PersonalName  *)_odata).surname), &((*(_PersonalName  *)_cdata).surname), sizeof(((*(_PersonalName  *)_cdata).surname).length), sizeof(((*(_PersonalName  *)_cdata).surname).value[0]), (unsigned int)((char *)&((*(_PersonalName  *)_odata).surname).value - (char *)&((*(_PersonalName  *)_odata).surname))))
		return 1;
	    if (((*(_PersonalName  *)_odata).bit_mask ^ (*(_PersonalName  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_PersonalName  *)_odata).bit_mask & 0x80000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_PersonalName  *)_odata).given_name), &((*(_PersonalName  *)_cdata).given_name), sizeof(((*(_PersonalName  *)_cdata).given_name).length), sizeof(((*(_PersonalName  *)_cdata).given_name).value[0]), (unsigned int)((char *)&((*(_PersonalName  *)_odata).given_name).value - (char *)&((*(_PersonalName  *)_odata).given_name))))
		    return 1;
	    }
	    if (((*(_PersonalName  *)_odata).bit_mask ^ (*(_PersonalName  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_PersonalName  *)_odata).bit_mask & 0x40000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_PersonalName  *)_odata).initials), &((*(_PersonalName  *)_cdata).initials), sizeof(((*(_PersonalName  *)_cdata).initials).length), sizeof(((*(_PersonalName  *)_cdata).initials).value[0]), (unsigned int)((char *)&((*(_PersonalName  *)_odata).initials).value - (char *)&((*(_PersonalName  *)_odata).initials))))
		    return 1;
	    }
	    if (((*(_PersonalName  *)_odata).bit_mask ^ (*(_PersonalName  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_PersonalName  *)_odata).bit_mask & 0x20000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_PersonalName  *)_odata).generation_qualifier), &((*(_PersonalName  *)_cdata).generation_qualifier), sizeof(((*(_PersonalName  *)_cdata).generation_qualifier).length), sizeof(((*(_PersonalName  *)_cdata).generation_qualifier).value[0]), (unsigned int)((char *)&((*(_PersonalName  *)_odata).generation_qualifier).value - (char *)&((*(_PersonalName  *)_odata).generation_qualifier))))
		    return 1;
	    }
	} break;
	case 64: {
	    {
		_seqof1 *  _s_oss_tmp_1 = *(_seqof1 * *)_odata;
		_seqof1 *  _d_oss_tmp_1 = *(_seqof1 * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    if (_oss_cmp_unbnd_octet_ia(&(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value), sizeof((_d_oss_tmp_1->value).length), sizeof((_d_oss_tmp_1->value).value[0]), (unsigned int)((char *)&(_s_oss_tmp_1->value).value - (char *)&(_s_oss_tmp_1->value))))
			return 1;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 65: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 66: {
	    if ((*(_CountryName  *)_odata).choice != (*(_CountryName  *)_cdata).choice)
		return 1;
	    switch ((*(_CountryName  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_CountryName  *)_odata).u.x121_dcc_code), &((*(_CountryName  *)_cdata).u.x121_dcc_code), sizeof(((*(_CountryName  *)_cdata).u.x121_dcc_code).length), sizeof(((*(_CountryName  *)_cdata).u.x121_dcc_code).value[0]), (unsigned int)((char *)&((*(_CountryName  *)_odata).u.x121_dcc_code).value - (char *)&((*(_CountryName  *)_odata).u.x121_dcc_code))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_CountryName  *)_odata).u.iso_3166_alpha2_code), &((*(_CountryName  *)_cdata).u.iso_3166_alpha2_code), sizeof(((*(_CountryName  *)_cdata).u.iso_3166_alpha2_code).length), sizeof(((*(_CountryName  *)_cdata).u.iso_3166_alpha2_code).value[0]), (unsigned int)((char *)&((*(_CountryName  *)_odata).u.iso_3166_alpha2_code).value - (char *)&((*(_CountryName  *)_odata).u.iso_3166_alpha2_code))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 67: {
	    if ((*(_PostalCode  *)_odata).choice != (*(_PostalCode  *)_cdata).choice)
		return 1;
	    switch ((*(_PostalCode  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_PostalCode  *)_odata).u.numeric_code), &((*(_PostalCode  *)_cdata).u.numeric_code), sizeof(((*(_PostalCode  *)_cdata).u.numeric_code).length), sizeof(((*(_PostalCode  *)_cdata).u.numeric_code).value[0]), (unsigned int)((char *)&((*(_PostalCode  *)_odata).u.numeric_code).value - (char *)&((*(_PostalCode  *)_odata).u.numeric_code))))
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_PostalCode  *)_odata).u.printable_code), &((*(_PostalCode  *)_cdata).u.printable_code), sizeof(((*(_PostalCode  *)_cdata).u.printable_code).length), sizeof(((*(_PostalCode  *)_cdata).u.printable_code).value[0]), (unsigned int)((char *)&((*(_PostalCode  *)_odata).u.printable_code).value - (char *)&((*(_PostalCode  *)_odata).u.printable_code))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 68: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 69: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 70: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 71: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 72: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 73: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 74: {
	    if (((*(_UnformattedPostalAddress  *)_odata).bit_mask ^ (*(_UnformattedPostalAddress  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_UnformattedPostalAddress  *)_odata).bit_mask & 0x80000000) {
		{
		    _seqof1 *  _s_oss_tmp_2 = (*(_UnformattedPostalAddress  *)_odata).printable_address;
		    _seqof1 *  _d_oss_tmp_2 = (*(_UnformattedPostalAddress  *)_cdata).printable_address;

		    while (_s_oss_tmp_2 && _d_oss_tmp_2) {
			if (_oss_cmp_unbnd_octet_ia(&(_s_oss_tmp_2->value), &(_d_oss_tmp_2->value), sizeof((_d_oss_tmp_2->value).length), sizeof((_d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(_s_oss_tmp_2->value).value - (char *)&(_s_oss_tmp_2->value))))
			    return 1;
			_s_oss_tmp_2 = _s_oss_tmp_2->next;
			_d_oss_tmp_2 = _d_oss_tmp_2->next;
		    }
		    if (_s_oss_tmp_2 || _d_oss_tmp_2)
			return 1;
		}
	    }
	    if (((*(_UnformattedPostalAddress  *)_odata).bit_mask ^ (*(_UnformattedPostalAddress  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_UnformattedPostalAddress  *)_odata).bit_mask & 0x40000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_UnformattedPostalAddress  *)_odata).teletex_string), &((*(_UnformattedPostalAddress  *)_cdata).teletex_string), sizeof(((*(_UnformattedPostalAddress  *)_cdata).teletex_string).length), sizeof(((*(_UnformattedPostalAddress  *)_cdata).teletex_string).value[0]), (unsigned int)((char *)&((*(_UnformattedPostalAddress  *)_odata).teletex_string).value - (char *)&((*(_UnformattedPostalAddress  *)_odata).teletex_string))))
		    return 1;
	    }
	} break;
	case 75: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 76: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 77: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 78: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 79: {
	    _res = _cmPDSParameter(_g, (_PDSParameter  *)_odata, (_PDSParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 80: {
	    if ((*(_ExtendedNetworkAddress  *)_odata).choice != (*(_ExtendedNetworkAddress  *)_cdata).choice)
		return 1;
	    switch ((*(_ExtendedNetworkAddress  *)_odata).choice) {
		case 1: {
		    if (_oss_cmp_unbnd_octet_ia(&(((*(_ExtendedNetworkAddress  *)_odata).u.e163_4_address)->number), &(((*(_ExtendedNetworkAddress  *)_cdata).u.e163_4_address)->number), sizeof((((*(_ExtendedNetworkAddress  *)_cdata).u.e163_4_address)->number).length), sizeof((((*(_ExtendedNetworkAddress  *)_cdata).u.e163_4_address)->number).value[0]), (unsigned int)((char *)&(((*(_ExtendedNetworkAddress  *)_odata).u.e163_4_address)->number).value - (char *)&(((*(_ExtendedNetworkAddress  *)_odata).u.e163_4_address)->number))))
			return 1;
		    if ((((*(_ExtendedNetworkAddress  *)_odata).u.e163_4_address)->bit_mask ^ ((*(_ExtendedNetworkAddress  *)_cdata).u.e163_4_address)->bit_mask) & 0x80000000)
			return 1;
		    if (((*(_ExtendedNetworkAddress  *)_odata).u.e163_4_address)->bit_mask & 0x80000000) {
			if (_oss_cmp_unbnd_octet_ia(&(((*(_ExtendedNetworkAddress  *)_odata).u.e163_4_address)->sub_address), &(((*(_ExtendedNetworkAddress  *)_cdata).u.e163_4_address)->sub_address), sizeof((((*(_ExtendedNetworkAddress  *)_cdata).u.e163_4_address)->sub_address).length), sizeof((((*(_ExtendedNetworkAddress  *)_cdata).u.e163_4_address)->sub_address).value[0]), (unsigned int)((char *)&(((*(_ExtendedNetworkAddress  *)_odata).u.e163_4_address)->sub_address).value - (char *)&(((*(_ExtendedNetworkAddress  *)_odata).u.e163_4_address)->sub_address))))
			    return 1;
		    }
		}   break;
		case 2: {
		    if (((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).bit_mask ^ (*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).bit_mask & 0x80000000) {
			if (_oss_cmp_unbnd_octet_ia(&((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).pSelector), &((*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).pSelector), sizeof(((*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).pSelector).length), sizeof(((*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).pSelector).value[0]), (unsigned int)((char *)&((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).pSelector).value - (char *)&((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).pSelector))))
			    return 1;
		    }
		    if (((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).bit_mask ^ (*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).bit_mask & 0x40000000) {
			if (_oss_cmp_unbnd_octet_ia(&((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).sSelector), &((*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).sSelector), sizeof(((*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).sSelector).length), sizeof(((*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).sSelector).value[0]), (unsigned int)((char *)&((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).sSelector).value - (char *)&((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).sSelector))))
			    return 1;
		    }
		    if (((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).bit_mask ^ (*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).bit_mask) & 0x20000000)
			return 1;
		    if ((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).bit_mask & 0x20000000) {
			if (_oss_cmp_unbnd_octet_ia(&((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).tSelector), &((*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).tSelector), sizeof(((*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).tSelector).length), sizeof(((*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).tSelector).value[0]), (unsigned int)((char *)&((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).tSelector).value - (char *)&((*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).tSelector))))
			    return 1;
		    }
		    {
			_seqof1 *  _s_3 = (*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).nAddresses;
			_seqof1 *  _d_3 = (*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).nAddresses;
			long        *_a, _i, _i_next, _c = 0L;

			while (_s_3 && _d_3) {
			    ++ _c;
			    _s_3 = _s_3->next;
			    _d_3 = _d_3->next;
			}
			if (_s_3 || _d_3)
			    return 1;
			if (_c) {
			    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			    for (_i = 0; _i < _c; _i ++)
				_a[_i] = _i;
			    _a[_c] = -1L;
			    for (_s_3 = (*(*(_ExtendedNetworkAddress  *)_odata).u.psap_address).nAddresses; _s_3; _s_3 = _s_3->next) {
				_i_next = _a[0]; _res = 1;
				for (_d_3 = (*(*(_ExtendedNetworkAddress  *)_cdata).u.psap_address).nAddresses, _i = 0L; _d_3 && _i_next >= 0L && _a[_i_next] >= 0L; _d_3 = _d_3->next,
					_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				    if (_i < _i_next)
					continue;
				    if (_oss_cmp_unbnd_octet_ia(&(_s_3->value), &(_d_3->value), sizeof((_d_3->value).length), sizeof((_d_3->value).value[0]), (unsigned int)((char *)&(_s_3->value).value - (char *)&(_s_3->value))))
					continue;
				    _res = 0; _a[_i] = _a[_i+1];
				    break;
				}
				if (_res)
				    break;
			    }
			    _oss_dec_freetempmem(_g, _a);
			    if (_res)
				return _res;
			}
		    }
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 81: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 82: {
	    {
		_BuiltInDomainDefinedAttributes *  _s_oss_tmp_1 = *(_BuiltInDomainDefinedAttributes * *)_odata;
		_BuiltInDomainDefinedAttributes *  _d_oss_tmp_1 = *(_BuiltInDomainDefinedAttributes * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_1->value).type), &((_d_oss_tmp_1->value).type), sizeof(((_d_oss_tmp_1->value).type).length), sizeof(((_d_oss_tmp_1->value).type).value[0]), (unsigned int)((char *)&((_s_oss_tmp_1->value).type).value - (char *)&((_s_oss_tmp_1->value).type))))
			return 1;
		    if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_1->value).value), &((_d_oss_tmp_1->value).value), sizeof(((_d_oss_tmp_1->value).value).length), sizeof(((_d_oss_tmp_1->value).value).value[0]), (unsigned int)((char *)&((_s_oss_tmp_1->value).value).value - (char *)&((_s_oss_tmp_1->value).value))))
			return 1;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 83: {
	    _res = _cmPrincipalName(_g, &(((*(_AuthPack_OLD  *)_odata).pkAuthenticator).kdc_name), &(((*(_AuthPack_OLD  *)_cdata).pkAuthenticator).kdc_name));
	    if (_res)
		return _res;
	    if (_oss_cmp_unbnd_octet_ia(&(((*(_AuthPack_OLD  *)_odata).pkAuthenticator).kdc_realm), &(((*(_AuthPack_OLD  *)_cdata).pkAuthenticator).kdc_realm), sizeof((((*(_AuthPack_OLD  *)_cdata).pkAuthenticator).kdc_realm).length), sizeof((((*(_AuthPack_OLD  *)_cdata).pkAuthenticator).kdc_realm).value[0]), (unsigned int)((char *)&(((*(_AuthPack_OLD  *)_odata).pkAuthenticator).kdc_realm).value - (char *)&(((*(_AuthPack_OLD  *)_odata).pkAuthenticator).kdc_realm))))
		return 1;
	    if (((*(_AuthPack_OLD  *)_cdata).pkAuthenticator).cusec != ((*(_AuthPack_OLD  *)_odata).pkAuthenticator).cusec)
		return 1;
	    if (OSS_STRCMP(_g, ((*(_AuthPack_OLD  *)_cdata).pkAuthenticator).ctime, OSS_MAX_STR, ((*(_AuthPack_OLD  *)_odata).pkAuthenticator).ctime, _g->_res))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time(((*(_AuthPack_OLD  *)_cdata).pkAuthenticator).ctime, ((*(_AuthPack_OLD  *)_odata).pkAuthenticator).ctime, 0))
#endif
		    return 1;
	    if (((*(_AuthPack_OLD  *)_cdata).pkAuthenticator).nonce != ((*(_AuthPack_OLD  *)_odata).pkAuthenticator).nonce)
		return 1;
	} break;
	case 84: {
	    _res = _cmEncryptionKey(_g, &((*(_KERB_REPLY_KEY_PACKAGE  *)_odata).replyKey), &((*(_KERB_REPLY_KEY_PACKAGE  *)_cdata).replyKey));
	    if (_res)
		return _res;
	    if ((*(_KERB_REPLY_KEY_PACKAGE  *)_cdata).nonce != (*(_KERB_REPLY_KEY_PACKAGE  *)_odata).nonce)
		return 1;
	} break;
	case 85: {
	    _res = _cmPrincipalName(_g, &((*(_PA_FOR_USER_ENC  *)_odata).userName), &((*(_PA_FOR_USER_ENC  *)_cdata).userName));
	    if (_res)
		return _res;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_PA_FOR_USER_ENC  *)_odata).userRealm), &((*(_PA_FOR_USER_ENC  *)_cdata).userRealm), sizeof(((*(_PA_FOR_USER_ENC  *)_cdata).userRealm).length), sizeof(((*(_PA_FOR_USER_ENC  *)_cdata).userRealm).value[0]), (unsigned int)((char *)&((*(_PA_FOR_USER_ENC  *)_odata).userRealm).value - (char *)&((*(_PA_FOR_USER_ENC  *)_odata).userRealm))))
		return 1;
	    _res = _cmChecksum(_g, &((*(_PA_FOR_USER_ENC  *)_odata).cksum), &((*(_PA_FOR_USER_ENC  *)_cdata).cksum));
	    if (_res)
		return _res;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_PA_FOR_USER_ENC  *)_odata).auth_package), &((*(_PA_FOR_USER_ENC  *)_cdata).auth_package), sizeof(((*(_PA_FOR_USER_ENC  *)_cdata).auth_package).length), sizeof(((*(_PA_FOR_USER_ENC  *)_cdata).auth_package).value[0]), (unsigned int)((char *)&((*(_PA_FOR_USER_ENC  *)_odata).auth_package).value - (char *)&((*(_PA_FOR_USER_ENC  *)_odata).auth_package))))
		return 1;
	} break;
	case 86: {
	    if (((*(_PA_S4U_X509_USER  *)_cdata).user_id).nonce != ((*(_PA_S4U_X509_USER  *)_odata).user_id).nonce)
		return 1;
	    if ((((*(_PA_S4U_X509_USER  *)_odata).user_id).bit_mask ^ ((*(_PA_S4U_X509_USER  *)_cdata).user_id).bit_mask) & 0x80000000)
		return 1;
	    if (((*(_PA_S4U_X509_USER  *)_odata).user_id).bit_mask & 0x80000000) {
		_res = _cmPrincipalName(_g, &(((*(_PA_S4U_X509_USER  *)_odata).user_id).cname), &(((*(_PA_S4U_X509_USER  *)_cdata).user_id).cname));
		if (_res)
		    return _res;
	    }
	    if (_oss_cmp_unbnd_octet_ia(&(((*(_PA_S4U_X509_USER  *)_odata).user_id).crealm), &(((*(_PA_S4U_X509_USER  *)_cdata).user_id).crealm), sizeof((((*(_PA_S4U_X509_USER  *)_cdata).user_id).crealm).length), sizeof((((*(_PA_S4U_X509_USER  *)_cdata).user_id).crealm).value[0]), (unsigned int)((char *)&(((*(_PA_S4U_X509_USER  *)_odata).user_id).crealm).value - (char *)&(((*(_PA_S4U_X509_USER  *)_odata).user_id).crealm))))
		return 1;
	    if ((((*(_PA_S4U_X509_USER  *)_odata).user_id).bit_mask ^ ((*(_PA_S4U_X509_USER  *)_cdata).user_id).bit_mask) & 0x40000000)
		return 1;
	    if (((*(_PA_S4U_X509_USER  *)_odata).user_id).bit_mask & 0x40000000) {
		if (_oss_cmp_unbnd_octet_ia(&(((*(_PA_S4U_X509_USER  *)_odata).user_id).subject_certificate), &(((*(_PA_S4U_X509_USER  *)_cdata).user_id).subject_certificate), sizeof((((*(_PA_S4U_X509_USER  *)_cdata).user_id).subject_certificate).length), sizeof((((*(_PA_S4U_X509_USER  *)_cdata).user_id).subject_certificate).value[0]), (unsigned int)((char *)&(((*(_PA_S4U_X509_USER  *)_odata).user_id).subject_certificate).value - (char *)&(((*(_PA_S4U_X509_USER  *)_odata).user_id).subject_certificate))))
		    return 1;
	    }
	    if ((((*(_PA_S4U_X509_USER  *)_odata).user_id).bit_mask ^ ((*(_PA_S4U_X509_USER  *)_cdata).user_id).bit_mask) & 0x20000000)
		return 1;
	    if (((*(_PA_S4U_X509_USER  *)_odata).user_id).bit_mask & 0x20000000) {
		if (_oss_cmp_arrbits((((*(_PA_S4U_X509_USER  *)_odata).user_id).options).value, (((*(_PA_S4U_X509_USER  *)_cdata).user_id).options).value, (((*(_PA_S4U_X509_USER  *)_odata).user_id).options).length, (((*(_PA_S4U_X509_USER  *)_cdata).user_id).options).length))
		    return 1;
	    }
	    _res = _cmChecksum(_g, &((*(_PA_S4U_X509_USER  *)_odata).checksum), &((*(_PA_S4U_X509_USER  *)_cdata).checksum));
	    if (_res)
		return _res;
	} break;
	case 87: {
	    if (_oss_cmp_arrbits(((*(_PA_PAC_OPTIONS  *)_odata).kerberosFlags).value, ((*(_PA_PAC_OPTIONS  *)_cdata).kerberosFlags).value, ((*(_PA_PAC_OPTIONS  *)_odata).kerberosFlags).length, ((*(_PA_PAC_OPTIONS  *)_cdata).kerberosFlags).length))
		return 1;
	} break;
	case 88: {
	    if (((*(_KERB_PA_PAC_REQUEST  *)_cdata).include_pac ^ (*(_KERB_PA_PAC_REQUEST  *)_odata).include_pac) & 0x01)
		return 1;
	} break;
	case 89: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 90: {
	    if ((*(_KERB_AD_RESTRICTION_ENTRY  *)_cdata).restriction_type != (*(_KERB_AD_RESTRICTION_ENTRY  *)_odata).restriction_type)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_KERB_AD_RESTRICTION_ENTRY  *)_odata).restriction), &((*(_KERB_AD_RESTRICTION_ENTRY  *)_cdata).restriction), sizeof(((*(_KERB_AD_RESTRICTION_ENTRY  *)_cdata).restriction).length), sizeof(((*(_KERB_AD_RESTRICTION_ENTRY  *)_cdata).restriction).value[0]), (unsigned int)((char *)&((*(_KERB_AD_RESTRICTION_ENTRY  *)_odata).restriction).value - (char *)&((*(_KERB_AD_RESTRICTION_ENTRY  *)_odata).restriction))))
		return 1;
	} break;
	case 91: {
	    if (*(OSS_INT32  *)_cdata != *(OSS_INT32  *)_odata)
		return 1;
	} break;
	default:
	    return PDU_RANGE;
    }
    (void)_g;

    return _res;
}
#endif /* OSS_COMPARE_VALUE */

/* Entry points */
static const _entry_point_struct _entry_points = {_ossinit_cbd_asn1, _emMS_SFU_KILE, _dmMS_SFU_KILE, 
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
_fmMS_SFU_KILE,
#else
NULL, 
#endif
117,
 NULL, NULL, 0, 0, NULL,
#ifdef OSSPRINT
_pmMS_SFU_KILE
#else
NULL
#endif
};
static void _oss_post_init(struct ossGlobal *world) {
    static const unsigned char _oss_typeinfo[] = {
        0x00, 0x83, 0x34, 0x6c, 0x9c, 0x25, 0xfe, 0xf1, 0x7e, 0x63,
        0xd6, 0xaa, 0x7e, 0xf2, 0xd6, 0x63, 0x12, 0x17, 0xc0, 0xd5,
        0x72, 0x91, 0xdb, 0x5c, 0xab, 0x9f, 0x7f, 0x6a, 0xde, 0x72,
        0x1f, 0xd6, 0x2e, 0xa7, 0x85, 0x0d, 0x4a, 0xf7, 0xcd, 0xc6,
        0x55, 0x4c, 0xed, 0xa3, 0x30, 0x45, 0xb4, 0x4c, 0xf8, 0x4d,
        0x99, 0x62, 0x6f, 0xce, 0x45, 0xe7, 0xe1, 0x7c, 0x67, 0x7b,
        0xe6, 0x67, 0x26, 0x8f, 0x9e, 0x9f, 0x63, 0x4f, 0xf7, 0x8e,
        0x4d, 0xa5, 0x18, 0x9e, 0x07, 0xaa, 0x1d, 0x9c, 0x14, 0x15,
        0x75, 0x19, 0xbb, 0xd4, 0xa0, 0xe0, 0x29, 0x43, 0x2e, 0x29,
        0x62, 0xf7, 0x5b, 0xc4, 0x01, 0xdb, 0xb1, 0x45, 0x6d, 0x91,
        0xd5, 0x15, 0x25, 0x4a, 0xf8, 0x47, 0xa5, 0x45, 0x65, 0x01,
        0x77, 0x86, 0x7c, 0xc9, 0x79, 0xa9, 0x52, 0x58, 0x57, 0xd8,
        0x05, 0x78, 0x3a, 0x4f, 0x20, 0xe6, 0xfe, 0xb7, 0x8f, 0x00,
        0xa9, 0x4b, 0x28
    };
    ossInitRootContext1(world, (unsigned char *)_oss_typeinfo);
#if (OSS_TOED_API_LEVEL > 35)
#if (OSSDEBUG == 0)
    ossLinkZeroMsgs(world);
#elif defined(OSS_REDUCED_ERROR_MSGS)
    ossLinkIdMsgs(world);
#else
    ossLinkFullMsgs(world);
#endif
#endif
}

} /* extern "C" */

void *cbd_asn1_TableType::internal = (void *)&_entry_points;
