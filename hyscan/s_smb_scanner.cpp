#include "s_smb_scanner.h"

extern vector<NtlmInfo> g_vNtlmInfo;
extern mutex g_vMutex;
const TCHAR NTLMSSP_SMB_NEGOTIATE[] = { 
	0x00, 0x00, 0x00, 0x85, 0xFF, 0x53, 0x4D, 0x42, 0x72, 0x00, 0x00, 0x00, 0x00, 0x18, 0x53, 0xC8,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x02, 0x50, 0x43, 0x20, 0x4E, 0x45, 0x54, 0x57, 0x4F,
	0x52, 0x4B, 0x20, 0x50, 0x52, 0x4F, 0x47, 0x52, 0x41, 0x4D, 0x20, 0x31, 0x2E, 0x30, 0x00, 0x02,
	0x4C, 0x41, 0x4E, 0x4D, 0x41, 0x4E, 0x31, 0x2E, 0x30, 0x00, 0x02, 0x57, 0x69, 0x6E, 0x64, 0x6F,
	0x77, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x57, 0x6F, 0x72, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x70,
	0x73, 0x20, 0x33, 0x2E, 0x31, 0x61, 0x00, 0x02, 0x4C, 0x4D, 0x31, 0x2E, 0x32, 0x58, 0x30, 0x30,
	0x32, 0x00, 0x02, 0x4C, 0x41, 0x4E, 0x4D, 0x41, 0x4E, 0x32, 0x2E, 0x31, 0x00, 0x02, 0x4E, 0x54,
	0x20, 0x4C, 0x4D, 0x20, 0x30, 0x2E, 0x31, 0x32, 0x00 };

const TCHAR NTLMSSP_NEGOTIATE[] = {
	0x00, 0x00, 0x01, 0x0A, 0xFF, 0x53, 0x4D, 0x42, 0x73, 0x00, 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE,
	0x00, 0x00, 0x40, 0x00, 0x0C, 0xFF, 0x00, 0x0A, 0x01, 0x04, 0x41, 0x32, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x4A, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0x00, 0x00, 0xA0, 0xCF, 0x00, 0x60,
	0x48, 0x06, 0x06, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x02, 0xA0, 0x3E, 0x30, 0x3C, 0xA0, 0x0E, 0x30,
	0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x02, 0x0A, 0xA2, 0x2A, 0x04,
	0x28, 0x4E, 0x54, 0x4C, 0x4D, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x82, 0x08,
	0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x05, 0x02, 0xCE, 0x0E, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x57, 0x00, 0x69, 0x00, 0x6E, 0x00,
	0x64, 0x00, 0x6F, 0x00, 0x77, 0x00, 0x73, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00,
	0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x33, 0x00,
	0x20, 0x00, 0x33, 0x00, 0x37, 0x00, 0x39, 0x00, 0x30, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x20, 0x00, 0x50, 0x00, 0x61, 0x00,
	0x63, 0x00, 0x6B, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x69, 0x00,
	0x6E, 0x00, 0x64, 0x00, 0x6F, 0x00, 0x77, 0x00, 0x73, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00,
	0x33, 0x00, 0x20, 0x00, 0x35, 0x00, 0x2E, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};


SMBScanner::SMBScanner()
{
	
}


SMBScanner::~SMBScanner()
{
	
}


void SMBScanner::check(string& ipAddr){
	if (!s_net_scanner::checkAliveReturn(ipAddr)){
		SOCKET clientSocket;
		TcpClient tcpClient;
		string receiveData;
		int iPacketSize;
		if (!tcpClient.initWinSock())
		{
			if (!tcpClient.createSocket(clientSocket))
			{
				if (!tcpClient.connectSocket(clientSocket, ipAddr.c_str(), SMBPORT))
				{
					if (!tcpClient.sendData(clientSocket, string((char*)NTLMSSP_SMB_NEGOTIATE, sizeof(NTLMSSP_SMB_NEGOTIATE) / sizeof(NTLMSSP_SMB_NEGOTIATE[0]))))
					{
						if (!tcpClient.receiveData(clientSocket, receiveData, &iPacketSize))
						{
							receiveData.clear();
							if (!tcpClient.sendData(clientSocket, string((char*)NTLMSSP_NEGOTIATE, sizeof(NTLMSSP_NEGOTIATE) / sizeof(NTLMSSP_NEGOTIATE[0]))))
							{
								if (!tcpClient.receiveData(clientSocket, receiveData, &iPacketSize))
								{
									NtlmInfo ntlmInfo;
									RtlZeroMemory(&ntlmInfo, sizeof(NtlmInfo));
									memcpy(ntlmInfo.ipAddr, ipAddr.c_str(), 0x10); // 111.111.111.111
									if (receiveData.substr(BASE_SMB_NTLMSSP, 7) == NTLMSSP_SIGNTURE)
										NtlmParser::parser(receiveData, &ntlmInfo, BASE_SMB_NTLMSSP);
									else if (receiveData.substr(BASE_SMB_NTLMSSP + 2, 7) == NTLMSSP_SIGNTURE)
										NtlmParser::parser(receiveData, &ntlmInfo, BASE_SMB_NTLMSSP + 2);
									closesocket(clientSocket);
									g_vMutex.lock();
									g_vNtlmInfo.push_back(ntlmInfo);
									g_vMutex.unlock();
								}
							}
						}
					}
				}
			}
		}
	}
}

void SMBScanner::pth(string& ipAddr){
	WNET_API wnetApi;
	if (!s_net_scanner::checkAliveReturn(ipAddr)){
		if (wnetApi.openConnectBySelf(ipAddr) == IPC_SUCCESS){
			printf("[+] SMB PTH %s Successed\n", ipAddr.data());
		}
	}
}

void SMBScanner::pth2(string& ipAddr, string& username, string& password){
	WNET_API wnetApi;
	if (!s_net_scanner::checkAliveReturn(ipAddr)){
		if (wnetApi.openConnectByUserPass(ipAddr, username, password) == IPC_SUCCESS){
			printf("[+] SMB PTH %s Successed\n", ipAddr.data());
		}
	}
}
